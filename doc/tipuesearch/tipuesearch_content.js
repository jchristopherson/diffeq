var tipuesearch = {"pages":[{"title":" DIFFEQ ","text":"DIFFEQ Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"adams_fixed_integerator – DIFFEQ ","text":"type, public, extends( fixed_multistep_integrator ) :: adams_fixed_integerator Defines a fixed-step, 4th-order, Adams-Bashforth-Moulton PECE \nintegrator. Contents Type-Bound Procedures get_order solve step Type-Bound Procedures procedure, public :: get_order => afi_get_order Returns the order of the integrator. private pure module function afi_get_order(this) result(rst) Returns the order of the integrator. Arguments Type Intent Optional Attributes Name class( adams_fixed_integerator ), intent(in) :: this The adams_fixed_integerator object. Return Value integer(kind=int32) The order of the integrator. procedure, public :: solve => fms_solver Solves the supplied system of ODEs. private  function fms_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( fixed_multistep_integrator ), intent(inout) :: this The fixed_multistep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure, public :: step => afi_step Takes a single fixed-size integration step. private module subroutine afi_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Takes a single fixed-size integration step. Arguments Type Intent Optional Attributes Name class( adams_fixed_integerator ), intent(inout) :: this The adams_fixed_integerator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not\n     sized appropriately. DIFFEQ_MATRIX_SIZE_ERROR: Occurs if any of the input matrices are\n     not sized appropriately. DIFFEQ_MISSING_ARGUMENT_ERROR: Occurs if xprev, yprev, and/or\n     fprev are not provided.","tags":"","loc":"type\\adams_fixed_integerator.html"},{"title":"ode_container – DIFFEQ ","text":"type, public :: ode_container A container for the routine containing the ODEs to integrate. Contents Variables fcn jacobian mass_matrix Type-Bound Procedures compute_jacobian get_finite_difference_step get_is_mass_matrix_dependent get_is_ode_defined ode set_finite_difference_step set_is_mass_matrix_dependent Components Type Visibility Attributes Name Initial procedure( ode ), public, pointer, nopass :: fcn => null() A pointer to the routine containing the ODEs to integrate. procedure( ode_jacobian ), public, pointer, nopass :: jacobian => null() A pointer to the routine containing the analytical Jacobian.\nIf supplied, this routine is utilized; however, if null, a finite\ndifference approximation is utilized. procedure( ode_mass_matrix ), public, pointer, nopass :: mass_matrix => null() A pointer to the routine containing the mass matrix for the\nsystem.  If set to null (the default), an identity mass matrix \nwill be assumed. Type-Bound Procedures procedure, public :: compute_jacobian => oc_jacobian private  subroutine oc_jacobian(this, x, y, jac, err) Computes the Jacobian matrix for the system of ODEs.  If\na routine is provided with an analytical Jacobian, the supplied\nroutine is utilized; else, the Jacobian is estimated via a forward\ndifference approximation. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. real(kind=real64), intent(in) :: x The current independent variable value. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current dependent\nvariable values. real(kind=real64), intent(out), dimension(:,:) :: jac An N-by-N matrix where the Jacobian will be written. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is defined,\n     and the calculation is being performed by finite differences. DIFFEQ_MATRIX_SIZE_ERROR: Occurs if jac is not N-by-N. procedure, public :: get_finite_difference_step => oc_get_fd_step private pure function oc_get_fd_step(this) result(rst) Gets the size of the step to use for the finite difference\ncalculations used to estimate the Jacobian. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value real(kind=real64) The step size. procedure, public :: get_is_mass_matrix_dependent => oc_get_is_mass_dependent private pure function oc_get_is_mass_dependent(this) result(rst) Gets a value determining if the mass matrix is state-dependent\nsuch that it requires updating at every integration step. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value logical True if the mass matrix is state-dependent such that it \nrequires updating at each integration step; else, false if the\nmass matrix is not state-dependent and can be treated as constant\nfor all integration steps. procedure, public :: get_is_ode_defined => oc_get_is_ode_defined private pure function oc_get_is_ode_defined(this) result(rst) Gets a logical value determining if the ODE routine has been defined. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value logical True if the ODE routine has been defined; else, false. procedure, public :: ode => oc_ode_fcn private  subroutine oc_ode_fcn(this, x, y, dydx) Evaluates the ODEs by evaluating the routine defined by\nfcn.  This routine may also be overidden to provide custom\nfunctionallity. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: dydx An N-element array where the output of each of the\nN ODEs will be written. procedure, public :: set_finite_difference_step => oc_set_fd_step private  subroutine oc_set_fd_step(this, x) Sets the size of the step to use for the finite difference\ncalculations used to estimate the Jacobian. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_is_mass_matrix_dependent => oc_set_is_mass_dependent private  subroutine oc_set_is_mass_dependent(this, x) Sets a value determining if the mass matrix is state-dependent\nsuch that it requires updating at every integration step. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. logical :: x True if the mass matrix is state-dependent such that it \nrequires updating at each integration step; else, false if the\nmass matrix is not state-dependent and can be treated as constant\nfor all integration steps.","tags":"","loc":"type\\ode_container.html"},{"title":"ode_integrator – DIFFEQ ","text":"type, public, abstract :: ode_integrator The most basic ODE integrator object capable of integrating\nsystems of ODE's. Contents Type-Bound Procedures get_order solve Type-Bound Procedures procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure( ode_solver ), public, deferred, pass :: solve Solves the supplied system of ODE's. function ode_solver(this, sys, x, iv, err) result(rst) Prototype Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE.","tags":"","loc":"type\\ode_integrator.html"},{"title":"fixed_step_integrator – DIFFEQ ","text":"type, public, abstract, extends( ode_integrator ) :: fixed_step_integrator Defines a fixed-step integrator. Contents Type-Bound Procedures get_order solve step Type-Bound Procedures procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: solve => fsi_solver Solves the supplied system of ODE's. private  function fsi_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure( ode_fixed_step ), public, deferred, pass :: step Takes a single integration step. subroutine ode_fixed_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Prototype Takes a single fixed-size integration step. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\fixed_step_integrator.html"},{"title":"implicit_rk_variable_integrator – DIFFEQ ","text":"type, public, abstract, extends( rk_variable_integrator ) :: implicit_rk_variable_integrator Defines an implicit Runge-Kutta variable-step integrator. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results build_factored_newton_matrix clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_is_jacobian_current get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_previous_step_size get_respect_x_max get_safety_factor get_stage_count get_step_size get_use_pi_controller initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_is_jacobian_current set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_previous_step_size set_respect_x_max set_safety_factor set_step_size set_up_interpolation set_use_pi_controller solve step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => rkv_attempt_step Attempts a single integration step. private  subroutine rkv_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at\nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the values of the error estimates wil\nbe written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure( build_factored_newton_matrix_routine ), public, deferred :: build_factored_newton_matrix Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. subroutine build_factored_newton_matrix_routine(this, sys, h, x, y, err) Prototype Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this class( ode_container ), intent(inout) :: sys real(kind=real64), intent(in) :: h real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y class(errors), intent(inout), optional, target :: err procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => irk_compute_next_step_size Computes the next step size. private  function irk_compute_next_step_size(this, hn, en, enm1) result(rst) Computes the next step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure( rkv_action ), public, deferred :: define_model Defines (initializes) the model parameters. subroutine rkv_action(this) Prototype Defines an action to undertake on a rk_variable_integrator \nobject. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: estimate_first_step_size => irk_estimate_first_step Computes an estimate to the first step size based upon the\ninitial function values. private pure function irk_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_is_jacobian_current => irk_get_is_jac_current Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private pure function irk_get_is_jac_current(this) result(rst) Gets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True if the Jacobian matrix is current; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_previous_step_size => irk_get_old_step Gets the most recent successful step size. private pure function irk_get_old_step(this) result(rst) Gets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure( rkv_get_integer_parameter ), public, deferred :: get_stage_count Gets the number of stages used by the integrator. pure function rkv_get_integer_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value integer(kind=int32) procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_use_pi_controller => irk_get_use_pi_controller Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private pure function irk_get_use_pi_controller(this) result(rst) Gets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: initialize => rkv_alloc_workspace Initializes the integrator. private  subroutine rkv_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling.  Possible errors and warning messages that may be \n encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure( variable_step_interpolation ), public, deferred :: interpolate Provides interpolation between integration points. subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Prototype Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure( rkv_get_boolean_parameter ), public, deferred :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. pure function rkv_get_boolean_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value logical procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_is_jacobian_current => irk_set_is_jac_current Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private  subroutine irk_set_is_jac_current(this, x) Sets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True if the Jacobian matrix is current; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_previous_step_size => irk_set_old_step Sets the most recent successful step size. private  subroutine irk_set_old_step(this, x) Sets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure( rkv_set_up_interp ), public, deferred :: set_up_interpolation Sets up the interpolation polynomial. subroutine rkv_set_up_interp(this, x, xn, y, yn, k) Prototype Sets up interpolation for the rk_variable_integrator object. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at x + h. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the values of the dependent\nvariables at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the values of the dependent\nvariables at x + h. real(kind=real64), intent(in), dimension(:,:) :: k procedure, public :: set_use_pi_controller => irk_set_use_pi_controller Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private  subroutine irk_set_use_pi_controller(this, x) Sets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\implicit_rk_variable_integrator.html"},{"title":"sdirk4_integrator – DIFFEQ ","text":"type, public, extends( sdirk_integrator ) :: sdirk4_integrator Defines a singly diagonally implicit 4th order Runge-Kutta \nintegrator suitable for integrating stiff systems of differential \nequations. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results build_factored_newton_matrix build_newton_matrix clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_is_jacobian_current get_max_integration_step_count get_max_newton_iteration_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_newton_tolerance get_next_step_size get_order get_previous_error_norm get_previous_step_size get_respect_x_max get_safety_factor get_stage_count get_step_size get_use_pi_controller initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_is_jacobian_current set_max_integration_step_count set_max_newton_iteration_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_newton_tolerance set_next_step_size set_previous_error_norm set_previous_step_size set_respect_x_max set_safety_factor set_step_size set_up_interpolation set_use_pi_controller solve solve_newton_stage step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => sdirk_attempt_step Attempts a single integration step. private  subroutine sdirk_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: build_factored_newton_matrix => sdirk_build_factored_matrix Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. private  subroutine sdirk_build_factored_matrix(this, sys, h, x, y, err) Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An array containing the current values of the dependent variables. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. procedure, public :: build_newton_matrix => sdirk_build_matrix Builds the system matrix of the form or if a mass matrix is defined. private  subroutine sdirk_build_matrix(this, h, jac, x, m, err) Builds the system matrix of the form or if a mass matrix is defined. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in), dimension(:,:) :: jac The current NEQN-by-NEQN Jacobian matrix. real(kind=real64), intent(out), dimension(:,:) :: x An NEQN-by-NEQN matrix where the output will be written. real(kind=real64), intent(in), optional, dimension(:,:) :: m An optional NEQN-by-NEQN mass matrix. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MATRIX_SIZE_ERROR: Occurs if any of the matrices are not\n     sized correctly. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => irk_compute_next_step_size Computes the next step size. private  function irk_compute_next_step_size(this, hn, en, enm1) result(rst) Computes the next step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure, public :: define_model => sd4_define_model Defines (initializes) the model parameters. private  subroutine sd4_define_model(this) Defines (initializes) the model parameters. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(inout) :: this The sdirk4_integrator object. procedure, public :: estimate_first_step_size => irk_estimate_first_step Computes an estimate to the first step size based upon the\ninitial function values. private pure function irk_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_is_jacobian_current => irk_get_is_jac_current Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private pure function irk_get_is_jac_current(this) result(rst) Gets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True if the Jacobian matrix is current; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_newton_iteration_count => sdirk_get_max_newton_iter Gets the maximum allowed number of Newton iterations. private pure function sdirk_get_max_newton_iter(this) result(rst) Gets the maximum allowed number of Newton iterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. Return Value integer(kind=int32) The iteration limit. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_newton_tolerance => sdirk_get_newton_tol Gets the tolerance used to check for convergence of the\nNewton iterations. private pure function sdirk_get_newton_tol(this) result(rst) Gets the tolerance used to check for convergence of the Newton \niterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. Return Value real(kind=real64) The tolerance. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_order => sd4_get_order Returns the order of the integrator. private pure function sd4_get_order(this) result(rst) Returns the order of the integrator. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(in) :: this The sdirk4_integrator object. Return Value integer(kind=int32) The order of the integrator, 4 in this case. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_previous_step_size => irk_get_old_step Gets the most recent successful step size. private pure function irk_get_old_step(this) result(rst) Gets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure, public :: get_stage_count => sd4_get_stage_count Gets the number of stages used by the integrator. private pure function sd4_get_stage_count(this) result(rst) Gets the number of stages used by the integrator. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(in) :: this The sdirk4_integrator object. Return Value integer(kind=int32) The number of stages, 6 in this case. procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_use_pi_controller => irk_get_use_pi_controller Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private pure function irk_get_use_pi_controller(this) result(rst) Gets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: initialize => sd4_alloc_workspace Initializes the integrator. private  subroutine sd4_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(inout) :: this The sdirk4_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure, public :: interpolate => sd4_interp Provides interpolation between integration points allowing for\ndense output. private  subroutine sd4_interp(this, xprev, yprev, xnew, x, y, err) Provides interpolation between integration points allowing for dense \noutput. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(in) :: this The sdirk4_integrator object. real(kind=real64), intent(in) :: xprev The previous value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the values of the dependent variables \nat xprev. real(kind=real64), intent(in) :: xnew The updated value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array containing the interpolated values for each \nequation. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. procedure, public :: is_fsal => sd4_is_fsal Determines if the integrator is an FSAL (first same as last)\nintegrator. private pure function sd4_is_fsal(this) result(rst) Determines if the integrator is an FSAL (first same as last) integrator. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(in) :: this The sdirk4_integrator object. Return Value logical Returns true as this is an FSAL integrator. procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_is_jacobian_current => irk_set_is_jac_current Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private  subroutine irk_set_is_jac_current(this, x) Sets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True if the Jacobian matrix is current; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_newton_iteration_count => sdirk_set_max_newton_iter Sets the maximum allowed number of Newton iterations. private  subroutine sdirk_set_max_newton_iter(this, x) Sets the maximum allowed number of Newton iterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. integer(kind=int32), intent(in) :: x The iteration limit. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_newton_tolerance => sdirk_set_newton_tol Sets the tolerance used to check for convergence of the\nNewton iterations. private  subroutine sdirk_set_newton_tol(this, x) Sets the tolerance used to check for convergence of the Newton \niterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. real(kind=real64), intent(in) :: x The tolerance. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_previous_step_size => irk_set_old_step Sets the most recent successful step size. private  subroutine irk_set_old_step(this, x) Sets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_up_interpolation => sd4_set_up_interp Sets up the interpolation polynomial. private  subroutine sd4_set_up_interp(this, x, xn, y, yn, k) Sets up the interpolation polynomial. Arguments Type Intent Optional Attributes Name class( sdirk4_integrator ), intent(inout) :: this The sdirk4_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. real(kind=real64), intent(in), dimension(:,:) :: k An N-by-M matrix containing the intermediate step function outputs \nwhere M is the number of stages of the integrator. procedure, public :: set_use_pi_controller => irk_set_use_pi_controller Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private  subroutine irk_set_use_pi_controller(this, x) Sets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: solve_newton_stage => sdirk_solve_newton Solves the Newton iteration problem for the i-th stage. private  subroutine sdirk_solve_newton(this, sys, i, h, x, y, yw, accept, niter) Solves the Newton iteration problem for the i-th stage. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. integer(kind=int32), intent(in) :: i The current stage number. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yw An N-element workspace array. logical, intent(out) :: accept Returns true if the Newton iteration reached convergence; else, \nfalse if the iteration did not converge. integer(kind=int32), intent(out) :: niter The number of iterations performed. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\sdirk4_integrator.html"},{"title":"sdirk_integrator – DIFFEQ ","text":"type, public, abstract, extends( implicit_rk_variable_integrator ) :: sdirk_integrator Defines a base structure for singly diagonally implicit \nRunge-Kutta integrators. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results build_factored_newton_matrix build_newton_matrix clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_is_jacobian_current get_max_integration_step_count get_max_newton_iteration_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_newton_tolerance get_next_step_size get_order get_previous_error_norm get_previous_step_size get_respect_x_max get_safety_factor get_stage_count get_step_size get_use_pi_controller initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_is_jacobian_current set_max_integration_step_count set_max_newton_iteration_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_newton_tolerance set_next_step_size set_previous_error_norm set_previous_step_size set_respect_x_max set_safety_factor set_step_size set_up_interpolation set_use_pi_controller solve solve_newton_stage step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => sdirk_attempt_step Attempts a single integration step. private  subroutine sdirk_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: build_factored_newton_matrix => sdirk_build_factored_matrix Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. private  subroutine sdirk_build_factored_matrix(this, sys, h, x, y, err) Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An array containing the current values of the dependent variables. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. procedure, public :: build_newton_matrix => sdirk_build_matrix Builds the system matrix of the form or if a mass matrix is defined. private  subroutine sdirk_build_matrix(this, h, jac, x, m, err) Builds the system matrix of the form or if a mass matrix is defined. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in), dimension(:,:) :: jac The current NEQN-by-NEQN Jacobian matrix. real(kind=real64), intent(out), dimension(:,:) :: x An NEQN-by-NEQN matrix where the output will be written. real(kind=real64), intent(in), optional, dimension(:,:) :: m An optional NEQN-by-NEQN mass matrix. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MATRIX_SIZE_ERROR: Occurs if any of the matrices are not\n     sized correctly. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => irk_compute_next_step_size Computes the next step size. private  function irk_compute_next_step_size(this, hn, en, enm1) result(rst) Computes the next step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure( rkv_action ), public, deferred :: define_model Defines (initializes) the model parameters. subroutine rkv_action(this) Prototype Defines an action to undertake on a rk_variable_integrator \nobject. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: estimate_first_step_size => irk_estimate_first_step Computes an estimate to the first step size based upon the\ninitial function values. private pure function irk_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_is_jacobian_current => irk_get_is_jac_current Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private pure function irk_get_is_jac_current(this) result(rst) Gets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True if the Jacobian matrix is current; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_newton_iteration_count => sdirk_get_max_newton_iter Gets the maximum allowed number of Newton iterations. private pure function sdirk_get_max_newton_iter(this) result(rst) Gets the maximum allowed number of Newton iterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. Return Value integer(kind=int32) The iteration limit. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_newton_tolerance => sdirk_get_newton_tol Gets the tolerance used to check for convergence of the\nNewton iterations. private pure function sdirk_get_newton_tol(this) result(rst) Gets the tolerance used to check for convergence of the Newton \niterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(in) :: this The sdirk_integrator object. Return Value real(kind=real64) The tolerance. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_previous_step_size => irk_get_old_step Gets the most recent successful step size. private pure function irk_get_old_step(this) result(rst) Gets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure( rkv_get_integer_parameter ), public, deferred :: get_stage_count Gets the number of stages used by the integrator. pure function rkv_get_integer_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value integer(kind=int32) procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_use_pi_controller => irk_get_use_pi_controller Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private pure function irk_get_use_pi_controller(this) result(rst) Gets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(in) :: this The implicit_rk_variable_integrator object. Return Value logical True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: initialize => sdirk_alloc_workspace Initializes the integrator. private  subroutine sdirk_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure( variable_step_interpolation ), public, deferred :: interpolate Provides interpolation between integration points. subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Prototype Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure( rkv_get_boolean_parameter ), public, deferred :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. pure function rkv_get_boolean_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value logical procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_is_jacobian_current => irk_set_is_jac_current Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. private  subroutine irk_set_is_jac_current(this, x) Sets a value determining if the Jacobian matrix estimate is current such \nthat it does not need to be recomputed at this time. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True if the Jacobian matrix is current; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_newton_iteration_count => sdirk_set_max_newton_iter Sets the maximum allowed number of Newton iterations. private  subroutine sdirk_set_max_newton_iter(this, x) Sets the maximum allowed number of Newton iterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. integer(kind=int32), intent(in) :: x The iteration limit. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_newton_tolerance => sdirk_set_newton_tol Sets the tolerance used to check for convergence of the\nNewton iterations. private  subroutine sdirk_set_newton_tol(this, x) Sets the tolerance used to check for convergence of the Newton \niterations. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. real(kind=real64), intent(in) :: x The tolerance. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_previous_step_size => irk_set_old_step Sets the most recent successful step size. private  subroutine irk_set_old_step(this, x) Sets the most recent successful step size. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure( rkv_set_up_interp ), public, deferred :: set_up_interpolation Sets up the interpolation polynomial. subroutine rkv_set_up_interp(this, x, xn, y, yn, k) Prototype Sets up interpolation for the rk_variable_integrator object. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at x + h. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the values of the dependent\nvariables at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the values of the dependent\nvariables at x + h. real(kind=real64), intent(in), dimension(:,:) :: k procedure, public :: set_use_pi_controller => irk_set_use_pi_controller Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. private  subroutine irk_set_use_pi_controller(this, x) Sets a parameter determining if a PI step size controller or a Gustafsson\nstep size controller should be used. The default is to use a PI step \nsize controller. Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this The implicit_rk_variable_integrator object. logical, intent(in) :: x True to use a PI controller; else, false to use a Gustafsson \ncontroller. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: solve_newton_stage => sdirk_solve_newton Solves the Newton iteration problem for the i-th stage. private  subroutine sdirk_solve_newton(this, sys, i, h, x, y, yw, accept, niter) Solves the Newton iteration problem for the i-th stage. Arguments Type Intent Optional Attributes Name class( sdirk_integrator ), intent(inout) :: this The sdirk_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. integer(kind=int32), intent(in) :: i The current stage number. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yw An N-element workspace array. logical, intent(out) :: accept Returns true if the Newton iteration reached convergence; else, \nfalse if the iteration did not converge. integer(kind=int32), intent(out) :: niter The number of iterations performed. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\sdirk_integrator.html"},{"title":"fixed_multistep_integrator – DIFFEQ ","text":"type, public, abstract, extends( fixed_step_integrator ) :: fixed_multistep_integrator Defines a fixed step-size, multi-step integrator. Contents Type-Bound Procedures get_order solve step Type-Bound Procedures procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: solve => fms_solver Solves the supplied system of ODEs. private  function fms_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( fixed_multistep_integrator ), intent(inout) :: this The fixed_multistep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure( ode_fixed_step ), public, deferred, pass :: step Takes a single integration step. subroutine ode_fixed_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Prototype Takes a single fixed-size integration step. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\fixed_multistep_integrator.html"},{"title":"rk4_fixed_integrator – DIFFEQ ","text":"type, public, extends( rk_fixed_integrator ) :: rk4_fixed_integrator Defines the explicit, 4th order, Runge-Kutta fixed-step \nintegrator. Contents Type-Bound Procedures get_method_factor get_order get_position_factor get_quadrature_weight solve step Type-Bound Procedures procedure, public :: get_method_factor => rk4_get_a_param Gets the requested method factor from the Butcher tableau. private pure function rk4_get_a_param(this, i, j) result(rst) Gets the requested method factor from the Butcher tableau. Arguments Type Intent Optional Attributes Name class( rk4_fixed_integrator ), intent(in) :: this The rk4_fixed_integrator object. integer(kind=int32), intent(in) :: i The row index of the parameter from the Butcher tableau. integer(kind=int32), intent(in) :: j The column index of the parameter from the Butcher tableau. Return Value real(kind=real64) The requested parameter. procedure, public :: get_order => rk4_get_order Returns the order of the integrator. private pure function rk4_get_order(this) result(rst) Returns the order of the integrator. Arguments Type Intent Optional Attributes Name class( rk4_fixed_integrator ), intent(in) :: this The rk4_fixed_integrator object. Return Value integer(kind=int32) The order of the integrator. procedure, public :: get_position_factor => rk4_get_c_param Gets the requested position factor from the Butcher tableau. private pure function rk4_get_c_param(this, i) result(rst) Gets the requested position factor from the Butcher tableau. Arguments Type Intent Optional Attributes Name class( rk4_fixed_integrator ), intent(in) :: this The rk4_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the parameter from the Butcher tableau. Return Value real(kind=real64) The requested parameter. procedure, public :: get_quadrature_weight => rk4_get_b_param Gets the requested quadrature weight from the Butcher tableau. private pure function rk4_get_b_param(this, i) result(rst) Gets the requested quadrature weight from the Butcher tableau. Arguments Type Intent Optional Attributes Name class( rk4_fixed_integrator ), intent(in) :: this The rk4_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the parameter from the Butcher tableau. Return Value real(kind=real64) The requested parameter. procedure, public :: solve => fsi_solver Solves the supplied system of ODE's. private  function fsi_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure, public :: step => rkf_step Takes a single Runge-Kutta integration step. private  subroutine rkf_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Takes a single Runge-Kutta integration step. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(inout) :: this The rk_fixed_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible error and warning messages that\nmay be encountered are as follows. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if yn is not sized appropriately.","tags":"","loc":"type\\rk4_fixed_integrator.html"},{"title":"rk_fixed_integrator – DIFFEQ ","text":"type, public, abstract, extends( fixed_step_integrator ) :: rk_fixed_integrator Defines an explicit, Runge-Kutta fixed-step integrator. Contents Type-Bound Procedures get_method_factor get_order get_position_factor get_quadrature_weight solve step Type-Bound Procedures procedure( rkf_get_matrix_parameter ), public, deferred :: get_method_factor Gets the requested method factor from the Butcher tableau. pure function rkf_get_matrix_parameter(this, i, j) result(rst) Prototype Retrieves a parameter from a matrix stored by the\nrk_fixed_integrator object. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The row index of the matrix parameter to retrieve. integer(kind=int32), intent(in) :: j The column index of the matrix parameter to retrieve. Return Value real(kind=real64) The requested parameter. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure( rkf_get_array_parameter ), public, deferred :: get_position_factor Gets the requested position factor from the Butcher tableau. pure function rkf_get_array_parameter(this, i) result(rst) Prototype Retrieves a parameter from an array stored by the \nrk_fixed_integrator object. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the array parameter to retrieve. Return Value real(kind=real64) The requested parameter procedure( rkf_get_array_parameter ), public, deferred :: get_quadrature_weight Gets the requested quadrature weight from the Butcher tableau. pure function rkf_get_array_parameter(this, i) result(rst) Prototype Retrieves a parameter from an array stored by the \nrk_fixed_integrator object. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the array parameter to retrieve. Return Value real(kind=real64) The requested parameter procedure, public :: solve => fsi_solver Solves the supplied system of ODE's. private  function fsi_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure, public :: step => rkf_step Takes a single Runge-Kutta integration step. private  subroutine rkf_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Takes a single Runge-Kutta integration step. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(inout) :: this The rk_fixed_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible error and warning messages that\nmay be encountered are as follows. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if yn is not sized appropriately.","tags":"","loc":"type\\rk_fixed_integrator.html"},{"title":"bsrk32_integrator – DIFFEQ ","text":"type, public, extends( rk_variable_integrator ) :: bsrk32_integrator Defines the Bogacki-Shampine 3rd/2nd order integrator. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_respect_x_max get_safety_factor get_stage_count get_step_size initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_respect_x_max set_safety_factor set_step_size set_up_interpolation solve step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => rkv_attempt_step Attempts a single integration step. private  subroutine rkv_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at\nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the values of the error estimates wil\nbe written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => rkv_next_step Computes the next step size. private  function rkv_next_step(this, hn, en, enm1) result(rst) Computes the next step size using a PI type controller such that where is the safety factor and is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure, public :: define_model => bsrk32_define_model Defines (initializes) the model parameters. private  subroutine bsrk32_define_model(this) Defines (initializes) the model parameters. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(inout) :: this The bsrk32_integrator object. procedure, public :: estimate_first_step_size => vsi_estimate_first_step Computes an estimate to the first step size based upon the \ninitial function values. private pure function vsi_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_order => bsrk32_get_order Returns the order of the integrator. private pure function bsrk32_get_order(this) result(rst) Returns the order of the integrator. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(in) :: this The bsrk32_integrator object. Return Value integer(kind=int32) Returns the order of the integrator, 3 for this integrator. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure, public :: get_stage_count => bsrk32_get_stage_count Gets the number of stages used by the integrator. private pure function bsrk32_get_stage_count(this) result(rst) Gets the number of stages used by the integrator. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(in) :: this The bsrk32_integrator object. Return Value integer(kind=int32) Returns the number of stages, 4 for this integrator. procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: initialize => rkv_alloc_workspace Initializes the integrator. private  subroutine rkv_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling.  Possible errors and warning messages that may be \n encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure, public :: interpolate => bsrk32_interp Provides interpolation between integration points allowing for\ndense output. private  subroutine bsrk32_interp(this, xprev, yprev, xnew, x, y, err) Provides interpolation between integration points allowing for dense \noutput. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(in) :: this The bsrk32_integrator object. real(kind=real64), intent(in) :: xprev The previous value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the values of the dependent variables \nat xprev. real(kind=real64), intent(in) :: xnew The updated value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array containing the interpolated values for each \nequation. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. procedure, public :: is_fsal => bsrk32_is_fsal Determines if the integrator is an FSAL (first same as last)\nintegrator. private pure function bsrk32_is_fsal(this) result(rst) Determines if the integrator is an FSAL (first same as last)\nintegrator. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(in) :: this The bsrk32_integrator object. Return Value logical Returns true, as this integrator is a FSAL integrator. procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_up_interpolation => bsrk32_set_up_interp Sets up the interpolation polynomial. private  subroutine bsrk32_set_up_interp(this, x, xn, y, yn, k) Sets up the interpolation polynomial. Arguments Type Intent Optional Attributes Name class( bsrk32_integrator ), intent(inout) :: this The bsrk32_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution\nvalues. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at\nthe next step. real(kind=real64), intent(in), dimension(:,:) :: k An N-by-M matrix containing the intermediate step function outputs \nwhere M is the number of stages of the integrator. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\bsrk32_integrator.html"},{"title":"dprk45_integrator – DIFFEQ ","text":"type, public, extends( rk_variable_integrator ) :: dprk45_integrator Defines the classical Dormand-Prince 4th/5th order integrator. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_respect_x_max get_safety_factor get_stage_count get_step_size initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_respect_x_max set_safety_factor set_step_size set_up_interpolation solve step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => rkv_attempt_step Attempts a single integration step. private  subroutine rkv_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at\nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the values of the error estimates wil\nbe written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => rkv_next_step Computes the next step size. private  function rkv_next_step(this, hn, en, enm1) result(rst) Computes the next step size using a PI type controller such that where is the safety factor and is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure, public :: define_model => dprk45_define_model Defines (initializes) the model parameters. private  subroutine dprk45_define_model(this) Defines (initializes) the model parameters. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(inout) :: this The dprk45_integrator object. procedure, public :: estimate_first_step_size => vsi_estimate_first_step Computes an estimate to the first step size based upon the \ninitial function values. private pure function vsi_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: get_order => dprk45_get_order Returns the order of the integrator. private pure function dprk45_get_order(this) result(rst) Returns the order of the integrator. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(in) :: this The dprk45_integrator object. Return Value integer(kind=int32) Returns the order of the integrator, 5 for this integrator. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure, public :: get_stage_count => dprk45_get_stage_count Gets the number of stages used by the integrator. private pure function dprk45_get_stage_count(this) result(rst) Gets the number of stages used by the integrator. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(in) :: this The dprk45_integrator object. Return Value integer(kind=int32) Returns the number of stages, 7 for this integrator. procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: initialize => rkv_alloc_workspace Initializes the integrator. private  subroutine rkv_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling.  Possible errors and warning messages that may be \n encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure, public :: interpolate => dprk45_interp Provides interpolation between integration points allowing\nfor dense output. private  subroutine dprk45_interp(this, xprev, yprev, xnew, x, y, err) Provides interpolation between integration points allowing for dense \noutput. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(in) :: this The dprk45_integrator object. real(kind=real64), intent(in) :: xprev The previous value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the values of the dependent variables \nat xprev. real(kind=real64), intent(in) :: xnew The updated value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array containing the interpolated values for each \nequation. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. procedure, public :: is_fsal => dprk45_is_fsal Determines if the integrator is an FSAL (first same as last)\nintegrator (e.g. the 4th/5th order Dormand-Prince integrator). private pure function dprk45_is_fsal(this) result(rst) Determines if the integrator is an FSAL (first same as last)\nintegrator. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(in) :: this The dprk45_integrator object. Return Value logical Returns true, as this integrator is a FSAL integrator. procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_up_interpolation => dprk45_set_up_interp Sets up the interpolation polynomial. private  subroutine dprk45_set_up_interp(this, x, xn, y, yn, k) Sets up the interpolation polynomial. Arguments Type Intent Optional Attributes Name class( dprk45_integrator ), intent(inout) :: this The dprk45_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution\nvalues. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at\nthe next step. real(kind=real64), intent(in), dimension(:,:) :: k An N-by-M matrix containing the intermediate step function outputs \nwhere M is the number of stages of the integrator. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\dprk45_integrator.html"},{"title":"rk_variable_integrator – DIFFEQ ","text":"type, public, abstract, extends( variable_singlestep_integrator ) :: rk_variable_integrator @brief Defines a variable-step, Runge-Kutta integrator. Contents Variables a b c e f m_bufferCount Type-Bound Procedures attempt_step buffer_results clear_buffer compute_next_step_size define_model estimate_first_step_size get_alpha get_beta get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_is_first_step get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_respect_x_max get_safety_factor get_stage_count get_step_size initialize interpolate is_fsal on_successful_step reset set_alpha set_beta set_is_first_step set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_respect_x_max set_safety_factor set_step_size set_up_interpolation solve step Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure, public :: attempt_step => rkv_attempt_step Attempts a single integration step. private  subroutine rkv_attempt_step(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Attempts a single integration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent\nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at\nx + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the values of the error estimates wil\nbe written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure, public :: compute_next_step_size => rkv_next_step Computes the next step size. private  function rkv_next_step(this, hn, en, enm1) result(rst) Computes the next step size using a PI type controller such that where is the safety factor and is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. Return Value real(kind=real64) The new step size. procedure( rkv_action ), public, deferred :: define_model Defines (initializes) the model parameters. subroutine rkv_action(this) Prototype Defines an action to undertake on a rk_variable_integrator \nobject. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: estimate_first_step_size => vsi_estimate_first_step Computes an estimate to the first step size based upon the \ninitial function values. private pure function vsi_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_alpha => rkv_get_alpha Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_alpha(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_beta => rkv_get_beta Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private pure function rkv_get_beta(this) result(rst) Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value real(kind=real64) The parameter. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_is_first_step => rkv_get_is_first_step Gets a value determining if the integrator is set up to take its \nfirst integration step. private pure function rkv_get_is_first_step(this) result(rst) Gets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this The rk_variable_integrator object. Return Value logical True if the integrator is on its first step; else, false. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure( rkv_get_integer_parameter ), public, deferred :: get_stage_count Gets the number of stages used by the integrator. pure function rkv_get_integer_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value integer(kind=int32) procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure, public :: initialize => rkv_alloc_workspace Initializes the integrator. private  subroutine rkv_alloc_workspace(this, neqn, err) Initializes the integrator. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. integer(kind=int32), intent(in) :: neqn The number of equations being integrated. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \n can be used to retrieve information relating to any errors \n encountered during execution. If not provided, a default \n implementation of the errors class is used internally to provide \n error handling.  Possible errors and warning messages that may be \n encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. procedure( variable_step_interpolation ), public, deferred :: interpolate Provides interpolation between integration points. subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Prototype Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure( rkv_get_boolean_parameter ), public, deferred :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. pure function rkv_get_boolean_parameter(this) result(rst) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value logical procedure, public :: on_successful_step => rkv_on_successful_step Perform necessary actions on completion of a successful step. private  subroutine rkv_on_successful_step(this, x, xn, y, yn) Perform necessary actions on completion of a successful step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at the next step. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution values. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution values at the next step. procedure, public :: reset => rkv_reset Resets the integrator to its initial state. private  subroutine rkv_reset(this) Resets the integrator to its initial state. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. procedure, public :: set_alpha => rkv_set_alpha Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_alpha(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64) :: x The parameter. procedure, public :: set_beta => rkv_set_beta Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. private  subroutine rkv_set_beta(this, x) Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The parameter. procedure, public :: set_is_first_step => rkv_set_is_first_step Sets a value determining if the integrator is set up to take its \nfirst integration step. private  subroutine rkv_set_is_first_step(this, x) Sets a value determining if the integrator is set up to take its first\nintegration step. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. logical :: x True if the integrator is on its first step; else, false. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure( rkv_set_up_interp ), public, deferred :: set_up_interpolation Sets up the interpolation polynomial. subroutine rkv_set_up_interp(this, x, xn, y, yn, k) Prototype Sets up interpolation for the rk_variable_integrator object. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at x + h. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the values of the dependent\nvariables at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the values of the dependent\nvariables at x + h. real(kind=real64), intent(in), dimension(:,:) :: k procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\rk_variable_integrator.html"},{"title":"variable_singlestep_integrator – DIFFEQ ","text":"type, public, abstract, extends( variable_step_integrator ) :: variable_singlestep_integrator @brief Defines a variable-step, single-stage integrator. Contents Variables m_bufferCount Type-Bound Procedures attempt_step buffer_results clear_buffer compute_next_step_size estimate_first_step_size get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_respect_x_max get_safety_factor get_step_size interpolate on_successful_step set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_respect_x_max set_safety_factor set_step_size solve step Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure( variable_step_attempt ), public, deferred :: attempt_step Attempts a single integration step. subroutine variable_step_attempt(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Prototype Defines a routine meant to attempt a single integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the error estimates for each \nequation will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure( next_step_size_calculator ), public, deferred :: compute_next_step_size Computes the next step size. function next_step_size_calculator(this, hn, en, enm1) result(rst) Prototype Defines a routine for computing the next step size to attempt. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step. Return Value real(kind=real64) The next step size to try. procedure, public :: estimate_first_step_size => vsi_estimate_first_step Computes an estimate to the first step size based upon the \ninitial function values. private pure function vsi_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( variable_step_interpolation ), public, deferred :: interpolate Provides interpolation between integration points. subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Prototype Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure( variable_step_action ), public, deferred :: on_successful_step Perform necessary actions on completion of a successful step. subroutine variable_step_action(this, x, xn, y, yn) Prototype Defines a routine for performing any actions upon completion of\na successful step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The new value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the new values of the N\ndependent variables. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: solve => vssi_solve Solves the supplied system of ODEs. private  function vssi_solve(this, sys, x, iv, err) result(rst) Solves the supplied system of ODEs. Arguments Type Intent Optional Attributes Name class( variable_singlestep_integrator ), intent(inout) :: this The variable_singlestep_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, the\nintegration results will be returned at the supplied values. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes\n     too small. DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration\n     count is exceeded for a single step. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column contains\nthe values of the independent variable at which the results were\ncomputed.  The remaining columns contain the integration results\nfor each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\variable_singlestep_integrator.html"},{"title":"variable_step_integrator – DIFFEQ ","text":"type, public, abstract, extends( ode_integrator ) :: variable_step_integrator Defines a variable-step integrator. Contents Variables m_bufferCount Type-Bound Procedures attempt_step buffer_results clear_buffer compute_next_step_size estimate_first_step_size get_buffer_contents get_buffer_size get_default_absolute_tolerance get_default_relative_tolerance get_max_integration_step_count get_max_per_step_iteration_count get_max_step_size get_min_step_size get_next_step_size get_order get_previous_error_norm get_respect_x_max get_safety_factor get_step_size interpolate on_successful_step set_max_integration_step_count set_max_per_step_iteration_count set_max_step_size set_min_step_size set_next_step_size set_previous_error_norm set_respect_x_max set_safety_factor set_step_size solve step Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure( variable_step_attempt ), public, deferred :: attempt_step Attempts a single integration step. subroutine variable_step_attempt(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Prototype Defines a routine meant to attempt a single integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the error estimates for each \nequation will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: buffer_results => vsi_append_to_buffer Buffers a results set. private  subroutine vsi_append_to_buffer(this, x, y, err) Buffers a results set. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in) :: y (:) An N-element array containing the solution values. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling.  Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with\n     the buffer size. procedure, public :: clear_buffer => vsi_clear_buffer Clears the results buffer. private  subroutine vsi_clear_buffer(this) Clears the results buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. procedure( next_step_size_calculator ), public, deferred :: compute_next_step_size Computes the next step size. function next_step_size_calculator(this, hn, en, enm1) result(rst) Prototype Defines a routine for computing the next step size to attempt. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step. Return Value real(kind=real64) The next step size to try. procedure, public :: estimate_first_step_size => vsi_estimate_first_step Computes an estimate to the first step size based upon the \ninitial function values. private pure function vsi_estimate_first_step(this, xo, xf, yo, fo) result(rst) Computes an estimate to the first step size based upon the initial \nfunction values. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo An N-element array containing the initial values. real(kind=real64), intent(in), dimension(:) :: fo An N-element array containing the initial function values. Return Value real(kind=real64) An estimate on the initial step size. procedure, public :: get_buffer_contents => vsi_get_buffer_contents Returns the contents of the solution buffer. private  function vsi_get_buffer_contents(this) result(rst) Returns the contents of the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The buffer contents. procedure, public :: get_buffer_size => vsi_get_buffer_count Gets the number of entries into the solution buffer. private pure function vsi_get_buffer_count(this) result(rst) Gets the number of entries into the solution buffer. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The number of buffer entries. procedure, public :: get_default_absolute_tolerance => vsi_get_default_abs_tol Gets the default absolute error tolerance. private pure function vsi_get_default_abs_tol(this) result(rst) Gets the default absolute error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_default_relative_tolerance => vsi_get_default_rel_tol Gets the default relative error tolerance. private pure function vsi_get_default_rel_tol(this) result(rst) Gets the default relative error tolerance. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_integration_step_count => vsi_get_max_step_count Gets the maximum number of integration steps allowed. private pure function vsi_get_max_step_count(this) result(rst) Gets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum number of integration steps. procedure, public :: get_max_per_step_iteration_count => vsi_get_max_iter_count Gets the maximum number of iterations per step allowed. private pure function vsi_get_max_iter_count(this) result(rst) Gets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value integer(kind=int32) The maximum iteration count. procedure, public :: get_max_step_size => vsi_get_max_step Gets the maximum allowed step size. private pure function vsi_get_max_step(this) result(rst) Gets the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The maximum step size. procedure, public :: get_min_step_size => vsi_get_min_step Gets the minimum allowed step size. private pure function vsi_get_min_step(this) result(rst) Gets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The minimum step size. procedure, public :: get_next_step_size => vsi_get_next_step_size Gets the next step size. private pure function vsi_get_next_step_size(this) result(rst) Gets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_previous_error_norm => vsi_get_prev_err_norm Gets the norm of the previous step's error estimate. private pure function vsi_get_prev_err_norm(this) result(rst) Gets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The error norm. procedure, public :: get_respect_x_max => vsi_get_respect_xmax Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private pure function vsi_get_respect_xmax(this) result(rst) Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value logical True if the integrator should respect the limiting value of\n the independent variable; else, false. procedure, public :: get_safety_factor => vsi_get_safety_factor Gets a safety factor used to limit the predicted step size. private pure function vsi_get_safety_factor(this) result(rst) Gets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The safety factor value. procedure, public :: get_step_size => vsi_get_step_size Gets the current step size. private pure function vsi_get_step_size(this) result(rst) Gets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. Return Value real(kind=real64) The step size. procedure( variable_step_interpolation ), public, deferred :: interpolate Provides interpolation between integration points. subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Prototype Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure( variable_step_action ), public, deferred :: on_successful_step Perform necessary actions on completion of a successful step. subroutine variable_step_action(this, x, xn, y, yn) Prototype Defines a routine for performing any actions upon completion of\na successful step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The new value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the new values of the N\ndependent variables. procedure, public :: set_max_integration_step_count => vsi_set_max_step_count Sets the maximum number of integration steps allowed. private  subroutine vsi_set_max_step_count(this, x) Sets the maximum number of integration steps allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum number of integration steps. procedure, public :: set_max_per_step_iteration_count => vsi_set_max_iter_count Sets the maximum number of iterations per step allowed. private  subroutine vsi_set_max_iter_count(this, x) Sets the maximum number of iterations per step allowed. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. integer(kind=int32), intent(in) :: x The maximum iteration count. procedure, public :: set_max_step_size => vsi_set_max_step Sets the maximum allowed step size. private  subroutine vsi_set_max_step(this, x) Sets the maximum step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The maximum step size. procedure, public :: set_min_step_size => vsi_set_min_step Sets the minimum allowed step size. private  subroutine vsi_set_min_step(this, x) Sets the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The minimum step size. procedure, public :: set_next_step_size => vsi_set_next_step_size Sets the next step size. private  subroutine vsi_set_next_step_size(this, x) Sets the next step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_previous_error_norm => vsi_set_prev_err_norm Sets the norm of the previous step's error estimate. private  subroutine vsi_set_prev_err_norm(this, x) Sets the norm of the previous step's error estimate. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The error norm. procedure, public :: set_respect_x_max => vsi_set_respect_xmax Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. private  subroutine vsi_set_respect_xmax(this, x) Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. logical, intent(in) :: x True if the integrator should respect the limiting \n value of the independent variable; else, false. procedure, public :: set_safety_factor => vsi_set_safety_factor Sets a safety factor used to limit the predicted step size. private  subroutine vsi_set_safety_factor(this, x) Sets a safety factor used to limit the predicted step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The safety factor value. procedure, public :: set_step_size => vsi_set_step_size Sets the current step size. private  subroutine vsi_set_step_size(this, x) Sets the current step size. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The step size. procedure( ode_solver ), public, deferred, pass :: solve Solves the supplied system of ODE's. function ode_solver(this, sys, x, iv, err) result(rst) Prototype Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. procedure, public :: step => vsi_step Takes one integration step. private  subroutine vsi_step(this, sys, x, xmax, y, yn, xprev, yprev, fprev, err) Takes one integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xmax The upper integration limit. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the dependent \nvariables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent variables at \nx + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.","tags":"","loc":"type\\variable_step_integrator.html"},{"title":"ode – DIFFEQ","text":"interface public  subroutine ode(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:) :: dydx","tags":"","loc":"interface\\ode.html"},{"title":"ode_integer_inquiry – DIFFEQ","text":"interface public pure function ode_integer_inquiry(this) result(rst) Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. Description Returns an integer value from the ode_integrator object.","tags":"","loc":"interface\\ode_integer_inquiry.html"},{"title":"ode_jacobian – DIFFEQ","text":"interface public  subroutine ode_jacobian(x, y, jac) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:,:) :: jac","tags":"","loc":"interface\\ode_jacobian.html"},{"title":"ode_mass_matrix – DIFFEQ","text":"interface public  subroutine ode_mass_matrix(x, y, m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:,:) :: m","tags":"","loc":"interface\\ode_mass_matrix.html"},{"title":"ode_solver – DIFFEQ","text":"interface public  function ode_solver(this, sys, x, iv, err) result(rst) Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64),allocatable,dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. Description Solves the supplied system of ODE's.","tags":"","loc":"interface\\ode_solver.html"},{"title":"report_array_size_error – DIFFEQ","text":"public  subroutine report_array_size_error(err, fcn, varname, expsize, actsize) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: expsize The expected size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_excessive_integration_steps – DIFFEQ","text":"public  subroutine report_excessive_integration_steps(err, fcn, n, x) Reports an error when an excessive  amount integration steps have been \ntaken. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of integration steps. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_excessive_integration_steps.html"},{"title":"report_excessive_iterations – DIFFEQ","text":"public  subroutine report_excessive_iterations(err, fcn, n, x) Reports an error when excessive iterations have been made. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of iterations. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_excessive_iterations.html"},{"title":"report_matrix_size_error – DIFFEQ","text":"public  subroutine report_matrix_size_error(err, fcn, varname, exprow, expcol, actrow, actcol) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: exprow The expected number of rows. integer(kind=int32), intent(in) :: expcol The expected number of columns. integer(kind=int32), intent(in) :: actrow The actual number of rows. integer(kind=int32), intent(in) :: actcol The actual number of columns. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – DIFFEQ","text":"public  subroutine report_memory_error(err, fcn, flag) Reports a memory error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: flag The memory status flag. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_min_array_size_not_met – DIFFEQ","text":"public  subroutine report_min_array_size_not_met(err, fcn, varname, minsize, actsize) Reports an error where the minimum array size was not met. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: minsize The minimum size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_min_array_size_not_met.html"},{"title":"report_missing_argument – DIFFEQ","text":"public  subroutine report_missing_argument(err, fcn, arg) Reports a missing argument error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: arg The name of the argument. Contents","tags":"","loc":"proc\\report_missing_argument.html"},{"title":"report_missing_ode – DIFFEQ","text":"public  subroutine report_missing_ode(err, fcn) Reports a missing ODE routine. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. Contents","tags":"","loc":"proc\\report_missing_ode.html"},{"title":"report_step_size_too_small – DIFFEQ","text":"public  subroutine report_step_size_too_small(err, fcn, x, h) Reports an error when the step size becomes too small. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. real(kind=real64), intent(in) :: x The value of the independent variable at which the step size error\noccurred. real(kind=real64), intent(in) :: h The step size value. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_step_size_too_small.html"},{"title":"ode_fixed_step – DIFFEQ","text":"interface public  subroutine ode_fixed_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Description Takes a single fixed-size integration step.","tags":"","loc":"interface\\ode_fixed_step.html"},{"title":"build_factored_newton_matrix_routine – DIFFEQ","text":"interface public  subroutine build_factored_newton_matrix_routine(this, sys, h, x, y, err) Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this class( ode_container ), intent(inout) :: sys real(kind=real64), intent(in) :: h real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y class(errors), intent(inout), optional, target :: err","tags":"","loc":"interface\\build_factored_newton_matrix_routine.html"},{"title":"rkf_get_array_parameter – DIFFEQ","text":"interface public pure function rkf_get_array_parameter(this, i) result(rst) Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the array parameter to retrieve. Return Value real(kind=real64) The requested parameter Description Retrieves a parameter from an array stored by the \nrk_fixed_integrator object.","tags":"","loc":"interface\\rkf_get_array_parameter.html"},{"title":"rkf_get_matrix_parameter – DIFFEQ","text":"interface public pure function rkf_get_matrix_parameter(this, i, j) result(rst) Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The row index of the matrix parameter to retrieve. integer(kind=int32), intent(in) :: j The column index of the matrix parameter to retrieve. Return Value real(kind=real64) The requested parameter. Description Retrieves a parameter from a matrix stored by the\nrk_fixed_integrator object.","tags":"","loc":"interface\\rkf_get_matrix_parameter.html"},{"title":"pi_controller – DIFFEQ","text":"public pure function pi_controller(alpha, beta, order, hn, en, enm1, fs, maxstep) result(rst) Computes the next step size using a PI type controller such that where is the safety factor and is the order of the integration method. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The control parameter. real(kind=real64), intent(in) :: beta The control parameter. integer(kind=int32), intent(in) :: order The order of the integrator. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. real(kind=real64), intent(in) :: fs A safety factor to place on the growth of the step size. real(kind=real64), intent(in) :: maxstep A cap on the size of the maximum step. Return Value real(kind=real64) The new step size. Contents","tags":"","loc":"proc\\pi_controller.html"},{"title":"rkv_action – DIFFEQ","text":"interface public  subroutine rkv_action(this) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. Description Defines an action to undertake on a rk_variable_integrator \nobject.","tags":"","loc":"interface\\rkv_action.html"},{"title":"rkv_get_array_parameter – DIFFEQ","text":"interface public pure function rkv_get_array_parameter(this, i) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this integer(kind=int32), intent(in) :: i Return Value real(kind=real64)","tags":"","loc":"interface\\rkv_get_array_parameter.html"},{"title":"rkv_get_boolean_parameter – DIFFEQ","text":"interface public pure function rkv_get_boolean_parameter(this) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value logical","tags":"","loc":"interface\\rkv_get_boolean_parameter.html"},{"title":"rkv_get_integer_parameter – DIFFEQ","text":"interface public pure function rkv_get_integer_parameter(this) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value integer(kind=int32)","tags":"","loc":"interface\\rkv_get_integer_parameter.html"},{"title":"rkv_get_matrix_parameter – DIFFEQ","text":"interface public pure function rkv_get_matrix_parameter(this, i, j) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Return Value real(kind=real64)","tags":"","loc":"interface\\rkv_get_matrix_parameter.html"},{"title":"rkv_set_up_interp – DIFFEQ","text":"interface public  subroutine rkv_set_up_interp(this, x, xn, y, yn, k) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at x + h. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the values of the dependent\nvariables at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the values of the dependent\nvariables at x + h. real(kind=real64), intent(in), dimension(:,:) :: k Description Sets up interpolation for the rk_variable_integrator object.","tags":"","loc":"interface\\rkv_set_up_interp.html"},{"title":"next_step_size_calculator – DIFFEQ","text":"interface public  function next_step_size_calculator(this, hn, en, enm1) result(rst) Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step. Return Value real(kind=real64) The next step size to try. Description Defines a routine for computing the next step size to attempt.","tags":"","loc":"interface\\next_step_size_calculator.html"},{"title":"variable_step_action – DIFFEQ","text":"interface public  subroutine variable_step_action(this, x, xn, y, yn) Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The new value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the new values of the N\ndependent variables. Description Defines a routine for performing any actions upon completion of\na successful step.","tags":"","loc":"interface\\variable_step_action.html"},{"title":"variable_step_attempt – DIFFEQ","text":"interface public  subroutine variable_step_attempt(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the error estimates for each \nequation will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Description Defines a routine meant to attempt a single integration step.","tags":"","loc":"interface\\variable_step_attempt.html"},{"title":"variable_step_interpolation – DIFFEQ","text":"interface public  subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Description Defines a routine for providing interpolation services between\nintegration points.","tags":"","loc":"interface\\variable_step_interpolation.html"},{"title":"diffeq – DIFFEQ","text":"@brief This module contains several ODE solvers and associated types. Uses diffeq_variable_singlestep iso_fortran_env diffeq_multistep_fixed diffeq_runge_kutta diffeq_errors diffeq_rk4 diffeq_abmf diffeq_fixed_step diffeq_variable_step diffeq_rk_fixed_step diffeq_implicit_runge_kutta diffeq_base Contents None","tags":"","loc":"module\\diffeq.html"},{"title":"diffeq_abmf – DIFFEQ","text":"This module provides a fixed-step Adams-type integrator. Uses ferror iso_fortran_env diffeq_errors diffeq_multistep_fixed diffeq_base Contents Derived Types adams_fixed_integerator Derived Types type, public, extends( fixed_multistep_integrator ) :: adams_fixed_integerator Defines a fixed-step, 4th-order, Adams-Bashforth-Moulton PECE \nintegrator. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_order =>\n                    afi_get_order Function Returns the order of the integrator. procedure\n                    ,                  public\n                  :: solve =>\n                    fms_solver Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    afi_step Subroutine Takes a single fixed-size integration step.","tags":"","loc":"module\\diffeq_abmf.html"},{"title":"diffeq_base – DIFFEQ","text":"A collection of base types for the DIFFEQ library. Uses ferror diffeq_errors iso_fortran_env Contents Interfaces ode ode_integer_inquiry ode_jacobian ode_mass_matrix ode_solver Derived Types ode_container ode_integrator Interfaces interface public  subroutine ode(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:) :: dydx interface public pure function ode_integer_inquiry(this) result(rst) Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. interface public  subroutine ode_jacobian(x, y, jac) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:,:) :: jac interface public  subroutine ode_mass_matrix(x, y, m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y real(kind=real64), intent(out), dimension(:,:) :: m interface public  function ode_solver(this, sys, x, iv, err) result(rst) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-N matrix where M is the number of solution points, \nand N is the number of ODEs plus 1.  The first column \ncontains the values of the independent variable at which the \nresults were computed.  The remaining columns contain the \nintegration results for each ODE. Derived Types type, public :: ode_container A container for the routine containing the ODEs to integrate. Components Type Visibility Attributes Name Initial procedure( ode ), public, pointer, nopass :: fcn => null() A pointer to the routine containing the ODEs to integrate. procedure( ode_jacobian ), public, pointer, nopass :: jacobian => null() A pointer to the routine containing the analytical Jacobian.\nIf supplied, this routine is utilized; however, if null, a finite\ndifference approximation is utilized. procedure( ode_mass_matrix ), public, pointer, nopass :: mass_matrix => null() A pointer to the routine containing the mass matrix for the\nsystem.  If set to null (the default), an identity mass matrix \nwill be assumed. Type-Bound Procedures procedure\n                    ,                  public\n                  :: compute_jacobian =>\n                    oc_jacobian Subroutine procedure\n                    ,                  public\n                  :: get_finite_difference_step =>\n                    oc_get_fd_step Function procedure\n                    ,                  public\n                  :: get_is_mass_matrix_dependent =>\n                    oc_get_is_mass_dependent Function procedure\n                    ,                  public\n                  :: get_is_ode_defined =>\n                    oc_get_is_ode_defined Function procedure\n                    ,                  public\n                  :: ode =>\n                    oc_ode_fcn Subroutine procedure\n                    ,                  public\n                  :: set_finite_difference_step =>\n                    oc_set_fd_step Subroutine procedure\n                    ,                  public\n                  :: set_is_mass_matrix_dependent =>\n                    oc_set_is_mass_dependent Subroutine type, public :: ode_integrator The most basic ODE integrator object capable of integrating\nsystems of ODE's. Type-Bound Procedures procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n(ode_solver)                    ,                  public\n, pass                  :: solve Solves the supplied system of ODE's.","tags":"","loc":"module\\diffeq_base.html"},{"title":"diffeq_bsrk32_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a31 a32 a41 a42 a43 b1 b1a b2 b2a b3 b3a b4 b4a c1 c2 c3 c4 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = 0.5d0 real(kind=real64), public, parameter :: a31 = 0.0d0 real(kind=real64), public, parameter :: a32 = 0.75d0 real(kind=real64), public, parameter :: a41 = 2.0d0/9.0d0 real(kind=real64), public, parameter :: a42 = 1.0d0/3.0d0 real(kind=real64), public, parameter :: a43 = 4.0d0/9.0d0 real(kind=real64), public, parameter :: b1 = 2.0d0/9.0d0 real(kind=real64), public, parameter :: b1a = 7.0d0/24.0d0 real(kind=real64), public, parameter :: b2 = 1.0d0/3.0d0 real(kind=real64), public, parameter :: b2a = 1.0d0/4.0d0 real(kind=real64), public, parameter :: b3 = 4.0d0/9.0d0 real(kind=real64), public, parameter :: b3a = 1.0d0/3.0d0 real(kind=real64), public, parameter :: b4 = 0.0d0 real(kind=real64), public, parameter :: b4a = 1.0d0/8.0d0 real(kind=real64), public, parameter :: c1 = 0.0d0 real(kind=real64), public, parameter :: c2 = 0.5d0 real(kind=real64), public, parameter :: c3 = 0.75d0 real(kind=real64), public, parameter :: c4 = 1.0d0","tags":"","loc":"module\\diffeq_bsrk32_constants.html"},{"title":"diffeq_dprk45_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a31 a32 a41 a42 a43 a51 a52 a53 a54 a61 a62 a63 a64 a65 a71 a72 a73 a74 a75 a76 c2 c3 c4 c5 c6 c7 d1 d3 d4 d5 d6 d7 e1 e2 e3 e4 e5 e6 e7 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = 1.0d0/5.0d0 real(kind=real64), public, parameter :: a31 = 3.0d0/40.0d0 real(kind=real64), public, parameter :: a32 = 9.0d0/40.0d0 real(kind=real64), public, parameter :: a41 = 44.0d0/45.0d0 real(kind=real64), public, parameter :: a42 = -56.0d0/15.0d0 real(kind=real64), public, parameter :: a43 = 32.0d0/9.0d0 real(kind=real64), public, parameter :: a51 = 1.9372d4/6.561d3 real(kind=real64), public, parameter :: a52 = -2.536d4/2.187d3 real(kind=real64), public, parameter :: a53 = 6.4448d4/6.561d3 real(kind=real64), public, parameter :: a54 = -2.12d2/7.29d2 real(kind=real64), public, parameter :: a61 = 9.017d3/3.168d3 real(kind=real64), public, parameter :: a62 = -3.55d2/33.0d0 real(kind=real64), public, parameter :: a63 = 4.6732d4/5.247d3 real(kind=real64), public, parameter :: a64 = 49.0d0/1.76d2 real(kind=real64), public, parameter :: a65 = -5.103d3/1.8656d4 real(kind=real64), public, parameter :: a71 = 35.0d0/3.84d2 real(kind=real64), public, parameter :: a72 = 0.0d0 real(kind=real64), public, parameter :: a73 = 5.0d2/1.113d3 real(kind=real64), public, parameter :: a74 = 1.25d2/1.92d2 real(kind=real64), public, parameter :: a75 = -2.187d3/6.784d3 real(kind=real64), public, parameter :: a76 = 11.0d0/84.0d0 real(kind=real64), public, parameter :: c2 = 1.0d0/5.0d0 real(kind=real64), public, parameter :: c3 = 3.0d0/1.0d1 real(kind=real64), public, parameter :: c4 = 4.0d0/5.0d0 real(kind=real64), public, parameter :: c5 = 8.0d0/9.0d0 real(kind=real64), public, parameter :: c6 = 1.0d0 real(kind=real64), public, parameter :: c7 = 1.0d0 real(kind=real64), public, parameter :: d1 = -1.2715105075d10/1.1282082432d10 real(kind=real64), public, parameter :: d3 = 8.74874797d10/3.2700410799d10 real(kind=real64), public, parameter :: d4 = -1.0690763975d10/1.880347072d9 real(kind=real64), public, parameter :: d5 = 7.01980252875d11/1.99316789632d11 real(kind=real64), public, parameter :: d6 = -1.453857185d9/8.22651844d8 real(kind=real64), public, parameter :: d7 = 6.9997945d7/2.9380423d7 real(kind=real64), public, parameter :: e1 = -71.0d0/5.76d4 real(kind=real64), public, parameter :: e2 = 0.0d0 real(kind=real64), public, parameter :: e3 = 71.0d0/1.6695d4 real(kind=real64), public, parameter :: e4 = -71.0d0/1.92d3 real(kind=real64), public, parameter :: e5 = 1.7253d4/3.392d5 real(kind=real64), public, parameter :: e6 = -22.0d0/5.25d2 real(kind=real64), public, parameter :: e7 = 1.0d0/4.0d1","tags":"","loc":"module\\diffeq_dprk45_constants.html"},{"title":"diffeq_errors – DIFFEQ","text":"A collection of routines for handling errors in the DIFFEQ library. Uses ferror iso_fortran_env Contents Variables DIFFEQ_ARRAY_SIZE_ERROR DIFFEQ_INVALID_INPUT_ERROR DIFFEQ_INVALID_OPERATION_ERROR DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR DIFFEQ_MATRIX_SIZE_ERROR DIFFEQ_MEMORY_ALLOCATION_ERROR DIFFEQ_MISSING_ARGUMENT_ERROR DIFFEQ_NULL_POINTER_ERROR DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR Subroutines report_array_size_error report_excessive_integration_steps report_excessive_iterations report_matrix_size_error report_memory_error report_min_array_size_not_met report_missing_argument report_missing_ode report_step_size_too_small Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DIFFEQ_ARRAY_SIZE_ERROR = 10003 integer(kind=int32), public, parameter :: DIFFEQ_INVALID_INPUT_ERROR = 10004 integer(kind=int32), public, parameter :: DIFFEQ_INVALID_OPERATION_ERROR = 10008 integer(kind=int32), public, parameter :: DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR = 10007 integer(kind=int32), public, parameter :: DIFFEQ_MATRIX_SIZE_ERROR = 10002 integer(kind=int32), public, parameter :: DIFFEQ_MEMORY_ALLOCATION_ERROR = 10000 integer(kind=int32), public, parameter :: DIFFEQ_MISSING_ARGUMENT_ERROR = 10005 integer(kind=int32), public, parameter :: DIFFEQ_NULL_POINTER_ERROR = 10001 integer(kind=int32), public, parameter :: DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR = 10006 Subroutines public  subroutine report_array_size_error (err, fcn, varname, expsize, actsize) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: expsize The expected size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. public  subroutine report_excessive_integration_steps (err, fcn, n, x) Reports an error when an excessive  amount integration steps have been \ntaken. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of integration steps. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. public  subroutine report_excessive_iterations (err, fcn, n, x) Reports an error when excessive iterations have been made. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of iterations. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. public  subroutine report_matrix_size_error (err, fcn, varname, exprow, expcol, actrow, actcol) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: exprow The expected number of rows. integer(kind=int32), intent(in) :: expcol The expected number of columns. integer(kind=int32), intent(in) :: actrow The actual number of rows. integer(kind=int32), intent(in) :: actcol The actual number of columns. public  subroutine report_memory_error (err, fcn, flag) Reports a memory error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: flag The memory status flag. public  subroutine report_min_array_size_not_met (err, fcn, varname, minsize, actsize) Reports an error where the minimum array size was not met. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: minsize The minimum size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. public  subroutine report_missing_argument (err, fcn, arg) Reports a missing argument error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: arg The name of the argument. public  subroutine report_missing_ode (err, fcn) Reports a missing ODE routine. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. public  subroutine report_step_size_too_small (err, fcn, x, h) Reports an error when the step size becomes too small. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. real(kind=real64), intent(in) :: x The value of the independent variable at which the step size error\noccurred. real(kind=real64), intent(in) :: h The step size value.","tags":"","loc":"module\\diffeq_errors.html"},{"title":"diffeq_fixed_step – DIFFEQ","text":"Uses diffeq_base diffeq_errors iso_fortran_env Contents Interfaces ode_fixed_step Derived Types fixed_step_integrator Interfaces interface public  subroutine ode_fixed_step(this, sys, h, x, y, yn, xprev, yprev, fprev, err) Takes a single fixed-size integration step. Arguments Type Intent Optional Attributes Name class( fixed_step_integrator ), intent(inout) :: this The fixed_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The size of the step to take. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Derived Types type, public, extends( ode_integrator ) :: fixed_step_integrator Defines a fixed-step integrator. Type-Bound Procedures procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: solve =>\n                    fsi_solver Function Solves the supplied system of ODE's. procedure\n(ode_fixed_step)                    ,                  public\n, pass                  :: step Takes a single integration step.","tags":"","loc":"module\\diffeq_fixed_step.html"},{"title":"diffeq_implicit_runge_kutta – DIFFEQ","text":"Uses iso_fortran_env diffeq_runge_kutta diffeq_errors diffeq_base linalg Contents Interfaces build_factored_newton_matrix_routine Derived Types implicit_rk_variable_integrator sdirk4_integrator sdirk_integrator Interfaces interface public  subroutine build_factored_newton_matrix_routine(this, sys, h, x, y, err) Arguments Type Intent Optional Attributes Name class( implicit_rk_variable_integrator ), intent(inout) :: this class( ode_container ), intent(inout) :: sys real(kind=real64), intent(in) :: h real(kind=real64), intent(in) :: x real(kind=real64), intent(in), dimension(:) :: y class(errors), intent(inout), optional, target :: err Derived Types type, public, extends( rk_variable_integrator ) :: implicit_rk_variable_integrator Defines an implicit Runge-Kutta variable-step integrator. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rkv_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n(build_factored_newton_matrix_routine)                    ,                  public\n                  :: build_factored_newton_matrix Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    irk_compute_next_step_size Function Computes the next step size. procedure\n(rkv_action)                    ,                  public\n                  :: define_model Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    irk_estimate_first_step Function Computes an estimate to the first step size based upon the\ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_is_jacobian_current =>\n                    irk_get_is_jac_current Function Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_previous_step_size =>\n                    irk_get_old_step Function Gets the most recent successful step size. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n(rkv_get_integer_parameter)                    ,                  public\n                  :: get_stage_count Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: get_use_pi_controller =>\n                    irk_get_use_pi_controller Function Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: initialize =>\n                    rkv_alloc_workspace Subroutine Initializes the integrator. procedure\n(variable_step_interpolation)                    ,                  public\n                  :: interpolate Provides interpolation between integration points. procedure\n(rkv_get_boolean_parameter)                    ,                  public\n                  :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_is_jacobian_current =>\n                    irk_set_is_jac_current Subroutine Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_previous_step_size =>\n                    irk_set_old_step Subroutine Sets the most recent successful step size. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n(rkv_set_up_interp)                    ,                  public\n                  :: set_up_interpolation Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: set_use_pi_controller =>\n                    irk_set_use_pi_controller Subroutine Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step. type, public, extends( sdirk_integrator ) :: sdirk4_integrator Defines a singly diagonally implicit 4th order Runge-Kutta \nintegrator suitable for integrating stiff systems of differential \nequations. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    sdirk_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: build_factored_newton_matrix =>\n                    sdirk_build_factored_matrix Subroutine Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. procedure\n                    ,                  public\n                  :: build_newton_matrix =>\n                    sdirk_build_matrix Subroutine Builds the system matrix of the form or if a mass matrix is defined. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    irk_compute_next_step_size Function Computes the next step size. procedure\n                    ,                  public\n                  :: define_model =>\n                    sd4_define_model Subroutine Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    irk_estimate_first_step Function Computes an estimate to the first step size based upon the\ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_is_jacobian_current =>\n                    irk_get_is_jac_current Function Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_newton_iteration_count =>\n                    sdirk_get_max_newton_iter Function Gets the maximum allowed number of Newton iterations. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_newton_tolerance =>\n                    sdirk_get_newton_tol Function Gets the tolerance used to check for convergence of the\nNewton iterations. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    sd4_get_order Function Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_previous_step_size =>\n                    irk_get_old_step Function Gets the most recent successful step size. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    sd4_get_stage_count Function Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: get_use_pi_controller =>\n                    irk_get_use_pi_controller Function Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: initialize =>\n                    sd4_alloc_workspace Subroutine Initializes the integrator. procedure\n                    ,                  public\n                  :: interpolate =>\n                    sd4_interp Subroutine Provides interpolation between integration points allowing for\ndense output. procedure\n                    ,                  public\n                  :: is_fsal =>\n                    sd4_is_fsal Function Determines if the integrator is an FSAL (first same as last)\nintegrator. procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_is_jacobian_current =>\n                    irk_set_is_jac_current Subroutine Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_newton_iteration_count =>\n                    sdirk_set_max_newton_iter Subroutine Sets the maximum allowed number of Newton iterations. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_newton_tolerance =>\n                    sdirk_set_newton_tol Subroutine Sets the tolerance used to check for convergence of the\nNewton iterations. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_previous_step_size =>\n                    irk_set_old_step Subroutine Sets the most recent successful step size. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n                    ,                  public\n                  :: set_up_interpolation =>\n                    sd4_set_up_interp Subroutine Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: set_use_pi_controller =>\n                    irk_set_use_pi_controller Subroutine Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: solve_newton_stage =>\n                    sdirk_solve_newton Subroutine Solves the Newton iteration problem for the i-th stage. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step. type, public, extends( implicit_rk_variable_integrator ) :: sdirk_integrator Defines a base structure for singly diagonally implicit \nRunge-Kutta integrators. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    sdirk_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: build_factored_newton_matrix =>\n                    sdirk_build_factored_matrix Subroutine Builds the matrix of the form or if a mass matrix is defined, and then computes\nits LU factorization.  The Jacobian and mass matrices are \nevaluated as part of this process, if necessary. procedure\n                    ,                  public\n                  :: build_newton_matrix =>\n                    sdirk_build_matrix Subroutine Builds the system matrix of the form or if a mass matrix is defined. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    irk_compute_next_step_size Function Computes the next step size. procedure\n(rkv_action)                    ,                  public\n                  :: define_model Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    irk_estimate_first_step Function Computes an estimate to the first step size based upon the\ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_is_jacobian_current =>\n                    irk_get_is_jac_current Function Gets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_newton_iteration_count =>\n                    sdirk_get_max_newton_iter Function Gets the maximum allowed number of Newton iterations. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_newton_tolerance =>\n                    sdirk_get_newton_tol Function Gets the tolerance used to check for convergence of the\nNewton iterations. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_previous_step_size =>\n                    irk_get_old_step Function Gets the most recent successful step size. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n(rkv_get_integer_parameter)                    ,                  public\n                  :: get_stage_count Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: get_use_pi_controller =>\n                    irk_get_use_pi_controller Function Gets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: initialize =>\n                    sdirk_alloc_workspace Subroutine Initializes the integrator. procedure\n(variable_step_interpolation)                    ,                  public\n                  :: interpolate Provides interpolation between integration points. procedure\n(rkv_get_boolean_parameter)                    ,                  public\n                  :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_is_jacobian_current =>\n                    irk_set_is_jac_current Subroutine Sets a value determining if the Jacobian matrix estimate is\ncurrent such that it does not need to be recomputed at this time. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_newton_iteration_count =>\n                    sdirk_set_max_newton_iter Subroutine Sets the maximum allowed number of Newton iterations. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_newton_tolerance =>\n                    sdirk_set_newton_tol Subroutine Sets the tolerance used to check for convergence of the\nNewton iterations. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_previous_step_size =>\n                    irk_set_old_step Subroutine Sets the most recent successful step size. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n(rkv_set_up_interp)                    ,                  public\n                  :: set_up_interpolation Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: set_use_pi_controller =>\n                    irk_set_use_pi_controller Subroutine Sets a parameter determining if a PI step size controller\nor a Gustafsson step size controller should be used. The default\nis to use a PI step size controller. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: solve_newton_stage =>\n                    sdirk_solve_newton Subroutine Solves the Newton iteration problem for the i-th stage. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step.","tags":"","loc":"module\\diffeq_implicit_runge_kutta.html"},{"title":"diffeq_multistep_fixed – DIFFEQ","text":"Uses iso_fortran_env diffeq_errors diffeq_rk4 diffeq_fixed_step diffeq_base Contents Derived Types fixed_multistep_integrator Derived Types type, public, extends( fixed_step_integrator ) :: fixed_multistep_integrator Defines a fixed step-size, multi-step integrator. Type-Bound Procedures procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: solve =>\n                    fms_solver Function Solves the supplied system of ODEs. procedure\n(ode_fixed_step)                    ,                  public\n, pass                  :: step Takes a single integration step.","tags":"","loc":"module\\diffeq_multistep_fixed.html"},{"title":"diffeq_rk4 – DIFFEQ","text":"This module provides a 4th order Runge-Kutta fixed-step integrator. Uses iso_fortran_env diffeq_rk_fixed_step Contents Derived Types rk4_fixed_integrator Derived Types type, public, extends( rk_fixed_integrator ) :: rk4_fixed_integrator Defines the explicit, 4th order, Runge-Kutta fixed-step \nintegrator. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_method_factor =>\n                    rk4_get_a_param Function Gets the requested method factor from the Butcher tableau. procedure\n                    ,                  public\n                  :: get_order =>\n                    rk4_get_order Function Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_position_factor =>\n                    rk4_get_c_param Function Gets the requested position factor from the Butcher tableau. procedure\n                    ,                  public\n                  :: get_quadrature_weight =>\n                    rk4_get_b_param Function Gets the requested quadrature weight from the Butcher tableau. procedure\n                    ,                  public\n                  :: solve =>\n                    fsi_solver Function Solves the supplied system of ODE's. procedure\n                    ,                  public\n                  :: step =>\n                    rkf_step Subroutine Takes a single Runge-Kutta integration step.","tags":"","loc":"module\\diffeq_rk4.html"},{"title":"diffeq_rk_fixed_step – DIFFEQ","text":"This module contains the structure for fixed-step Runge-Kutta \nintegrators. Uses diffeq_base diffeq_errors iso_fortran_env diffeq_fixed_step Contents Interfaces rkf_get_array_parameter rkf_get_matrix_parameter Derived Types rk_fixed_integrator Interfaces interface public pure function rkf_get_array_parameter(this, i) result(rst) Retrieves a parameter from an array stored by the \nrk_fixed_integrator object. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The index of the array parameter to retrieve. Return Value real(kind=real64) The requested parameter interface public pure function rkf_get_matrix_parameter(this, i, j) result(rst) Retrieves a parameter from a matrix stored by the\nrk_fixed_integrator object. Arguments Type Intent Optional Attributes Name class( rk_fixed_integrator ), intent(in) :: this The rk_fixed_integrator object. integer(kind=int32), intent(in) :: i The row index of the matrix parameter to retrieve. integer(kind=int32), intent(in) :: j The column index of the matrix parameter to retrieve. Return Value real(kind=real64) The requested parameter. Derived Types type, public, extends( fixed_step_integrator ) :: rk_fixed_integrator Defines an explicit, Runge-Kutta fixed-step integrator. Type-Bound Procedures procedure\n(rkf_get_matrix_parameter)                    ,                  public\n                  :: get_method_factor Gets the requested method factor from the Butcher tableau. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n(rkf_get_array_parameter)                    ,                  public\n                  :: get_position_factor Gets the requested position factor from the Butcher tableau. procedure\n(rkf_get_array_parameter)                    ,                  public\n                  :: get_quadrature_weight Gets the requested quadrature weight from the Butcher tableau. procedure\n                    ,                  public\n                  :: solve =>\n                    fsi_solver Function Solves the supplied system of ODE's. procedure\n                    ,                  public\n                  :: step =>\n                    rkf_step Subroutine Takes a single Runge-Kutta integration step.","tags":"","loc":"module\\diffeq_rk_fixed_step.html"},{"title":"diffeq_runge_kutta – DIFFEQ","text":"Uses diffeq_variable_singlestep diffeq_base diffeq_errors iso_fortran_env Contents Interfaces rkv_action rkv_get_array_parameter rkv_get_boolean_parameter rkv_get_integer_parameter rkv_get_matrix_parameter rkv_set_up_interp Derived Types bsrk32_integrator dprk45_integrator rk_variable_integrator Functions pi_controller Interfaces interface public  subroutine rkv_action(this) Defines an action to undertake on a rk_variable_integrator \nobject. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. interface public pure function rkv_get_array_parameter(this, i) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this integer(kind=int32), intent(in) :: i Return Value real(kind=real64) interface public pure function rkv_get_boolean_parameter(this) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value logical interface public pure function rkv_get_integer_parameter(this) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this Return Value integer(kind=int32) interface public pure function rkv_get_matrix_parameter(this, i, j) result(rst) Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(in) :: this integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Return Value real(kind=real64) interface public  subroutine rkv_set_up_interp(this, x, xn, y, yn, k) Sets up interpolation for the rk_variable_integrator object. Arguments Type Intent Optional Attributes Name class( rk_variable_integrator ), intent(inout) :: this The rk_variable_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The value of the independent variable at x + h. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the values of the dependent\nvariables at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the values of the dependent\nvariables at x + h. real(kind=real64), intent(in), dimension(:,:) :: k Derived Types type, public, extends( rk_variable_integrator ) :: bsrk32_integrator Defines the Bogacki-Shampine 3rd/2nd order integrator. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rkv_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    rkv_next_step Function Computes the next step size. procedure\n                    ,                  public\n                  :: define_model =>\n                    bsrk32_define_model Subroutine Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    vsi_estimate_first_step Function Computes an estimate to the first step size based upon the \ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    bsrk32_get_order Function Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    bsrk32_get_stage_count Function Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: initialize =>\n                    rkv_alloc_workspace Subroutine Initializes the integrator. procedure\n                    ,                  public\n                  :: interpolate =>\n                    bsrk32_interp Subroutine Provides interpolation between integration points allowing for\ndense output. procedure\n                    ,                  public\n                  :: is_fsal =>\n                    bsrk32_is_fsal Function Determines if the integrator is an FSAL (first same as last)\nintegrator. procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n                    ,                  public\n                  :: set_up_interpolation =>\n                    bsrk32_set_up_interp Subroutine Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step. type, public, extends( rk_variable_integrator ) :: dprk45_integrator Defines the classical Dormand-Prince 4th/5th order integrator. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rkv_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    rkv_next_step Function Computes the next step size. procedure\n                    ,                  public\n                  :: define_model =>\n                    dprk45_define_model Subroutine Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    vsi_estimate_first_step Function Computes an estimate to the first step size based upon the \ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    dprk45_get_order Function Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    dprk45_get_stage_count Function Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: initialize =>\n                    rkv_alloc_workspace Subroutine Initializes the integrator. procedure\n                    ,                  public\n                  :: interpolate =>\n                    dprk45_interp Subroutine Provides interpolation between integration points allowing\nfor dense output. procedure\n                    ,                  public\n                  :: is_fsal =>\n                    dprk45_is_fsal Function Determines if the integrator is an FSAL (first same as last)\nintegrator (e.g. the 4th/5th order Dormand-Prince integrator). procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n                    ,                  public\n                  :: set_up_interpolation =>\n                    dprk45_set_up_interp Subroutine Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step. type, public, extends( variable_singlestep_integrator ) :: rk_variable_integrator @brief Defines a variable-step, Runge-Kutta integrator. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: a The NSTAGE-by-NSTAGE method factor matrix A. real(kind=real64), public, allocatable, dimension(:) :: b The NSTAGE-element quadrature weight array B. real(kind=real64), public, allocatable, dimension(:) :: c The NSTAGE-element position factor array C. real(kind=real64), public, allocatable, dimension(:) :: e The NSTAGE-element error estimate factor array E. real(kind=real64), public, allocatable, dimension(:,:) :: f An NEQN-by-NSTAGE matrix containing the function evaluations\n(derivatives) at each of the stages of evaluation. integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rkv_attempt_step Subroutine Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n                    ,                  public\n                  :: compute_next_step_size =>\n                    rkv_next_step Function Computes the next step size. procedure\n(rkv_action)                    ,                  public\n                  :: define_model Defines (initializes) the model parameters. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    vsi_estimate_first_step Function Computes an estimate to the first step size based upon the \ninitial function values. procedure\n                    ,                  public\n                  :: get_alpha =>\n                    rkv_get_alpha Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_beta =>\n                    rkv_get_beta Function Gets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_is_first_step =>\n                    rkv_get_is_first_step Function Gets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n(rkv_get_integer_parameter)                    ,                  public\n                  :: get_stage_count Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n                    ,                  public\n                  :: initialize =>\n                    rkv_alloc_workspace Subroutine Initializes the integrator. procedure\n(variable_step_interpolation)                    ,                  public\n                  :: interpolate Provides interpolation between integration points. procedure\n(rkv_get_boolean_parameter)                    ,                  public\n                  :: is_fsal Gets a value determining if this is a FSAL (first, same as last)\nintegrator. procedure\n                    ,                  public\n                  :: on_successful_step =>\n                    rkv_on_successful_step Subroutine Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: reset =>\n                    rkv_reset Subroutine Resets the integrator to its initial state. procedure\n                    ,                  public\n                  :: set_alpha =>\n                    rkv_set_alpha Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_beta =>\n                    rkv_set_beta Subroutine Sets the control parameter in the PI controller , where is a safety \nfactor, and \\f$ k ) is the order of the integration method. procedure\n                    ,                  public\n                  :: set_is_first_step =>\n                    rkv_set_is_first_step Subroutine Sets a value determining if the integrator is set up to take its \nfirst integration step. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n(rkv_set_up_interp)                    ,                  public\n                  :: set_up_interpolation Sets up the interpolation polynomial. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step. Functions public pure function pi_controller (alpha, beta, order, hn, en, enm1, fs, maxstep) result(rst) Computes the next step size using a PI type controller such that where is the safety factor and is the order of the integration method. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The control parameter. real(kind=real64), intent(in) :: beta The control parameter. integer(kind=int32), intent(in) :: order The order of the integrator. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step size. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step size. real(kind=real64), intent(in) :: fs A safety factor to place on the growth of the step size. real(kind=real64), intent(in) :: maxstep A cap on the size of the maximum step. Return Value real(kind=real64) The new step size.","tags":"","loc":"module\\diffeq_runge_kutta.html"},{"title":"diffeq_sdirk4_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a22 a31 a32 a33 a41 a42 a43 a44 a51 a52 a53 a54 a55 b1 b1a b2 b2a b3 b3a b4 b4a b5 b5a b6 b6a bs11 bs12 bs13 bs14 bs15 bs16 bs21 bs22 bs23 bs24 bs25 bs26 bs31 bs32 bs33 bs34 bs35 bs36 bs41 bs42 bs43 bs44 bs45 bs46 c2 c3 c4 c5 c6 gamma Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = gamma real(kind=real64), public, parameter :: a22 = gamma real(kind=real64), public, parameter :: a31 = (c3-a32-gamma) real(kind=real64), public, parameter :: a32 = (1.0d0-sqrt(2.0d0))/8.0d0 real(kind=real64), public, parameter :: a33 = gamma real(kind=real64), public, parameter :: a41 = c4-a42-a43-gamma real(kind=real64), public, parameter :: a42 = (5.0d0-7.0d0*sqrt(2.0d0))/64.0d0 real(kind=real64), public, parameter :: a43 = 7.0d0*(1.0d0+sqrt(2.0d0))/32.0d0 real(kind=real64), public, parameter :: a44 = gamma real(kind=real64), public, parameter :: a51 = c5-a52-a53-a54-gamma real(kind=real64), public, parameter :: a52 = (-1.3796d4-5.4539d4*sqrt(2.0d0))/1.25d5 real(kind=real64), public, parameter :: a53 = (5.06605d5+1.32109d5*sqrt(2.0d0))/4.375d5 real(kind=real64), public, parameter :: a54 = 166.0d0*(-97.0d0+376.0d0*sqrt(2.0d0))/1.09375d5 real(kind=real64), public, parameter :: a55 = gamma real(kind=real64), public, parameter :: b1 = 1.0d0-b2-b3-b4-b5-gamma real(kind=real64), public, parameter :: b1a = 1.0d0-b2a-b3a-b4a-b5a-b6a real(kind=real64), public, parameter :: b2 = (1.181d3-9.87d2*sqrt(2.0d0))/1.3782d4 real(kind=real64), public, parameter :: b2a = -4.80923228411d11/4.982971448372d12 real(kind=real64), public, parameter :: b3 = 47.0d0*(-267.0d0+1.783d3*sqrt(2.0d0))/2.73343d5 real(kind=real64), public, parameter :: b3a = 6.709447293961d12/1.2833189095359d13 real(kind=real64), public, parameter :: b4 = -16.0d0*(-2.2922d4+3.525d3*sqrt(2.0d0))/5.71953d5 real(kind=real64), public, parameter :: b4a = 3.513175791894d12/6.748737351361d12 real(kind=real64), public, parameter :: b5 = -15.625d3*(97.0d0+376.0d0*sqrt(2.0d0))/9.0749876d7 real(kind=real64), public, parameter :: b5a = -4.98863281070d11/6.042575550617d12 real(kind=real64), public, parameter :: b6 = gamma real(kind=real64), public, parameter :: b6a = 2.077005547802d12/8.945017530137d12 real(kind=real64), public, parameter :: bs11 = 11963910384665.0d0/12483345430363.0d0 real(kind=real64), public, parameter :: bs12 = 11963910384665.0d0/12483345430363.0d0 real(kind=real64), public, parameter :: bs13 = -28603264624.0d0/1970169629981.0d0 real(kind=real64), public, parameter :: bs14 = -3524425447183.0d0/2683177070205.0d0 real(kind=real64), public, parameter :: bs15 = -17173522440186.0d0/10195024317061.0d0 real(kind=real64), public, parameter :: bs16 = 27308879169709.0d0/13030500014233.0d0 real(kind=real64), public, parameter :: bs21 = -69996760330788.0d0/18526599551455.0d0 real(kind=real64), public, parameter :: bs22 = -69996760330788.0d0/18526599551455.0d0 real(kind=real64), public, parameter :: bs23 = 102610171905103.0d0/26266659717953.0d0 real(kind=real64), public, parameter :: bs24 = 74957623907620.0d0/12279805097313.0d0 real(kind=real64), public, parameter :: bs25 = 113853199235633.0d0/9983266320290.0d0 real(kind=real64), public, parameter :: bs26 = -84229392543950.0d0/6077740599399.0d0 real(kind=real64), public, parameter :: bs31 = 32473635429419.0d0/7030701510665.0d0 real(kind=real64), public, parameter :: bs32 = 32473635429419.0d0/7030701510665.0d0 real(kind=real64), public, parameter :: bs33 = -38866317253841.0d0/6249835826165.0d0 real(kind=real64), public, parameter :: bs34 = -26705717223886.0d0/4265677133337.0d0 real(kind=real64), public, parameter :: bs35 = -121105382143155.0d0/6658412667527.0d0 real(kind=real64), public, parameter :: bs36 = 1102028547503824.0d0/51424476870755.0d0 real(kind=real64), public, parameter :: bs41 = -14668528638623.0d0/8083464301755.0d0 real(kind=real64), public, parameter :: bs42 = -14668528638623.0d0/8083464301755.0d0 real(kind=real64), public, parameter :: bs43 = 21103455885091.0d0/7774428730952.0d0 real(kind=real64), public, parameter :: bs44 = 30155591475533.0d0/15293695940061.0d0 real(kind=real64), public, parameter :: bs45 = 119853375102088.0d0/14336240079991.0d0 real(kind=real64), public, parameter :: bs46 = -63602213973224.0d0/6753880425717.0d0 real(kind=real64), public, parameter :: c2 = 0.5d0 real(kind=real64), public, parameter :: c3 = (2.0d0-sqrt(2.0d0))/4.0d0 real(kind=real64), public, parameter :: c4 = 5.0d0/8.0d0 real(kind=real64), public, parameter :: c5 = 26.0d0/25.0d0 real(kind=real64), public, parameter :: c6 = 1.0d0 real(kind=real64), public, parameter :: gamma = 0.25d0","tags":"","loc":"module\\diffeq_sdirk4_constants.html"},{"title":"diffeq_variable_singlestep – DIFFEQ","text":"Uses diffeq_variable_step diffeq_errors iso_fortran_env diffeq_base Contents Derived Types variable_singlestep_integrator Derived Types type, public, extends( variable_step_integrator ) :: variable_singlestep_integrator @brief Defines a variable-step, single-stage integrator. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n(variable_step_attempt)                    ,                  public\n                  :: attempt_step Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n(next_step_size_calculator)                    ,                  public\n                  :: compute_next_step_size Computes the next step size. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    vsi_estimate_first_step Function Computes an estimate to the first step size based upon the \ninitial function values. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n(variable_step_interpolation)                    ,                  public\n                  :: interpolate Provides interpolation between integration points. procedure\n(variable_step_action)                    ,                  public\n                  :: on_successful_step Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n                    ,                  public\n                  :: solve =>\n                    vssi_solve Function Solves the supplied system of ODEs. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step.","tags":"","loc":"module\\diffeq_variable_singlestep.html"},{"title":"diffeq_variable_step – DIFFEQ","text":"Uses diffeq_base diffeq_errors iso_fortran_env Contents Interfaces next_step_size_calculator variable_step_action variable_step_attempt variable_step_interpolation Derived Types variable_step_integrator Interfaces interface public  function next_step_size_calculator(this, hn, en, enm1) result(rst) Defines a routine for computing the next step size to attempt. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: hn The current step size. real(kind=real64), intent(in) :: en The norm of the error for the current step. real(kind=real64), intent(in) :: enm1 The norm of the error from the previous step. Return Value real(kind=real64) The next step size to try. interface public  subroutine variable_step_action(this, x, xn, y, yn) Defines a routine for performing any actions upon completion of\na successful step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in) :: xn The new value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the new values of the N\ndependent variables. interface public  subroutine variable_step_attempt(this, sys, h, x, y, yn, en, xprev, yprev, fprev, err) Defines a routine meant to attempt a single integration step. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(inout) :: this The variable_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the N\ndependent variables. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where the values of the dependent \nvariables at x + h will be written. real(kind=real64), intent(out), dimension(:) :: en An N-element array where the error estimates for each \nequation will be written. real(kind=real64), intent(in), optional, dimension(:) :: xprev An optional M-element array containing the previous M values\nof the independent variable where M is the order of the \nmethod.  This is typically only used for multi-step methods.\nIn single-step methods, this parameter is typically not\nneeded. real(kind=real64), intent(in), optional, dimension(:,:) :: yprev An optional M-by-N matrix containing the previous M arrays of\ndependent variables, where M is the order of the method.  As\nwith xprev, this parameter is typically used for multi-step\nmethods.  In single-step methods, this parameter is typically\nnot needed. real(kind=real64), intent(inout), optional, dimension(:,:) :: fprev An optional M-by-N matrix containing the previous M arrays of\nODE (function) values.  As with xprev and yprev, M is the\norder of the method, and this parameter is typically used for\nmulti-step methods.  In single-step methods, this parameter \nis typically not needed. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. interface public  subroutine variable_step_interpolation(this, xprev, yprev, xnew, x, y, err) Defines a routine for providing interpolation services between\nintegration points. Arguments Type Intent Optional Attributes Name class( variable_step_integrator ), intent(in) :: this The variable_step_integrator object. real(kind=real64), intent(in) :: xprev The previoius value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yprev An N-element array containing the previous values of the\nN dependent variables. real(kind=real64), intent(in) :: xnew The new value of the independent variable. real(kind=real64), intent(in) :: x The value at which to perform the interpolation. real(kind=real64), intent(out), dimension(:) :: y An N-element array where the interpolated values will be\nwritten. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Derived Types type, public, extends( ode_integrator ) :: variable_step_integrator Defines a variable-step integrator. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_bufferCount = 0 Type-Bound Procedures procedure\n(variable_step_attempt)                    ,                  public\n                  :: attempt_step Attempts a single integration step. procedure\n                    ,                  public\n                  :: buffer_results =>\n                    vsi_append_to_buffer Subroutine Buffers a results set. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    vsi_clear_buffer Subroutine Clears the results buffer. procedure\n(next_step_size_calculator)                    ,                  public\n                  :: compute_next_step_size Computes the next step size. procedure\n                    ,                  public\n                  :: estimate_first_step_size =>\n                    vsi_estimate_first_step Function Computes an estimate to the first step size based upon the \ninitial function values. procedure\n                    ,                  public\n                  :: get_buffer_contents =>\n                    vsi_get_buffer_contents Function Returns the contents of the solution buffer. procedure\n                    ,                  public\n                  :: get_buffer_size =>\n                    vsi_get_buffer_count Function Gets the number of entries into the solution buffer. procedure\n                    ,                  public\n                  :: get_default_absolute_tolerance =>\n                    vsi_get_default_abs_tol Function Gets the default absolute error tolerance. procedure\n                    ,                  public\n                  :: get_default_relative_tolerance =>\n                    vsi_get_default_rel_tol Function Gets the default relative error tolerance. procedure\n                    ,                  public\n                  :: get_max_integration_step_count =>\n                    vsi_get_max_step_count Function Gets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: get_max_per_step_iteration_count =>\n                    vsi_get_max_iter_count Function Gets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: get_max_step_size =>\n                    vsi_get_max_step Function Gets the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_min_step_size =>\n                    vsi_get_min_step Function Gets the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_next_step_size =>\n                    vsi_get_next_step_size Function Gets the next step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_previous_error_norm =>\n                    vsi_get_prev_err_norm Function Gets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: get_respect_x_max =>\n                    vsi_get_respect_xmax Function Gets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: get_safety_factor =>\n                    vsi_get_safety_factor Function Gets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: get_step_size =>\n                    vsi_get_step_size Function Gets the current step size. procedure\n(variable_step_interpolation)                    ,                  public\n                  :: interpolate Provides interpolation between integration points. procedure\n(variable_step_action)                    ,                  public\n                  :: on_successful_step Perform necessary actions on completion of a successful step. procedure\n                    ,                  public\n                  :: set_max_integration_step_count =>\n                    vsi_set_max_step_count Subroutine Sets the maximum number of integration steps allowed. procedure\n                    ,                  public\n                  :: set_max_per_step_iteration_count =>\n                    vsi_set_max_iter_count Subroutine Sets the maximum number of iterations per step allowed. procedure\n                    ,                  public\n                  :: set_max_step_size =>\n                    vsi_set_max_step Subroutine Sets the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_min_step_size =>\n                    vsi_set_min_step Subroutine Sets the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_next_step_size =>\n                    vsi_set_next_step_size Subroutine Sets the next step size. procedure\n                    ,                  public\n                  :: set_previous_error_norm =>\n                    vsi_set_prev_err_norm Subroutine Sets the norm of the previous step's error estimate. procedure\n                    ,                  public\n                  :: set_respect_x_max =>\n                    vsi_set_respect_xmax Subroutine Sets a value determining if the integrator should respect a\nhard limit in the independent variable range.  If false, the \nintegrator may step pass the limit. procedure\n                    ,                  public\n                  :: set_safety_factor =>\n                    vsi_set_safety_factor Subroutine Sets a safety factor used to limit the predicted step size. procedure\n                    ,                  public\n                  :: set_step_size =>\n                    vsi_set_step_size Subroutine Sets the current step size. procedure\n(ode_solver)                    ,                  public\n, pass                  :: solve Solves the supplied system of ODE's. procedure\n                    ,                  public\n                  :: step =>\n                    vsi_step Subroutine Takes one integration step.","tags":"","loc":"module\\diffeq_variable_step.html"},{"title":"diffeq.f90 – DIFFEQ","text":"Contents Modules diffeq Source Code diffeq.f90 Source Code !> @brief This module contains several ODE solvers and associated types. module diffeq use iso_fortran_env use diffeq_errors use diffeq_base use diffeq_fixed_step use diffeq_abmf use diffeq_rk_fixed_step use diffeq_rk4 use diffeq_multistep_fixed use diffeq_variable_step use diffeq_variable_singlestep use diffeq_runge_kutta use diffeq_implicit_runge_kutta implicit none private public :: ode public :: ode_jacobian public :: ode_mass_matrix public :: ode_container public :: ode_integrator public :: ode_solver public :: ode_integer_inquiry public :: fixed_step_integrator public :: ode_fixed_step public :: rk_fixed_integrator public :: rkf_get_array_parameter public :: rkf_get_matrix_parameter public :: rk4_fixed_integrator public :: fixed_multistep_integrator public :: adams_fixed_integerator public :: variable_step_integrator public :: variable_step_attempt public :: variable_step_action public :: variable_step_interpolation public :: next_step_size_calculator public :: variable_singlestep_integrator public :: pi_controller public :: rkv_get_matrix_parameter public :: rkv_get_array_parameter public :: rkv_get_boolean_parameter public :: rkv_get_integer_parameter public :: rkv_action public :: rkv_set_up_interp public :: rk_variable_integrator public :: dprk45_integrator public :: bsrk32_integrator public :: build_factored_newton_matrix_routine public :: implicit_rk_variable_integrator public :: sdirk_integrator public :: sdirk4_integrator public :: DIFFEQ_MEMORY_ALLOCATION_ERROR public :: DIFFEQ_NULL_POINTER_ERROR public :: DIFFEQ_MATRIX_SIZE_ERROR public :: DIFFEQ_ARRAY_SIZE_ERROR public :: DIFFEQ_INVALID_INPUT_ERROR public :: DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR public :: DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR public :: DIFFEQ_INVALID_OPERATION_ERROR end module","tags":"","loc":"sourcefile\\diffeq.f90.html"},{"title":"diffeq_abmf.f90 – DIFFEQ","text":"Contents Modules diffeq_abmf Source Code diffeq_abmf.f90 Source Code module diffeq_abmf !! This module provides a fixed-step Adams-type integrator. use iso_fortran_env use diffeq_multistep_fixed use diffeq_base use diffeq_errors use ferror implicit none private public :: adams_fixed_integerator type , extends ( fixed_multistep_integrator ) :: adams_fixed_integerator !! Defines a fixed-step, 4th-order, Adams-Bashforth-Moulton PECE !! integrator. contains procedure , public :: get_order => afi_get_order !! Returns the order of the integrator. procedure , public :: step => afi_step !! Takes a single fixed-size integration step. end type contains ! ------------------------------------------------------------------------------ pure module function afi_get_order ( this ) result ( rst ) !! Returns the order of the integrator. class ( adams_fixed_integerator ), intent ( in ) :: this !! The adams_fixed_integerator object. integer ( int32 ) :: rst !! The order of the integrator. rst = 4 end function ! ------------------------------------------------------------------------------ subroutine shift ( x ) ! Arguments real ( real64 ), intent ( inout ), dimension (:,:) :: x ! Local Variables integer ( int32 ) :: j , n ! Shift each column over by 1 allowing the last column to fall off n = size ( x , 2 ) do j = n , 2 , - 1 x (:, j ) = x (:, j - 1 ) end do end subroutine ! ------------------------------------------------------------------------------ module subroutine afi_step ( this , sys , h , x , y , yn , xprev , yprev , fprev , err ) !! Takes a single fixed-size integration step. class ( adams_fixed_integerator ), intent ( inout ) :: this !! The adams_fixed_integerator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The size of the step to take. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent !! variables at x + h will be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. !! !! - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if any of the input arrays are not !!      sized appropriately. !! !! - DIFFEQ_MATRIX_SIZE_ERROR: Occurs if any of the input matrices are !!      not sized appropriately. !! !! - DIFFEQ_MISSING_ARGUMENT_ERROR: Occurs if xprev, yprev, and/or !!      fprev are not provided. ! Model Constants real ( real64 ), parameter :: a1 = 5 5.0d0 / 2 4.0d0 real ( real64 ), parameter :: a2 = - 5 9.0d0 / 2 4.0d0 real ( real64 ), parameter :: a3 = 3 7.0d0 / 2 4.0d0 real ( real64 ), parameter :: a4 = - 9.0d0 / 2 4.0d0 real ( real64 ), parameter :: b1 = 9.0d0 / 2 4.0d0 real ( real64 ), parameter :: b2 = 1 9.0d0 / 2 4.0d0 real ( real64 ), parameter :: b3 = - 5.0d0 / 2 4.0d0 real ( real64 ), parameter :: b4 = 1.0d0 / 2 4.0d0 ! Local Variables integer ( int32 ) :: i , j , n , neqn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( y ) n = this % get_order () ! Input Checking if ( size ( yn ) /= neqn ) then call report_array_size_error ( errmgr , \"afi_step\" , \"yn\" , neqn , size ( yn )) return end if if (. not . present ( yprev )) then call report_missing_argument ( errmgr , \"afi_step\" , \"xprev\" ) return end if if (. not . present ( yprev )) then call report_missing_argument ( errmgr , \"afi_step\" , \"yprev\" ) return end if if (. not . present ( fprev )) then call report_missing_argument ( errmgr , \"afi_step\" , \"fprev\" ) return end if if ( size ( xprev ) < n ) then call report_array_size_error ( errmgr , \"afi_step\" , \"xprev\" , n , & size ( xprev )) return end if if ( size ( yprev , 1 ) < n . or . size ( yprev , 2 ) /= neqn ) then call report_matrix_size_error ( errmgr , \"afi_step\" , \"yprev\" , n , neqn , & size ( yprev , 1 ), size ( yprev , 2 )) return end if if ( size ( fprev , 1 ) < n . or . size ( fprev , 2 ) /= neqn ) then call report_matrix_size_error ( errmgr , \"afi_step\" , \"fprev\" , n , neqn , & size ( fprev , 1 ), size ( fprev , 2 )) return end if ! Compute the Adams-Bashforth predictor yn = y + h * ( & a1 * fprev (:, 1 ) + & a2 * fprev (:, 2 ) + & a3 * fprev (:, 3 ) + & a4 * fprev (:, 4 ) & ) call shift ( fprev ) call sys % ode ( x + h , yn , fprev (:, 1 )) ! Compute the Adams-Moulton corrector yn = y + h * ( & b1 * fprev (:, 1 ) + & b2 * fprev (:, 2 ) + & b3 * fprev (:, 3 ) + & b4 * fprev (:, 4 ) & ) call sys % ode ( x + h , yn , fprev (:, 1 )) ! End return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_abmf.f90.html"},{"title":"diffeq_base.f90 – DIFFEQ","text":"Contents Modules diffeq_base Source Code diffeq_base.f90 Source Code module diffeq_base !! A collection of base types for the DIFFEQ library. use iso_fortran_env use diffeq_errors use ferror implicit none private public :: ode public :: ode_jacobian public :: ode_mass_matrix public :: ode_container public :: ode_integrator public :: ode_solver public :: ode_integer_inquiry ! ------------------------------------------------------------------------------ interface subroutine ode ( x , y , dydx ) use iso_fortran_env real ( real64 ), intent ( in ) :: x real ( real64 ), intent ( in ), dimension (:) :: y real ( real64 ), intent ( out ), dimension (:) :: dydx end subroutine subroutine ode_jacobian ( x , y , jac ) use iso_fortran_env real ( real64 ), intent ( in ) :: x real ( real64 ), intent ( in ), dimension (:) :: y real ( real64 ), intent ( out ), dimension (:,:) :: jac end subroutine subroutine ode_mass_matrix ( x , y , m ) use iso_fortran_env real ( real64 ), intent ( in ) :: x real ( real64 ), intent ( in ), dimension (:) :: y real ( real64 ), intent ( out ), dimension (:,:) :: m end subroutine end interface ! ------------------------------------------------------------------------------ type ode_container !! A container for the routine containing the ODEs to integrate. logical , private :: m_massDependent = . true . ! A value determining if the mass matrix is state dependent such !! that it must be recomputed at each step. real ( real64 ), private , allocatable , dimension (:) :: m_jwork ! Jacobian calculation workspace array. real ( real64 ), private :: m_fdStep = sqrt ( epsilon ( 1.0d0 )) ! Finite difference step size. procedure ( ode ), pointer , public , nopass :: fcn => null () !! A pointer to the routine containing the ODEs to integrate. procedure ( ode_jacobian ), pointer , public , nopass :: & jacobian => null () !! A pointer to the routine containing the analytical Jacobian. !! If supplied, this routine is utilized; however, if null, a finite !! difference approximation is utilized. procedure ( ode_mass_matrix ), pointer , public , nopass :: & mass_matrix => null () !! A pointer to the routine containing the mass matrix for the !! system.  If set to null (the default), an identity mass matrix !! will be assumed. contains procedure , private :: allocate_workspace => oc_alloc_workspace procedure , public :: get_finite_difference_step => oc_get_fd_step procedure , public :: set_finite_difference_step => oc_set_fd_step procedure , public :: get_is_mass_matrix_dependent => & oc_get_is_mass_dependent procedure , public :: set_is_mass_matrix_dependent => & oc_set_is_mass_dependent procedure , public :: compute_jacobian => oc_jacobian procedure , public :: ode => oc_ode_fcn procedure , public :: get_is_ode_defined => oc_get_is_ode_defined end type ! ------------------------------------------------------------------------------ type , abstract :: ode_integrator !! The most basic ODE integrator object capable of integrating !! systems of ODE's. contains procedure ( ode_solver ), public , pass , deferred :: solve !! Solves the supplied system of ODE's. procedure ( ode_integer_inquiry ), public , pass , deferred :: get_order !! Returns the order of the integrator. end type interface function ode_solver ( this , sys , x , iv , err ) result ( rst ) !! Solves the supplied system of ODE's. use iso_fortran_env use ferror import ode_integrator import ode_container class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array, of at least 2 values, defining at a minimum !! the starting and ending values of the independent variable !! integration range.  If more than two values are specified, !! the integration results will be returned at the supplied !! values. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is !!      defined. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than !!      2 values given in the independent variable array x. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-N matrix where M is the number of solution points, !! and N is the number of ODEs plus 1.  The first column !! contains the values of the independent variable at which the !! results were computed.  The remaining columns contain the !! integration results for each ODE. end function pure function ode_integer_inquiry ( this ) result ( rst ) !! Returns an integer value from the ode_integrator object. use iso_fortran_env import ode_integrator class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. integer ( int32 ) :: rst !! The requested value. end function end interface contains ! ****************************************************************************** ! ODE_CONTAINER ROUTINES ! ------------------------------------------------------------------------------ pure function oc_get_fd_step ( this ) result ( rst ) !! Gets the size of the step to use for the finite difference !! calculations used to estimate the Jacobian. class ( ode_container ), intent ( in ) :: this !! The ode_container object. real ( real64 ) :: rst !! The step size. rst = this % m_fdStep end function ! -------------------- subroutine oc_set_fd_step ( this , x ) !! Sets the size of the step to use for the finite difference !! calculations used to estimate the Jacobian. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. real ( real64 ), intent ( in ) :: x !! The step size. this % m_fdStep = x end subroutine ! ------------------------------------------------------------------------------ pure function oc_get_is_mass_dependent ( this ) result ( rst ) !! Gets a value determining if the mass matrix is state-dependent !! such that it requires updating at every integration step. class ( ode_container ), intent ( in ) :: this !! The ode_container object. logical :: rst !! True if the mass matrix is state-dependent such that it !! requires updating at each integration step; else, false if the !! mass matrix is not state-dependent and can be treated as constant !! for all integration steps. rst = this % m_massDependent end function ! -------------------- subroutine oc_set_is_mass_dependent ( this , x ) !! Sets a value determining if the mass matrix is state-dependent !! such that it requires updating at every integration step. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. logical :: x !! True if the mass matrix is state-dependent such that it !! requires updating at each integration step; else, false if the !! mass matrix is not state-dependent and can be treated as constant !! for all integration steps. this % m_massDependent = x end subroutine ! ------------------------------------------------------------------------------ subroutine oc_jacobian ( this , x , y , jac , err ) !! Computes the Jacobian matrix for the system of ODEs.  If !! a routine is provided with an analytical Jacobian, the supplied !! routine is utilized; else, the Jacobian is estimated via a forward !! difference approximation. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. real ( real64 ), intent ( in ) :: x !! The current independent variable value. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current dependent !! variable values. real ( real64 ), intent ( out ), dimension (:,:) :: jac !! An N-by-N matrix where the Jacobian will be written. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is defined, !!      and the calculation is being performed by finite differences. !! !!  - DIFFEQ_MATRIX_SIZE_ERROR: Occurs if jac is not N-by-N. ! Local Variables integer ( int32 ) :: i , ndof real ( real64 ) :: h class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ndof = size ( y ) h = this % get_finite_difference_step () ! Input Checking if ( size ( jac , 1 ) /= ndof . or . size ( jac , 2 ) /= ndof ) then call report_matrix_size_error ( errmgr , \"oc_jacobian\" , \"jac\" , & ndof , ndof , size ( jac , 1 ), size ( jac , 2 )) return end if ! Use a user-defined routine, and then be done if ( associated ( this % jacobian )) then call this % jacobian ( x , y , jac ) return end if ! Allocate workspace.  No action is taken if the proper workspace is ! already allocated. call this % allocate_workspace ( ndof , errmgr ) if ( errmgr % has_error_occurred ()) return ! Finite Difference Approximation ! J(i,j) = df(i) / dy(j) this % m_jwork ( 1 : ndof ) = y call this % ode ( x , y , this % m_jwork ( ndof + 1 :)) do i = 1 , ndof this % m_jwork ( i ) = this % m_jwork ( i ) + h call this % ode ( x , this % m_jwork ( 1 : ndof ), jac (:, i )) jac (:, i ) = ( jac (:, i ) - this % m_jwork ( ndof + 1 :)) / h this % m_jwork ( i ) = y ( i ) end do ! End return end subroutine ! ------------------------------------------------------------------------------ subroutine oc_alloc_workspace ( this , ndof , err ) ! Use to allocate internal workspaces.  This routine only takes action ! if the workspace array(s) are not sized properly for the application. class ( ode_container ), intent ( inout ) :: this ! The ode_container object. integer ( int32 ), intent ( in ) :: ndof ! The number of degrees of freedom. class ( errors ), intent ( inout ) :: err ! The error handling object. ! Local Variables integer ( int32 ) :: flag ! Jacobian Workspace Allocation if ( allocated ( this % m_jwork )) then if ( size ( this % m_jwork ) /= 2 * ndof ) then deallocate ( this % m_jwork ) allocate ( this % m_jwork ( 2 * ndof ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) then call report_memory_error ( err , \"oc_alloc_workspace\" , flag ) return end if end if else allocate ( this % m_jwork ( 2 * ndof ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) then call report_memory_error ( err , \"oc_alloc_workspace\" , flag ) return end if end if ! End return end subroutine ! ------------------------------------------------------------------------------ subroutine oc_ode_fcn ( this , x , y , dydx ) !! Evaluates the ODEs by evaluating the routine defined by !! fcn.  This routine may also be overidden to provide custom !! functionallity. class ( ode_container ), intent ( in ) :: this !! The ode_container object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: dydx !! An N-element array where the output of each of the !! N ODEs will be written. ! Process if ( associated ( this % fcn )) then call this % fcn ( x , y , dydx ) end if end subroutine ! ------------------------------------------------------------------------------ pure function oc_get_is_ode_defined ( this ) result ( rst ) !! Gets a logical value determining if the ODE routine has been defined. class ( ode_container ), intent ( in ) :: this !! The ode_container object. logical :: rst !! True if the ODE routine has been defined; else, false. rst = associated ( this % fcn ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_base.f90.html"},{"title":"diffeq_bsrk32_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_bsrk32_constants Source Code diffeq_bsrk32_constants.f90 Source Code module diffeq_bsrk32_constants use iso_fortran_env implicit none real ( real64 ), parameter :: a21 = 0.5d0 real ( real64 ), parameter :: a31 = 0.0d0 real ( real64 ), parameter :: a32 = 0.75d0 real ( real64 ), parameter :: a41 = 2.0d0 / 9.0d0 real ( real64 ), parameter :: a42 = 1.0d0 / 3.0d0 real ( real64 ), parameter :: a43 = 4.0d0 / 9.0d0 real ( real64 ), parameter :: b1 = 2.0d0 / 9.0d0 real ( real64 ), parameter :: b2 = 1.0d0 / 3.0d0 real ( real64 ), parameter :: b3 = 4.0d0 / 9.0d0 real ( real64 ), parameter :: b4 = 0.0d0 real ( real64 ), parameter :: b1a = 7.0d0 / 2 4.0d0 real ( real64 ), parameter :: b2a = 1.0d0 / 4.0d0 real ( real64 ), parameter :: b3a = 1.0d0 / 3.0d0 real ( real64 ), parameter :: b4a = 1.0d0 / 8.0d0 real ( real64 ), parameter :: c1 = 0.0d0 real ( real64 ), parameter :: c2 = 0.5d0 real ( real64 ), parameter :: c3 = 0.75d0 real ( real64 ), parameter :: c4 = 1.0d0 end module","tags":"","loc":"sourcefile\\diffeq_bsrk32_constants.f90.html"},{"title":"diffeq_dprk45_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_dprk45_constants Source Code diffeq_dprk45_constants.f90 Source Code module diffeq_dprk45_constants use iso_fortran_env implicit none ! Dormand-Prince 4th/5th Order Model Coefficients real ( real64 ), parameter :: a21 = 1.0d0 / 5.0d0 real ( real64 ), parameter :: a31 = 3.0d0 / 4 0.0d0 real ( real64 ), parameter :: a32 = 9.0d0 / 4 0.0d0 real ( real64 ), parameter :: a41 = 4 4.0d0 / 4 5.0d0 real ( real64 ), parameter :: a42 = - 5 6.0d0 / 1 5.0d0 real ( real64 ), parameter :: a43 = 3 2.0d0 / 9.0d0 real ( real64 ), parameter :: a51 = 1.9372d4 / 6.561d3 real ( real64 ), parameter :: a52 = - 2.536d4 / 2.187d3 real ( real64 ), parameter :: a53 = 6.4448d4 / 6.561d3 real ( real64 ), parameter :: a54 = - 2.12d2 / 7.29d2 real ( real64 ), parameter :: a61 = 9.017d3 / 3.168d3 real ( real64 ), parameter :: a62 = - 3.55d2 / 3 3.0d0 real ( real64 ), parameter :: a63 = 4.6732d4 / 5.247d3 real ( real64 ), parameter :: a64 = 4 9.0d0 / 1.76d2 real ( real64 ), parameter :: a65 = - 5.103d3 / 1.8656d4 real ( real64 ), parameter :: a71 = 3 5.0d0 / 3.84d2 real ( real64 ), parameter :: a72 = 0.0d0 real ( real64 ), parameter :: a73 = 5.0d2 / 1.113d3 real ( real64 ), parameter :: a74 = 1.25d2 / 1.92d2 real ( real64 ), parameter :: a75 = - 2.187d3 / 6.784d3 real ( real64 ), parameter :: a76 = 1 1.0d0 / 8 4.0d0 real ( real64 ), parameter :: e1 = - 7 1.0d0 / 5.76d4 real ( real64 ), parameter :: e2 = 0.0d0 real ( real64 ), parameter :: e3 = 7 1.0d0 / 1.6695d4 real ( real64 ), parameter :: e4 = - 7 1.0d0 / 1.92d3 real ( real64 ), parameter :: e5 = 1.7253d4 / 3.392d5 real ( real64 ), parameter :: e6 = - 2 2.0d0 / 5.25d2 real ( real64 ), parameter :: e7 = 1.0d0 / 4.0d1 real ( real64 ), parameter :: c2 = 1.0d0 / 5.0d0 real ( real64 ), parameter :: c3 = 3.0d0 / 1.0d1 real ( real64 ), parameter :: c4 = 4.0d0 / 5.0d0 real ( real64 ), parameter :: c5 = 8.0d0 / 9.0d0 real ( real64 ), parameter :: c6 = 1.0d0 real ( real64 ), parameter :: c7 = 1.0d0 ! Interpolation Parameters real ( real64 ), parameter :: d1 = - 1.2715105075d10 / 1.1282082432d10 real ( real64 ), parameter :: d3 = 8.74874797d10 / 3.2700410799d10 real ( real64 ), parameter :: d4 = - 1.0690763975d10 / 1.880347072d9 real ( real64 ), parameter :: d5 = 7.01980252875d11 / 1.99316789632d11 real ( real64 ), parameter :: d6 = - 1.453857185d9 / 8.22651844d8 real ( real64 ), parameter :: d7 = 6.9997945d7 / 2.9380423d7 end module","tags":"","loc":"sourcefile\\diffeq_dprk45_constants.f90.html"},{"title":"diffeq_errors.f90 – DIFFEQ","text":"Contents Modules diffeq_errors Source Code diffeq_errors.f90 Source Code module diffeq_errors !! A collection of routines for handling errors in the DIFFEQ library. use iso_fortran_env use ferror implicit none ! ------------------------------------------------------------------------------ ! Error Flags integer ( int32 ), parameter :: DIFFEQ_MEMORY_ALLOCATION_ERROR = 10000 integer ( int32 ), parameter :: DIFFEQ_NULL_POINTER_ERROR = 10001 integer ( int32 ), parameter :: DIFFEQ_MATRIX_SIZE_ERROR = 10002 integer ( int32 ), parameter :: DIFFEQ_ARRAY_SIZE_ERROR = 10003 integer ( int32 ), parameter :: DIFFEQ_INVALID_INPUT_ERROR = 10004 integer ( int32 ), parameter :: DIFFEQ_MISSING_ARGUMENT_ERROR = 10005 integer ( int32 ), parameter :: DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR = 10006 integer ( int32 ), parameter :: DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR = 10007 integer ( int32 ), parameter :: DIFFEQ_INVALID_OPERATION_ERROR = 10008 ! ------------------------------------------------------------------------------ contains ! ------------------------------------------------------------------------------ subroutine report_memory_error ( err , fcn , flag ) !! Reports a memory error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: flag !! The memory status flag. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_MEMORY_ALLOCATION_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_error ( err , fcn , varname , exprow , expcol , & actrow , actcol ) !! Reports a matrix size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: exprow !! The expected number of rows. integer ( int32 ), intent ( in ) :: expcol !! The expected number of columns. integer ( int32 ), intent ( in ) :: actrow !! The actual number of rows. integer ( int32 ), intent ( in ) :: actcol !! The actual number of columns. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"The matrix \" // varname // \" was expected to be (\" , & exprow , \"-by-\" , expcol , \"), but was found to be (\" , actrow , \"-by-\" , & actcol , \").\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_min_array_size_not_met ( err , fcn , varname , minsize , actsize ) !! Reports an error where the minimum array size was not met. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: minsize !! The minimum size of the array. integer ( int32 ), intent ( in ) :: actsize !! The actual size of the array. ! Local Variables character ( len = 256 ) :: errmsg ! Process write ( errmsg , 100 ) \"Array \" // varname // \" must be at least of size \" , & minsize , \", but was found to be of size \" , actsize , \".\" call err % report_error ( fcn , trim ( errmsg ), DIFFEQ_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_missing_ode ( err , fcn ) !! Reports a missing ODE routine. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. ! Process call err % report_error ( fcn , \"No ODE routine has been supplied.\" , & DIFFEQ_NULL_POINTER_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine report_array_size_error ( err , fcn , varname , expsize , actsize ) !! Reports an array size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: expsize !! The expected size of the array. integer ( int32 ), intent ( in ) :: actsize !! The actual size of the array. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"Array \" // varname // \" was expected to be of size \" , & expsize , \", but was found to be of size \" , actsize , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_missing_argument ( err , fcn , arg ) !! Reports a missing argument error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: arg !! The name of the argument. ! Process call err % report_error ( fcn , \"Argument \" // arg // \" was missing.\" , & DIFFEQ_MISSING_ARGUMENT_ERROR ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_step_size_too_small ( err , fcn , x , h ) !! Reports an error when the step size becomes too small. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the step size error !! occurred. real ( real64 ), intent ( in ) :: h !! The step size value. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) \"A step size of \" , h , \" was encountered at x = \" , x , & \", and is too small to continue integration.\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR ) ! Formatting 100 format ( A , EN0 . 3 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_excessive_iterations ( err , fcn , n , x ) !! Reports an error when excessive iterations have been made. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: n !! The number of iterations. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the error occurred. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) \"The allowable iteration count was exceeded (iteration \" , & n , \") at x = \" , x , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR ) ! Formatting 100 format ( A , I0 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_excessive_integration_steps ( err , fcn , n , x ) !! Reports an error when an excessive  amount integration steps have been !! taken. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: n !! The number of integration steps. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the error occurred. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) & \"The allowable number of integration steps was exceeded (step \" , & n , \" at x = \" , x , \".\" ! Formatting 100 format ( A , I0 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_errors.f90.html"},{"title":"diffeq_fixed_step.f90 – DIFFEQ","text":"Contents Modules diffeq_fixed_step Source Code diffeq_fixed_step.f90 Source Code module diffeq_fixed_step use iso_fortran_env use diffeq_base use diffeq_errors implicit none private public :: fixed_step_integrator public :: ode_fixed_step ! ------------------------------------------------------------------------------ type , abstract , extends ( ode_integrator ) :: fixed_step_integrator !! Defines a fixed-step integrator. contains procedure , public :: solve => fsi_solver !! Solves the supplied system of ODE's. procedure ( ode_fixed_step ), public , pass , deferred :: step !! Takes a single integration step. end type ! diffeq_fs_integrator.f90 interface subroutine ode_fixed_step ( this , sys , h , x , y , yn , xprev , yprev , fprev , & err ) !! Takes a single fixed-size integration step. use iso_fortran_env use ferror import fixed_step_integrator import ode_container class ( fixed_step_integrator ), intent ( inout ) :: this !! The fixed_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The size of the step to take. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent !! variables at x + h will be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. end subroutine end interface contains ! ------------------------------------------------------------------------------ function fsi_solver ( this , sys , x , iv , err ) result ( rst ) !! Solves the supplied system of ODE's. class ( fixed_step_integrator ), intent ( inout ) :: this !! The fixed_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array, of at least 2 values, defining at a minimum !! the starting and ending values of the independent variable !! integration range.  If more than two values are specified, !! the integration results will be returned at the supplied !! values. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !! - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. !! !! - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is !!      defined. !! !! - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than !!      2 values given in the independent variable array x. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-N matrix where M is the number of solution points, !! and N is the number of ODEs plus 1.  The first column !! contains the values of the independent variable at which the !! results were computed.  The remaining columns contain the !! integration results for each ODE. ! Local Variables integer ( int32 ) :: i , j , npts , neqn , flag real ( real64 ) :: h class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) neqn = size ( iv ) ! Input Checking if ( npts < 2 ) then call report_min_array_size_not_met ( errmgr , \"fsi_solver\" , \"x\" , 2 , npts ) return end if if (. not . sys % get_is_ode_defined ()) then call report_missing_ode ( errmgr , \"fsi_solver\" ) return end if ! Memory Allocation allocate ( rst ( npts , neqn + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"fsi_solver\" , flag ) return end if ! Process rst ( 1 , 1 ) = x ( 1 ) rst ( 1 , 2 :) = iv do i = 2 , npts ! Compute the solution j = i - 1 h = x ( i ) - x ( j ) rst ( i , 1 ) = x ( i ) call this % step ( sys , h , rst ( j , 1 ), rst ( j , 2 :), rst ( i , 2 :), err = errmgr ) if ( errmgr % has_error_occurred ()) return end do ! End return end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_fixed_step.f90.html"},{"title":"diffeq_implicit_runge_kutta.f90 – DIFFEQ","text":"Contents Modules diffeq_implicit_runge_kutta Source Code diffeq_implicit_runge_kutta.f90 Source Code module diffeq_implicit_runge_kutta use iso_fortran_env use diffeq_runge_kutta use diffeq_errors use diffeq_base use linalg implicit none private public :: build_factored_newton_matrix_routine public :: implicit_rk_variable_integrator public :: sdirk_integrator public :: sdirk4_integrator type , abstract , extends ( rk_variable_integrator ) :: & implicit_rk_variable_integrator !! Defines an implicit Runge-Kutta variable-step integrator. real ( real64 ), private :: m_hold = 0.0d0 ! The most recent successful step size logical , private :: m_isJacCurrent = . false . ! Is the Jacobian current? logical , private :: m_usePI = . true . ! Use a PI step size (true) or a Gustafsson controller (false) contains procedure , public :: get_previous_step_size => irk_get_old_step !! Gets the most recent successful step size. procedure , public :: set_previous_step_size => irk_set_old_step !! Sets the most recent successful step size. procedure , public :: compute_next_step_size => & irk_compute_next_step_size !! Computes the next step size. procedure , public :: get_is_jacobian_current => irk_get_is_jac_current !! Gets a value determining if the Jacobian matrix estimate is !! current such that it does not need to be recomputed at this time. procedure , public :: set_is_jacobian_current => irk_set_is_jac_current !! Sets a value determining if the Jacobian matrix estimate is !! current such that it does not need to be recomputed at this time. procedure ( build_factored_newton_matrix_routine ), public , deferred :: & build_factored_newton_matrix !! Builds the matrix of the form  X = f I - J  or !!  X = f M - J  if a mass matrix is defined, and then computes !! its LU factorization.  The Jacobian and mass matrices are !! evaluated as part of this process, if necessary. procedure , public :: get_use_pi_controller => irk_get_use_pi_controller !! Gets a parameter determining if a PI step size controller !! or a Gustafsson step size controller should be used. The default !! is to use a PI step size controller. procedure , public :: set_use_pi_controller => irk_set_use_pi_controller !! Sets a parameter determining if a PI step size controller !! or a Gustafsson step size controller should be used. The default !! is to use a PI step size controller. procedure , public :: estimate_first_step_size => irk_estimate_first_step !! Computes an estimate to the first step size based upon the !! initial function values. end type interface subroutine build_factored_newton_matrix_routine ( this , sys , h , x , y , err ) use iso_fortran_env , only : real64 use ferror , only : errors import implicit_rk_variable_integrator import ode_container class ( implicit_rk_variable_integrator ), intent ( inout ) :: this class ( ode_container ), intent ( inout ) :: sys real ( real64 ), intent ( in ) :: h real ( real64 ), intent ( in ) :: x real ( real64 ), intent ( in ), dimension (:) :: y class ( errors ), intent ( inout ), optional , target :: err end subroutine end interface ! ------------------------------------------------------------------------------ type , abstract , extends ( implicit_rk_variable_integrator ) :: sdirk_integrator !! Defines a base structure for singly diagonally implicit !! Runge-Kutta integrators. real ( real64 ), private , allocatable , dimension (:,:) :: m_jac ! Jacobian matrix workspace real ( real64 ), private , allocatable , dimension (:,:) :: m_mass ! Mass matrix workspace real ( real64 ), private , allocatable , dimension (:,:) :: m_mtx ! System matrix workspace integer ( int32 ), private , allocatable , dimension (:) :: m_pvt ! LU pivot tracking workspace real ( real64 ), private , allocatable , dimension (:) :: m_w ! NEQN-element workspace array real ( real64 ), private , allocatable , dimension (:) :: m_dy ! NEQN-element workspace array integer ( int32 ), private :: m_maxNewtonIter = 7 ! Allowable number of Newton iterations real ( real64 ), private :: m_newtontol = 1.0d-6 ! Newton iteration tolerance contains procedure , public :: initialize => sdirk_alloc_workspace !! Initializes the integrator. procedure , public :: build_newton_matrix => sdirk_build_matrix !! Builds the system matrix of the form  X = f I - J  !! or  X = f M - J  if a mass matrix is defined. procedure , public :: build_factored_newton_matrix => & sdirk_build_factored_matrix !! Builds the matrix of the form  X = f I - J  or !!  X = f M - J  if a mass matrix is defined, and then computes !! its LU factorization.  The Jacobian and mass matrices are !! evaluated as part of this process, if necessary. procedure , public :: get_max_newton_iteration_count => & sdirk_get_max_newton_iter !! Gets the maximum allowed number of Newton iterations. procedure , public :: set_max_newton_iteration_count => & sdirk_set_max_newton_iter !! Sets the maximum allowed number of Newton iterations. procedure , public :: get_newton_tolerance => sdirk_get_newton_tol !! Gets the tolerance used to check for convergence of the !! Newton iterations. procedure , public :: set_newton_tolerance => sdirk_set_newton_tol !! Sets the tolerance used to check for convergence of the !! Newton iterations. procedure , public :: attempt_step => sdirk_attempt_step !! Attempts a single integration step. procedure , public :: solve_newton_stage => sdirk_solve_newton !! Solves the Newton iteration problem for the i-th stage. end type ! ------------------------------------------------------------------------------ type , extends ( sdirk_integrator ) :: sdirk4_integrator !! Defines a singly diagonally implicit 4th order Runge-Kutta !! integrator suitable for integrating stiff systems of differential !! equations. logical , private :: m_modelDefined = . false . real ( real64 ), private , allocatable , dimension (:,:) :: m_dc ! Interpolation coefficients for dense output contains procedure , public :: get_order => sd4_get_order !! Returns the order of the integrator. procedure , public :: get_stage_count => sd4_get_stage_count !! Gets the number of stages used by the integrator. procedure , public :: define_model => sd4_define_model !! Defines (initializes) the model parameters. procedure , public :: is_fsal => sd4_is_fsal !! Determines if the integrator is an FSAL (first same as last) !! integrator. procedure , public :: interpolate => sd4_interp !! Provides interpolation between integration points allowing for !! dense output. procedure , public :: set_up_interpolation => sd4_set_up_interp !! Sets up the interpolation polynomial. procedure , public :: initialize => sd4_alloc_workspace !! Initializes the integrator. end type contains ! ------------------------------------------------------------------------------ pure function irk_get_old_step ( this ) result ( rst ) !! Gets the most recent successful step size. class ( implicit_rk_variable_integrator ), intent ( in ) :: this !! The implicit_rk_variable_integrator object. real ( real64 ) :: rst !! The step size. rst = this % m_hold end function ! --------------------- subroutine irk_set_old_step ( this , x ) !! Sets the most recent successful step size. class ( implicit_rk_variable_integrator ), intent ( inout ) :: this !! The implicit_rk_variable_integrator object. real ( real64 ), intent ( in ) :: x !! The step size. this % m_hold = x end subroutine ! ------------------------------------------------------------------------------ function irk_compute_next_step_size ( this , hn , en , enm1 ) result ( rst ) !! Computes the next step size. class ( implicit_rk_variable_integrator ), intent ( inout ) :: this !! The implicit_rk_variable_integrator object. real ( real64 ), intent ( in ) :: hn !! The current step size. real ( real64 ), intent ( in ) :: en !! The norm of the error for the current step size. real ( real64 ), intent ( in ) :: enm1 !! The norm of the error from the previous step size. real ( real64 ) :: rst !! The new step size. ! Parameters real ( real64 ), parameter :: fac1 = 5.0d0 real ( real64 ), parameter :: fac2 = 1.0d0 / 8.0d0 ! Local Variables real ( real64 ) :: fac , safe , hnew , facpred , e , hold , hmax ! Process if ( this % get_use_pi_controller ()) then rst = pi_controller ( this % get_alpha (), this % get_beta (), & this % get_order (), hn , en , enm1 , this % get_safety_factor (), & this % get_max_step_size ()) else ! Initialization safe = this % get_safety_factor () e = 1.0d0 / real ( this % get_order (), real64 ) fac = max ( fac2 , min ( fac1 , ( en ** 2 / enm1 ) ** e / safe )) rst = hn / fac hold = this % get_previous_step_size () hmax = this % get_max_step_size () ! Process if ( en <= 1.0d0 ) then if (. not . this % get_is_first_step ()) then facpred = ( hold / hn ) * ( en ** 2 / enm1 ) ** e / safe facpred = max ( fac2 , min ( fac1 , facpred )) fac = max ( fac , facpred ) rst = hn / fac end if call this % set_is_first_step (. false .) call this % set_previous_step_size ( hn ) call this % set_previous_error_norm ( max ( 1.0d-2 , en )) end if if ( abs ( rst ) > abs ( hmax )) rst = sign ( hmax , rst ) end if end function ! ------------------------------------------------------------------------------ pure function irk_get_is_jac_current ( this ) result ( rst ) !! Gets a value determining if the Jacobian matrix estimate is current such !! that it does not need to be recomputed at this time. class ( implicit_rk_variable_integrator ), intent ( in ) :: this !! The implicit_rk_variable_integrator object. logical :: rst !! True if the Jacobian matrix is current; else, false. rst = this % m_isJacCurrent end function ! --------------------- subroutine irk_set_is_jac_current ( this , x ) !! Sets a value determining if the Jacobian matrix estimate is current such !! that it does not need to be recomputed at this time. class ( implicit_rk_variable_integrator ), intent ( inout ) :: this !! The implicit_rk_variable_integrator object. logical , intent ( in ) :: x !! True if the Jacobian matrix is current; else, false. this % m_isJacCurrent = x end subroutine ! ------------------------------------------------------------------------------ pure function irk_get_use_pi_controller ( this ) result ( rst ) !! Gets a parameter determining if a PI step size controller or a Gustafsson !! step size controller should be used. The default is to use a PI step !! size controller. class ( implicit_rk_variable_integrator ), intent ( in ) :: this !! The implicit_rk_variable_integrator object. logical :: rst !! True to use a PI controller; else, false to use a Gustafsson !! controller. rst = this % m_usePI end function ! --------------------- subroutine irk_set_use_pi_controller ( this , x ) !! Sets a parameter determining if a PI step size controller or a Gustafsson !! step size controller should be used. The default is to use a PI step !! size controller. class ( implicit_rk_variable_integrator ), intent ( inout ) :: this !! The implicit_rk_variable_integrator object. logical , intent ( in ) :: x !! True to use a PI controller; else, false to use a Gustafsson !! controller. this % m_usePI = x end subroutine ! ------------------------------------------------------------------------------ pure function irk_estimate_first_step ( this , xo , xf , yo , fo ) result ( rst ) !! Computes an estimate to the first step size based upon the initial !! function values. class ( implicit_rk_variable_integrator ), intent ( in ) :: this !! The implicit_rk_variable_integrator object. real ( real64 ), intent ( in ) :: xo !! The initial value of the independent variable. real ( real64 ), intent ( in ) :: xf !! The final value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yo !! An N-element array containing the initial values. real ( real64 ), intent ( in ), dimension (:) :: fo !! An N-element array containing the initial function values. real ( real64 ) :: rst !! An estimate on the initial step size. ! Local Variables real ( real64 ) :: h1 , h2 ! Process h1 = 1.0d-5 * ( xf - xo ) h2 = this % get_max_step_size () rst = sign ( min ( abs ( h1 ), abs ( h2 )), h1 ) end function ! ****************************************************************************** ! SDIRK INTEGRATOR - BASE TYPE ! ------------------------------------------------------------------------------ subroutine sdirk_alloc_workspace ( this , neqn , err ) !! Initializes the integrator. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. ! Local Variables integer ( int32 ) :: flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Allocations if ( allocated ( this % m_jac )) then if ( size ( this % m_jac , 1 ) /= neqn . or . size ( this % m_jac , 2 ) /= neqn ) then deallocate ( this % m_jac ) allocate ( this % m_jac ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_jac ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_mass )) then if ( size ( this % m_mass , 1 ) /= neqn . or . size ( this % m_mass , 2 ) /= neqn ) then deallocate ( this % m_mass ) allocate ( this % m_mass ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_mass ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_mtx )) then if ( size ( this % m_mtx , 1 ) /= neqn . or . size ( this % m_mtx , 2 ) /= neqn ) then deallocate ( this % m_mtx ) allocate ( this % m_mtx ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_mtx ( neqn , neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_pvt )) then if ( size ( this % m_pvt ) /= neqn ) then deallocate ( this % m_pvt ) allocate ( this % m_pvt ( neqn ), stat = flag , source = 0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_pvt ( neqn ), stat = flag , source = 0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_w )) then if ( size ( this % m_w ) /= neqn ) then deallocate ( this % m_w ) allocate ( this % m_w ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_w ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_dy )) then if ( size ( this % m_dy ) /= neqn ) then deallocate ( this % m_dy ) allocate ( this % m_dy ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_dy ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"sdirk_alloc_workspace\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ subroutine sdirk_build_factored_matrix ( this , sys , h , x , y , err ) !! Builds the matrix of the form  X = f I - J  or !!  X = f M - J  if a mass matrix is defined, and then computes !! its LU factorization.  The Jacobian and mass matrices are !! evaluated as part of this process, if necessary. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An array containing the current values of the dependent variables. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr logical :: change ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if change = . false . ! Compute the Jacobian, if an update is needed. if (. not . this % get_is_jacobian_current () . or . this % get_is_first_step ()) then ! Recompute the Jacobian call sys % compute_jacobian ( x , y , this % m_jac , errmgr ) if ( errmgr % has_error_occurred ()) return call this % set_is_jacobian_current (. true .) change = . true . end if ! Compute the mass matrix if ( associated ( sys % mass_matrix ) . and . & ( sys % get_is_mass_matrix_dependent () . or . this % get_is_first_step ())) & then call sys % mass_matrix ( x , y , this % m_mass ) change = . true . end if ! Compute the system matrix if ( associated ( sys % mass_matrix )) then call this % build_newton_matrix ( h , this % m_jac , this % m_mtx , this % m_mass ) else call this % build_newton_matrix ( h , this % m_jac , this % m_mtx ) end if ! Compute the LU factorization of the system matrix if anything has changed if ( change ) then call lu_factor ( this % m_mtx , this % m_pvt , errmgr ) if ( errmgr % has_error_occurred ()) return end if end subroutine ! ------------------------------------------------------------------------------ subroutine sdirk_build_matrix ( this , h , jac , x , m , err ) !! Builds the system matrix of the form  X = f I - J  !! or  X = f M - J  if a mass matrix is defined. class ( sdirk_integrator ), intent ( in ) :: this !! The sdirk_integrator object. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ), dimension (:,:) :: jac !! The current NEQN-by-NEQN Jacobian matrix. real ( real64 ), intent ( out ), dimension (:,:) :: x !! An NEQN-by-NEQN matrix where the output will be written. real ( real64 ), intent ( in ), dimension (:,:), optional :: m !! An optional NEQN-by-NEQN mass matrix. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MATRIX_SIZE_ERROR: Occurs if any of the matrices are not !!      sized correctly. ! Local Variables integer ( int32 ) :: i , neqn , ns real ( real64 ) :: fac class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization neqn = size ( this % m_jac , 1 ) ns = this % get_stage_count () if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( size ( jac , 1 ) /= neqn . or . size ( jac , 2 ) /= neqn ) then call report_matrix_size_error ( errmgr , \"sdirk_build_matrix\" , \"jac\" , & neqn , neqn , size ( jac , 1 ), size ( jac , 2 )) return end if if ( size ( x , 1 ) /= neqn . or . size ( x , 2 ) /= neqn ) then call report_matrix_size_error ( errmgr , \"sdirk_build_matrix\" , \"x\" , & neqn , neqn , size ( x , 1 ), size ( x , 2 )) return end if if ( present ( m )) then if ( size ( m , 1 ) /= neqn . or . size ( m , 2 ) /= neqn ) then call report_matrix_size_error ( errmgr , \"sdirk_build_matrix\" , \"m\" , & neqn , neqn , size ( m , 1 ), size ( m , 2 )) return end if end if ! Process fac = this % a ( ns , ns ) * h if ( present ( m )) then x = m - fac * jac else x = - fac * jac do i = 1 , neqn x ( i , i ) = x ( i , i ) + 1.0d0 end do end if ! End return end subroutine ! ------------------------------------------------------------------------------ subroutine sdirk_attempt_step ( this , sys , h , x , y , yn , en , xprev , yprev , & fprev , err ) !! Attempts a single integration step. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the dependent !! variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent variables at !! x + h will be written. real ( real64 ), intent ( out ), dimension (:) :: en real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. ! Local Variables logical :: accept integer ( int32 ) :: i , j , neqn , nstages , niter , maxiter , itertracking real ( real64 ) :: z , tol , disp , val , eval class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( y ) nstages = this % get_stage_count () maxiter = this % get_max_newton_iteration_count () accept = . false . tol = this % get_newton_tolerance () itertracking = 0 ! Ensure the Jacobian is up to date prior to the step if (. not . this % get_is_jacobian_current ()) then call this % build_factored_newton_matrix ( sys , h , x , y , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Process if (. not . this % is_fsal () . or . this % get_is_first_step ()) then ! On FSAL integrators, we only need to make this call on the first step ! as the integrator uses the last evaluation from the previous step ! as this step.  On non-FSAL integrators we always need to compute an ! updated first step. call sys % ode ( x , y , this % f (:, 1 )) end if ! Cycle over each stage and solve the Newton problem do i = 1 , nstages ! Attempt to solve the Newton problem call this % solve_newton_stage ( sys , i , h , x , y , yn , accept , niter ) itertracking = max ( niter , itertracking ) if (. not . accept ) exit end do ! Do we need to update the Jacobian? if (. not . accept ) then ! We couldn't converge - force a Jacobian update call this % set_is_jacobian_current (. false .) ! TO DO: ! Figure out a way to estimate a new step size end if ! Update the solution estimate and error estimate do i = 1 , nstages if ( i == 1 ) then yn = this % b ( i ) * this % f (:, i ) en = this % e ( i ) * this % f (:, i ) else yn = yn + this % b ( i ) * this % f (:, i ) en = en + this % e ( i ) * this % f (:, i ) end if end do yn = y + h * yn en = h * en ! Only update the Jacobian if the Newton iteration encountered difficulty if ( itertracking > maxiter / 2 ) then call this % set_is_jacobian_current (. false .) end if ! End return end subroutine ! ------------------------------------------------------------------------------ pure function sdirk_get_max_newton_iter ( this ) result ( rst ) !! Gets the maximum allowed number of Newton iterations. class ( sdirk_integrator ), intent ( in ) :: this !! The sdirk_integrator object. integer ( int32 ) :: rst !! The iteration limit. rst = this % m_maxNewtonIter end function ! -------------------- subroutine sdirk_set_max_newton_iter ( this , x ) !! Sets the maximum allowed number of Newton iterations. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. integer ( int32 ), intent ( in ) :: x !! The iteration limit. this % m_maxNewtonIter = x end subroutine ! ------------------------------------------------------------------------------ pure function sdirk_get_newton_tol ( this ) result ( rst ) !! Gets the tolerance used to check for convergence of the Newton !! iterations. class ( sdirk_integrator ), intent ( in ) :: this !! The sdirk_integrator object. real ( real64 ) :: rst !! The tolerance. rst = this % m_newtontol end function ! -------------------- subroutine sdirk_set_newton_tol ( this , x ) !! Sets the tolerance used to check for convergence of the Newton !! iterations. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. real ( real64 ), intent ( in ) :: x !! The tolerance. this % m_newtontol = x end subroutine ! ------------------------------------------------------------------------------ subroutine sdirk_solve_newton ( this , sys , i , h , x , y , yw , accept , niter ) !! Solves the Newton iteration problem for the i-th stage. class ( sdirk_integrator ), intent ( inout ) :: this !! The sdirk_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. integer ( int32 ), intent ( in ) :: i !! The current stage number. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the dependent !! variables. real ( real64 ), intent ( out ), dimension (:) :: yw !! An N-element workspace array. logical , intent ( out ) :: accept !! Returns true if the Newton iteration reached convergence; else, !! false if the iteration did not converge. integer ( int32 ), intent ( out ) :: niter !! The number of iterations performed. ! Local Variables integer ( int32 ) :: j , maxiter real ( real64 ) :: z , disp , tol , alpha ! Initialization accept = . false . z = x + this % c ( i ) * h tol = this % get_newton_tolerance () maxiter = this % get_max_newton_iteration_count () yw = y ! Process this % m_w = 0.0d0 do j = 1 , i - 1 alpha = this % a ( i , j ) this % m_w = this % m_w + this % a ( i , j ) * this % f (:, i ) end do this % m_w = y + h * this % m_w call sys % ode ( z , this % m_w , this % f (:, i )) do niter = 1 , maxiter ! Compute the right-hand-side this % m_dy = this % m_w + h * this % a ( i , i ) * this % f (:, i ) - yw ! Solve the system call solve_lu ( this % m_mtx , this % m_pvt , this % m_dy ) ! Update the solution yw = yw + this % m_dy ! Update the function evaluation call sys % ode ( z , yw , this % f (:, i )) ! Check for convergence disp = norm2 ( this % m_dy ) if ( disp < tol ) then accept = . true . exit end if end do end subroutine ! ****************************************************************************** ! SINGLY DIAGONALLY IMPLICIT 4TH ORDER RUNGE-KUTTA INTEGRATOR ! ------------------------------------------------------------------------------ subroutine sd4_alloc_workspace ( this , neqn , err ) use diffeq_sdirk4_constants !! Initializes the integrator. class ( sdirk4_integrator ), intent ( inout ) :: this !! The sdirk4_integrator object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !! - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. ! Local Variables integer ( int32 ) :: norder , nstages , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if norder = this % get_order () nstages = this % get_stage_count () ! Process if ( allocated ( this % m_dc )) then if ( size ( this % m_dc , 1 ) /= norder . or . size ( this % m_dc , 2 ) /= nstages ) & then deallocate ( this % m_dc ) allocate ( this % m_dc ( norder , nstages ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_dc ( norder , nstages ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! Populate the coefficient matrix this % m_dc ( 1 , 1 ) = bs11 this % m_dc ( 2 , 1 ) = bs21 this % m_dc ( 3 , 1 ) = bs31 this % m_dc ( 4 , 1 ) = bs41 this % m_dc ( 1 , 2 ) = bs12 this % m_dc ( 2 , 2 ) = bs22 this % m_dc ( 3 , 2 ) = bs32 this % m_dc ( 4 , 2 ) = bs42 this % m_dc ( 1 , 3 ) = bs13 this % m_dc ( 2 , 3 ) = bs23 this % m_dc ( 3 , 3 ) = bs33 this % m_dc ( 4 , 3 ) = bs43 this % m_dc ( 1 , 4 ) = bs14 this % m_dc ( 2 , 4 ) = bs24 this % m_dc ( 3 , 4 ) = bs34 this % m_dc ( 4 , 4 ) = bs44 this % m_dc ( 1 , 5 ) = bs15 this % m_dc ( 2 , 5 ) = bs25 this % m_dc ( 3 , 5 ) = bs35 this % m_dc ( 4 , 5 ) = bs45 this % m_dc ( 1 , 6 ) = bs16 this % m_dc ( 2 , 6 ) = bs26 this % m_dc ( 3 , 6 ) = bs36 this % m_dc ( 4 , 6 ) = bs46 ! Call the base routine call sdirk_alloc_workspace ( this , neqn , errmgr ) ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"sd4_alloc_workspace\" , flag ) return ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ pure function sd4_get_order ( this ) result ( rst ) !! Returns the order of the integrator. class ( sdirk4_integrator ), intent ( in ) :: this !! The sdirk4_integrator object. integer ( int32 ) :: rst !! The order of the integrator, 4 in this case. rst = 4 end function ! ------------------------------------------------------------------------------ pure function sd4_get_stage_count ( this ) result ( rst ) !! Gets the number of stages used by the integrator. class ( sdirk4_integrator ), intent ( in ) :: this !! The sdirk4_integrator object. integer ( int32 ) :: rst !! The number of stages, 6 in this case. rst = 6 end function ! ------------------------------------------------------------------------------ subroutine sd4_define_model ( this ) use diffeq_sdirk4_constants !! Defines (initializes) the model parameters. class ( sdirk4_integrator ), intent ( inout ) :: this !! The sdirk4_integrator object. ! Process if ( this % m_modelDefined ) return ! A this % a = 0.0d0 this % a ( 2 , 1 ) = a21 this % a ( 2 , 2 ) = a22 this % a ( 3 , 1 ) = a31 this % a ( 3 , 2 ) = a32 this % a ( 3 , 3 ) = a33 this % a ( 4 , 1 ) = a41 this % a ( 4 , 2 ) = a42 this % a ( 4 , 3 ) = a43 this % a ( 4 , 4 ) = a44 this % a ( 5 , 1 ) = a51 this % a ( 5 , 2 ) = a52 this % a ( 5 , 3 ) = a53 this % a ( 5 , 4 ) = a54 this % a ( 5 , 5 ) = a55 this % a ( 6 , 1 ) = b1 this % a ( 6 , 2 ) = b2 this % a ( 6 , 3 ) = b3 this % a ( 6 , 4 ) = b4 this % a ( 6 , 5 ) = b5 this % a ( 6 , 6 ) = b6 ! B this % b ( 1 ) = b1 this % b ( 2 ) = b2 this % b ( 3 ) = b3 this % b ( 4 ) = b4 this % b ( 5 ) = b5 this % b ( 6 ) = b6 ! C this % c ( 1 ) = 0.0d0 this % c ( 2 ) = c2 this % c ( 3 ) = c3 this % c ( 4 ) = c4 this % c ( 5 ) = c5 this % c ( 6 ) = c6 ! E this % e ( 1 ) = b1a - b1 this % e ( 2 ) = b2a - b2 this % e ( 3 ) = b3a - b3 this % e ( 4 ) = b4a - b4 this % e ( 5 ) = b5a - b5 this % e ( 6 ) = b6a - b6 ! Update definition status this % m_modelDefined = . true . end subroutine ! ------------------------------------------------------------------------------ pure function sd4_is_fsal ( this ) result ( rst ) !! Determines if the integrator is an FSAL (first same as last) integrator. class ( sdirk4_integrator ), intent ( in ) :: this !! The sdirk4_integrator object. logical :: rst !! Returns true as this is an FSAL integrator. rst = . true . end function ! ------------------------------------------------------------------------------ subroutine sd4_set_up_interp ( this , x , xn , y , yn , k ) !! Sets up the interpolation polynomial. class ( sdirk4_integrator ), intent ( inout ) :: this !! The sdirk4_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The value of the independent variable at the next step. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution values. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution values at the next step. real ( real64 ), intent ( in ), dimension (:,:) :: k !! An N-by-M matrix containing the intermediate step function outputs !! where M is the number of stages of the integrator. ! No set-up actions required end subroutine ! ------------------------------------------------------------------------------ subroutine sd4_interp ( this , xprev , yprev , xnew , x , y , err ) !! Provides interpolation between integration points allowing for dense !! output. class ( sdirk4_integrator ), intent ( in ) :: this !! The sdirk4_integrator object. real ( real64 ), intent ( in ) :: xprev !! The previous value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yprev !! An N-element array containing the values of the dependent variables !! at xprev. real ( real64 ), intent ( in ) :: xnew !! The updated value of the independent variable. real ( real64 ), intent ( in ) :: x !! The value at which to perform the interpolation. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array containing the interpolated values for each !! equation. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. ! Local Variables integer ( int32 ) :: i , j , norder , nstages , neqn real ( real64 ) :: h , theta , bi real ( real64 ), allocatable , dimension (:) :: yn ! Initialization neqn = size ( yprev ) norder = this % get_order () nstages = this % get_stage_count () h = xnew - xprev theta = ( x - xprev ) / h ! Process allocate ( yn ( neqn ), source = 0.0d0 ) do i = 1 , nstages bi = 0.0d0 do j = 1 , norder bi = bi + this % m_dc ( j , i ) * theta ** j end do yn = yn + bi * this % f (:, i ) end do y = yprev + h * yn end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_implicit_runge_kutta.f90.html"},{"title":"diffeq_multistep_fixed.f90 – DIFFEQ","text":"Contents Modules diffeq_multistep_fixed Source Code diffeq_multistep_fixed.f90 Source Code module diffeq_multistep_fixed use iso_fortran_env use diffeq_fixed_step use diffeq_errors use diffeq_rk4 use diffeq_base implicit none private public :: fixed_multistep_integrator type , abstract , extends ( fixed_step_integrator ) :: fixed_multistep_integrator !! Defines a fixed step-size, multi-step integrator. real ( real64 ), private , allocatable , dimension (:,:) :: m_buffer ! An NEQN-by-ORDER storage matrix for ODE outputs. contains procedure , private :: allocate_workspace => fms_alloc_workspace !! Allocates workspace variables. procedure , public :: solve => fms_solver !! Solves the supplied system of ODEs. end type contains ! ------------------------------------------------------------------------------ subroutine fms_alloc_workspace ( this , neqn , err ) !! Allocates workspace variables. class ( fixed_multistep_integrator ), intent ( inout ) :: this !! The fixed_multistep_integrator object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations to integrate. class ( errors ), intent ( inout ) :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !! - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. ! Local Variables integer ( int32 ) :: n , flag ! Process n = this % get_order () if ( allocated ( this % m_buffer )) then if ( size ( this % m_buffer , 1 ) /= neqn . or . & size ( this % m_buffer , 2 ) /= n ) & then deallocate ( this % m_buffer ) allocate ( this % m_buffer ( neqn , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_buffer ( neqn , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory Error Handling 10 continue call report_memory_error ( err , \"fms_alloc_workspace\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ function fms_solver ( this , sys , x , iv , err ) result ( rst ) !! Solves the supplied system of ODEs. class ( fixed_multistep_integrator ), intent ( inout ) :: this !! The fixed_multistep_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array, of at least 2 values, defining at a minimum !! the starting and ending values of the independent variable !! integration range.  If more than two values are specified, !! the integration results will be returned at the supplied !! values. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is !!      defined. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than !!      2 values given in the independent variable array x. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-N matrix where M is the number of solution points, !! and N is the number of ODEs plus 1.  The first column !! contains the values of the independent variable at which the !! results were computed.  The remaining columns contain the !! integration results for each ODE. ! Local Variables integer ( int32 ) :: i , j , j1 , j2 , npts , neqn , order , mn , flag real ( real64 ) :: h type ( rk4_fixed_integrator ) :: starter class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = :), allocatable :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) neqn = size ( iv ) order = this % get_order () mn = min ( order , npts ) ! Input Checking if ( npts < 2 ) then call report_min_array_size_not_met ( errmgr , \"fms_solver\" , \"x\" , 2 , npts ) return end if if (. not . sys % get_is_ode_defined ()) then call report_missing_ode ( errmgr , \"fms_solver\" ) return end if ! Memory Allocation allocate ( rst ( npts , neqn + 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"fms_solver\" , flag ) return end if call this % allocate_workspace ( neqn , errmgr ) if ( errmgr % has_error_occurred ()) return ! Use a 4th order Runge-Kutta integrator to step into the problem rst ( 1 , 1 ) = x ( 1 ) rst ( 1 , 2 :) = iv call sys % ode ( x ( 1 ), iv , this % m_buffer (:, order )) j2 = order - 1 do i = 2 , mn j = i - 1 h = x ( j ) - x ( i ) call starter % step ( sys , h , x ( j ), rst ( j , 2 :), rst ( i , 2 :)) call sys % ode ( x ( i ), rst ( i , 2 :), this % m_buffer (:, j2 )) j2 = j2 - 1 end do ! Finish the problem with the multi-step method j1 = 1 j2 = order do i = order + 1 , npts h = x ( i ) - x ( j2 ) rst ( i , 1 ) = x ( i ) call this % step ( sys , h , rst ( j2 , 1 ), rst ( j2 , 2 :), rst ( i , 2 :), & rst ( j1 : j2 , 1 ), rst ( j1 : j2 , 2 :), this % m_buffer , err = errmgr ) if ( errmgr % has_error_occurred ()) return j1 = j1 + 1 j2 = j2 + 1 end do ! End return end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_multistep_fixed.f90.html"},{"title":"diffeq_rk4.f90 – DIFFEQ","text":"Contents Modules diffeq_rk4 Source Code diffeq_rk4.f90 Source Code module diffeq_rk4 !! This module provides a 4th order Runge-Kutta fixed-step integrator. use iso_fortran_env use diffeq_rk_fixed_step implicit none private public :: rk4_fixed_integrator type , extends ( rk_fixed_integrator ) :: rk4_fixed_integrator !! Defines the explicit, 4th order, Runge-Kutta fixed-step !! integrator. contains procedure , public :: get_order => rk4_get_order !! Returns the order of the integrator. procedure , public :: get_method_factor => rk4_get_a_param !! Gets the requested method factor from the Butcher tableau. procedure , public :: get_quadrature_weight => rk4_get_b_param !! Gets the requested quadrature weight from the Butcher tableau. procedure , public :: get_position_factor => rk4_get_c_param !! Gets the requested position factor from the Butcher tableau. end type contains ! ------------------------------------------------------------------------------ pure function rk4_get_order ( this ) result ( rst ) !! Returns the order of the integrator. class ( rk4_fixed_integrator ), intent ( in ) :: this !! The rk4_fixed_integrator object. integer ( int32 ) :: rst !! The order of the integrator. rst = 4 end function ! ------------------------------------------------------------------------------ pure function rk4_get_a_param ( this , i , j ) result ( rst ) !! Gets the requested method factor from the Butcher tableau. class ( rk4_fixed_integrator ), intent ( in ) :: this !! The rk4_fixed_integrator object. integer ( int32 ), intent ( in ) :: i !! The row index of the parameter from the Butcher tableau. integer ( int32 ), intent ( in ) :: j !! The column index of the parameter from the Butcher tableau. real ( real64 ) :: rst !! The requested parameter. if ( i == 2 . and . j == 1 ) then rst = 0.5d0 else if ( i == 3 . and . j == 2 ) then rst = 0.5d0 else if ( i == 4 . and . j == 3 ) then rst = 1.0d0 else rst = 0.0d0 end if end function ! ------------------------------------------------------------------------------ pure function rk4_get_b_param ( this , i ) result ( rst ) !! Gets the requested quadrature weight from the Butcher tableau. class ( rk4_fixed_integrator ), intent ( in ) :: this !! The rk4_fixed_integrator object. integer ( int32 ), intent ( in ) :: i !! The index of the parameter from the Butcher tableau. real ( real64 ) :: rst !! The requested parameter. real ( real64 ), parameter :: sixth = 1.0d0 / 6.0d0 real ( real64 ), parameter :: third = 1.0d0 / 3.0d0 select case ( i ) case ( 1 ) rst = sixth case ( 2 ) rst = third case ( 3 ) rst = third case ( 4 ) rst = sixth case default rst = 0.0d0 end select end function ! ------------------------------------------------------------------------------ pure function rk4_get_c_param ( this , i ) result ( rst ) !! Gets the requested position factor from the Butcher tableau. class ( rk4_fixed_integrator ), intent ( in ) :: this !! The rk4_fixed_integrator object. integer ( int32 ), intent ( in ) :: i !! The index of the parameter from the Butcher tableau. real ( real64 ) :: rst !! The requested parameter. select case ( i ) case ( 2 ) rst = 0.5d0 case ( 3 ) rst = 0.5d0 case default rst = 0.0d0 end select end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_rk4.f90.html"},{"title":"diffeq_rk_fixed_step.f90 – DIFFEQ","text":"Contents Modules diffeq_rk_fixed_step Source Code diffeq_rk_fixed_step.f90 Source Code module diffeq_rk_fixed_step !! This module contains the structure for fixed-step Runge-Kutta !! integrators. use iso_fortran_env use diffeq_errors use diffeq_base use diffeq_fixed_step implicit none private public :: rk_fixed_integrator public :: rkf_get_array_parameter public :: rkf_get_matrix_parameter type , abstract , extends ( fixed_step_integrator ) :: rk_fixed_integrator !! Defines an explicit, Runge-Kutta fixed-step integrator. real ( real64 ), private , allocatable , dimension (:,:) :: m_work ! Workspace matrix. contains ! Use to allocate internal workspaces.  This routine only takes action ! if the workspace array(s) are not sized properly for the application. procedure , private :: allocate_workspace => rkf_alloc_workspace procedure , public :: step => rkf_step !! Takes a single Runge-Kutta integration step. procedure ( rkf_get_matrix_parameter ), deferred , public :: & get_method_factor !! Gets the requested method factor from the Butcher tableau. procedure ( rkf_get_array_parameter ), deferred , public :: & get_quadrature_weight !! Gets the requested quadrature weight from the Butcher tableau. procedure ( rkf_get_array_parameter ), deferred , public :: & get_position_factor !! Gets the requested position factor from the Butcher tableau. end type interface pure function rkf_get_matrix_parameter ( this , i , j ) result ( rst ) !! Retrieves a parameter from a matrix stored by the !! rk_fixed_integrator object. use iso_fortran_env import rk_fixed_integrator class ( rk_fixed_integrator ), intent ( in ) :: this !! The rk_fixed_integrator object. integer ( int32 ), intent ( in ) :: i !! The row index of the matrix parameter to retrieve. integer ( int32 ), intent ( in ) :: j !! The column index of the matrix parameter to retrieve. real ( real64 ) :: rst !! The requested parameter. end function pure function rkf_get_array_parameter ( this , i ) result ( rst ) !! Retrieves a parameter from an array stored by the !! rk_fixed_integrator object. use iso_fortran_env import rk_fixed_integrator class ( rk_fixed_integrator ), intent ( in ) :: this !! The rk_fixed_integrator object. integer ( int32 ), intent ( in ) :: i !! The index of the array parameter to retrieve. real ( real64 ) :: rst !! The requested parameter end function end interface contains ! ------------------------------------------------------------------------------ ! n = method order ! neqn = # of ODE's to solve subroutine rkf_alloc_workspace ( this , n , neqn , err ) ! Arguments class ( rk_fixed_integrator ), intent ( inout ) :: this integer ( int32 ), intent ( in ) :: n , neqn class ( errors ), intent ( inout ) :: err ! Local Variables integer ( int32 ) :: flag , mw , nw ! Process mw = neqn nw = n + 1 ! +1 for 1 additional NEQN-element workspace array if ( allocated ( this % m_work )) then if ( size ( this % m_work , 1 ) /= mw . or . size ( this % m_work , 2 ) /= nw ) then deallocate ( this % m_work ) allocate ( this % m_work ( mw , nw ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_work ( mw , nw ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory Error Handling 10 continue call report_memory_error ( err , \"rkf_alloc_workspace\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ subroutine rkf_step ( this , sys , h , x , y , yn , xprev , yprev , fprev , err ) !! Takes a single Runge-Kutta integration step. class ( rk_fixed_integrator ), intent ( inout ) :: this !! The rk_fixed_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The size of the step to take. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent !! variables at x + h will be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible error and warning messages that !! may be encountered are as follows. !! !! - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if yn is not sized appropriately. ! Local Variables integer ( int32 ) :: i , j , n , neqn , m , n1 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( y ) n = this % get_order () n1 = n + 1 ! index of additional workspace array #1 ! Input Checking if ( size ( yn ) /= neqn ) then call report_array_size_error ( errmgr , \"rkf_step\" , \"yn\" , neqn , size ( yn )) return end if ! Allocate the workspace call this % allocate_workspace ( n , neqn , errmgr ) if ( errmgr % has_error_occurred ()) return ! As this is an explicit routine, the Butcher tableau is lower triangular. call sys % ode ( x , y , this % m_work (:, 1 )) do i = 2 , n this % m_work (:, n1 ) = 0.0d0 do j = 1 , i - 1 ! only reference the sub-diagonal components this % m_work (:, n1 ) = this % m_work (:, n1 ) + & this % get_method_factor ( i , j ) * this % m_work (:, j ) end do call sys % ode ( & x + h * this % get_position_factor ( i ), & y + h * this % m_work (:, n1 ), & this % m_work (:, i ) & ! output ) end do ! Compute the next solution estimate do i = 1 , n if ( i == 1 ) then this % m_work (:, n1 ) = this % get_quadrature_weight ( i ) * this % m_work (:, i ) else this % m_work (:, n1 ) = this % m_work (:, n1 ) + & this % get_quadrature_weight ( i ) * this % m_work (:, i ) end if end do yn = y + h * this % m_work (:, n1 ) ! End return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_rk_fixed_step.f90.html"},{"title":"diffeq_runge_kutta.f90 – DIFFEQ","text":"Contents Modules diffeq_runge_kutta Source Code diffeq_runge_kutta.f90 Source Code module diffeq_runge_kutta use iso_fortran_env use diffeq_variable_singlestep use diffeq_errors use diffeq_base implicit none private public :: pi_controller public :: rkv_get_matrix_parameter public :: rkv_get_array_parameter public :: rkv_get_boolean_parameter public :: rkv_get_integer_parameter public :: rkv_action public :: rkv_set_up_interp public :: rk_variable_integrator public :: dprk45_integrator public :: bsrk32_integrator !> @brief Defines a variable-step, Runge-Kutta integrator. type , abstract , extends ( variable_singlestep_integrator ) :: & rk_variable_integrator ! Workspace matrix (NEQN -by- STAGE COUNT) real ( real64 ), public , allocatable , dimension (:,:) :: f !! An NEQN-by-NSTAGE matrix containing the function evaluations !! (derivatives) at each of the stages of evaluation. real ( real64 ), private , allocatable , dimension (:) :: m_ywork ! Workspace array (NEQN) logical , private :: m_firstStep = . true . ! A flag determining if this is the first accepted step (use for FSAL) real ( real64 ), private :: m_alpha = 0.7d0 ! Step-size PI control parameters real ( real64 ), private :: m_beta = 0.4d-1 ! Step-size PI control parameters real ( real64 ), public , allocatable , dimension (:,:) :: a !! The NSTAGE-by-NSTAGE method factor matrix A. real ( real64 ), public , allocatable , dimension (:) :: b !! The NSTAGE-element quadrature weight array B. real ( real64 ), public , allocatable , dimension (:) :: c !! The NSTAGE-element position factor array C. real ( real64 ), public , allocatable , dimension (:) :: e !! The NSTAGE-element error estimate factor array E. contains procedure , public :: initialize => rkv_alloc_workspace !! Initializes the integrator. procedure ( rkv_get_boolean_parameter ), deferred , public :: is_fsal !! Gets a value determining if this is a FSAL (first, same as last) !! integrator. procedure ( rkv_get_integer_parameter ), deferred , public :: & get_stage_count !! Gets the number of stages used by the integrator. procedure ( rkv_action ), deferred , public :: define_model !! Defines (initializes) the model parameters. procedure , public :: reset => rkv_reset !! Resets the integrator to its initial state. procedure , public :: attempt_step => rkv_attempt_step !! Attempts a single integration step. procedure , public :: on_successful_step => rkv_on_successful_step !! Perform necessary actions on completion of a successful step. procedure ( rkv_set_up_interp ), public , deferred :: set_up_interpolation !! Sets up the interpolation polynomial. procedure , public :: get_alpha => rkv_get_alpha !! Gets the  \\alpha  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. procedure , public :: set_alpha => rkv_set_alpha !! Sets the  \\alpha  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. procedure , public :: get_beta => rkv_get_beta !! Gets the  \\beta  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. procedure , public :: set_beta => rkv_set_beta !! Sets the  \\beta  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. procedure , public :: compute_next_step_size => rkv_next_step !! Computes the next step size. procedure , public :: get_is_first_step => rkv_get_is_first_step !! Gets a value determining if the integrator is set up to take its !! first integration step. procedure , public :: set_is_first_step => rkv_set_is_first_step !! Sets a value determining if the integrator is set up to take its !! first integration step. end type interface pure function rkv_get_matrix_parameter ( this , i , j ) result ( rst ) use iso_fortran_env import rk_variable_integrator class ( rk_variable_integrator ), intent ( in ) :: this integer ( int32 ), intent ( in ) :: i , j real ( real64 ) :: rst end function pure function rkv_get_array_parameter ( this , i ) result ( rst ) use iso_fortran_env import rk_variable_integrator class ( rk_variable_integrator ), intent ( in ) :: this integer ( int32 ), intent ( in ) :: i real ( real64 ) :: rst end function pure function rkv_get_boolean_parameter ( this ) result ( rst ) import rk_variable_integrator class ( rk_variable_integrator ), intent ( in ) :: this logical :: rst end function pure function rkv_get_integer_parameter ( this ) result ( rst ) use iso_fortran_env import rk_variable_integrator class ( rk_variable_integrator ), intent ( in ) :: this integer ( int32 ) :: rst end function subroutine rkv_action ( this ) !! Defines an action to undertake on a rk_variable_integrator !! object. import rk_variable_integrator class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. end subroutine subroutine rkv_set_up_interp ( this , x , xn , y , yn , k ) !! Sets up interpolation for the rk_variable_integrator object. use iso_fortran_env import rk_variable_integrator class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The value of the independent variable at x + h. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the values of the dependent !! variables at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the values of the dependent !! variables at x + h. real ( real64 ), intent ( in ), dimension (:,:) :: k end subroutine end interface ! ------------------------------------------------------------------------------ type , extends ( rk_variable_integrator ) :: dprk45_integrator !! Defines the classical Dormand-Prince 4th/5th order integrator. logical , private :: m_modelDefined = . false . real ( real64 ), private , allocatable , dimension (:,:) :: m_dprk45work contains procedure , public :: define_model => dprk45_define_model !! Defines (initializes) the model parameters. procedure , public :: is_fsal => dprk45_is_fsal !! Determines if the integrator is an FSAL (first same as last) !! integrator (e.g. the 4th/5th order Dormand-Prince integrator). procedure , public :: get_stage_count => dprk45_get_stage_count !! Gets the number of stages used by the integrator. procedure , public :: get_order => dprk45_get_order !! Returns the order of the integrator. procedure , public :: interpolate => dprk45_interp !! Provides interpolation between integration points allowing !! for dense output. procedure , public :: set_up_interpolation => dprk45_set_up_interp !! Sets up the interpolation polynomial. end type ! ------------------------------------------------------------------------------ type , extends ( rk_variable_integrator ) :: bsrk32_integrator !! Defines the Bogacki-Shampine 3rd/2nd order integrator. logical , private :: m_modelDefined = . false . real ( real64 ), private , allocatable , dimension (:,:) :: m_bsrk23work contains procedure , public :: define_model => bsrk32_define_model !! Defines (initializes) the model parameters. procedure , public :: is_fsal => bsrk32_is_fsal !! Determines if the integrator is an FSAL (first same as last) !! integrator. procedure , public :: get_stage_count => bsrk32_get_stage_count !! Gets the number of stages used by the integrator. procedure , public :: get_order => bsrk32_get_order !! Returns the order of the integrator. procedure , public :: interpolate => bsrk32_interp !! Provides interpolation between integration points allowing for !! dense output. procedure , public :: set_up_interpolation => bsrk32_set_up_interp !! Sets up the interpolation polynomial. end type contains ! ------------------------------------------------------------------------------ pure function pi_controller ( alpha , beta , order , hn , en , enm1 , fs , maxstep ) & result ( rst ) !! Computes the next step size using a PI type controller such that !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} e_n&#94;{\\alpha} !! e_{n-1}&#94;{\\beta}  where  f  is the safety factor and  k  !! is the order of the integration method. real ( real64 ), intent ( in ) :: alpha !! The  \\alpha  control parameter. real ( real64 ), intent ( in ) :: beta !! The  \\beta  control parameter. integer ( int32 ), intent ( in ) :: order !! The order of the integrator. real ( real64 ), intent ( in ) :: hn !! The current step size. real ( real64 ), intent ( in ) :: en !! The norm of the error for the current step size. real ( real64 ), intent ( in ) :: enm1 !! The norm of the error from the previous step size. real ( real64 ), intent ( in ) :: fs !! A safety factor to place on the growth of the step size. real ( real64 ), intent ( in ) :: maxstep !! A cap on the size of the maximum step. real ( real64 ) :: rst !! The new step size. ! Local Variables real ( real64 ) :: hest ! Process hest = fs * hn * ( 1.0d0 / en ) ** ( 1.0d0 / order ) rst = hest * ( en ** alpha ) * ( enm1 ** beta ) if ( abs ( rst ) > maxstep ) rst = sign ( maxstep , rst ) if ( rst / hn > 2.0d0 ) rst = 2.0d0 * hn end function ! ****************************************************************************** ! ABSTRACT VARIABLE-STEP RUNGE-KUTTA ! ------------------------------------------------------------------------------ subroutine rkv_alloc_workspace ( this , neqn , err ) !! Initializes the integrator. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !!  can be used to retrieve information relating to any errors !!  encountered during execution. If not provided, a default !!  implementation of the errors class is used internally to provide !!  error handling.  Possible errors and warning messages that may be !!  encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. ! Local Variables integer ( int32 ) :: m , n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Process m = neqn n = this % get_stage_count () if ( allocated ( this % f )) then if ( size ( this % f , 1 ) /= m . or . size ( this % f , 2 ) /= n ) then deallocate ( this % f ) allocate ( this % f ( m , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % f ( m , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_ywork )) then if ( size ( this % m_ywork ) /= neqn ) then deallocate ( this % m_ywork ) allocate ( this % m_ywork ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_ywork ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % a )) then if ( size ( this % a , 1 ) /= n . or . size ( this % a , 2 ) /= n ) then deallocate ( this % a ) allocate ( this % a ( n , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % a ( n , n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % b )) then if ( size ( this % b ) /= n ) then deallocate ( this % b ) allocate ( this % b ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % b ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % c )) then if ( size ( this % c ) /= n ) then deallocate ( this % c ) allocate ( this % c ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % c ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % e )) then if ( size ( this % e ) /= n ) then deallocate ( this % e ) allocate ( this % e ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % e ( n ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! Define the model parameters call this % define_model () ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"rkv_alloc_workspace\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ subroutine rkv_reset ( this ) !! Resets the integrator to its initial state. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. call this % set_is_first_step (. true .) end subroutine ! ------------------------------------------------------------------------------ subroutine rkv_attempt_step ( this , sys , h , x , y , yn , en , xprev , yprev , & fprev , err ) !! Attempts a single integration step. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the dependent !! variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent variables at !! x + h will be written. real ( real64 ), intent ( out ), dimension (:) :: en !! An N-element array where the values of the error estimates wil !! be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !!  can be used to retrieve information relating to any errors !!  encountered during execution. If not provided, a default !!  implementation of the errors class is used internally to provide !!  error handling. ! Local Variables integer ( int32 ) :: i , j , n , neqn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = this % get_stage_count () neqn = size ( y ) ! Ensure the workspace is allocated if (. not . allocated ( this % f ) . or . . not . allocated ( this % m_ywork )) then call this % initialize ( neqn , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! The Butcher tableau is lower triangular as this is an explicit integrator if (. not . this % is_fsal () . or . this % get_is_first_step ()) then ! On FSAL integrators, we only need to make this call on the first step ! as the integrator uses the last evaluation from the previous step ! as this step.  On non-FSAL integrators we always need to compute an ! updated first step. call sys % ode ( x , y , this % f (:, 1 )) end if do i = 2 , n this % m_ywork = 0.0d0 do j = 1 , i - 1 ! only reference the sub-diagonal components this % m_ywork = this % m_ywork + this % a ( i , j ) * & this % f (:, j ) end do call sys % ode ( & x + h * this % c ( i ), & y + h * this % m_ywork , & this % f (:, i ) & ! output ) end do ! Compute the two solution estimates, and the resulting error estimate do i = 1 , n if ( i == 1 ) then this % m_ywork = this % b ( i ) * this % f (:, i ) else this % m_ywork = this % m_ywork + this % b ( i ) * & this % f (:, i ) end if end do yn = y + h * this % m_ywork do i = 1 , n if ( i == 1 ) then this % m_ywork = this % e ( i ) * this % f (:, i ) else this % m_ywork = this % m_ywork + this % e ( i ) * & this % f (:, i ) end if end do en = h * this % m_ywork end subroutine ! ------------------------------------------------------------------------------ subroutine rkv_on_successful_step ( this , x , xn , y , yn ) !! Perform necessary actions on completion of a successful step. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The value of the independent variable at the next step. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution values. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution values at the next step. ! Local Variables integer ( int32 ) :: n ! Set up the interpolation polynomial - TO DO check for dense output first call this % set_up_interpolation ( x , xn , y , yn , this % f ) ! Store the last result as the first, if this is FSAL if ( this % is_fsal ()) then call this % set_is_first_step (. false .) n = this % get_stage_count () this % f (:, 1 ) = this % f (:, n ) end if end subroutine ! ------------------------------------------------------------------------------ pure function rkv_get_alpha ( this ) result ( rst ) !! Gets the  \\alpha  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. class ( rk_variable_integrator ), intent ( in ) :: this !! The rk_variable_integrator object. real ( real64 ) :: rst !! The parameter. rst = this % m_alpha end function ! -------------------- subroutine rkv_set_alpha ( this , x ) !! Sets the  \\alpha  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. real ( real64 ) :: x !! The parameter. this % m_alpha = x end subroutine ! ------------------------------------------------------------------------------ pure function rkv_get_beta ( this ) result ( rst ) !! Gets the  \\beta  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. class ( rk_variable_integrator ), intent ( in ) :: this !! The rk_variable_integrator object. real ( real64 ) :: rst !! The parameter. rst = this % m_beta end function ! -------------------- subroutine rkv_set_beta ( this , x ) !! Sets the  \\beta  control parameter in the PI controller !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} !! e_n&#94;{\\alpha} e_{n-1}&#94;{\\beta}, where  f  is a safety !! factor, and \\f$ k  is the order of the integration method. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. real ( real64 ), intent ( in ) :: x !! The parameter. this % m_beta = x end subroutine ! ------------------------------------------------------------------------------ function rkv_next_step ( this , hn , en , enm1 ) result ( rst ) !! Computes the next step size using a PI type controller such that !!  h_{n+1} = f h_n \\left( \\frac{1}{e_n} \\right)&#94;{1/k} e_n&#94;{\\alpha} !! e_{n-1}&#94;{\\beta}  where  f  is the safety factor and  k  !! is the order of the integration method. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. real ( real64 ), intent ( in ) :: hn !! The current step size. real ( real64 ), intent ( in ) :: en !! The norm of the error for the current step size. real ( real64 ), intent ( in ) :: enm1 !! The norm of the error from the previous step size. real ( real64 ) :: rst !! The new step size. ! Process rst = pi_controller ( this % get_alpha (), this % get_beta (), this % get_order (), & hn , en , enm1 , this % get_safety_factor (), this % get_max_step_size ()) end function ! ------------------------------------------------------------------------------ pure function rkv_get_is_first_step ( this ) result ( rst ) !! Gets a value determining if the integrator is set up to take its first !! integration step. class ( rk_variable_integrator ), intent ( in ) :: this !! The rk_variable_integrator object. logical :: rst !! True if the integrator is on its first step; else, false. rst = this % m_firstStep end function ! -------------------- subroutine rkv_set_is_first_step ( this , x ) !! Sets a value determining if the integrator is set up to take its first !! integration step. class ( rk_variable_integrator ), intent ( inout ) :: this !! The rk_variable_integrator object. logical :: x !! True if the integrator is on its first step; else, false. this % m_firstStep = x end subroutine ! ****************************************************************************** ! DORMAND-PRINCE 4/5 INTEGRATOR ROUTINES ! ------------------------------------------------------------------------------ subroutine dprk45_define_model ( this ) use diffeq_dprk45_constants !! Defines (initializes) the model parameters. class ( dprk45_integrator ), intent ( inout ) :: this !! The dprk45_integrator object. ! Process if ( this % m_modelDefined ) return ! A this % a = 0.0d0 this % a ( 2 , 1 ) = a21 this % a ( 3 , 1 ) = a31 this % a ( 3 , 2 ) = a32 this % a ( 4 , 1 ) = a41 this % a ( 4 , 2 ) = a42 this % a ( 4 , 3 ) = a43 this % a ( 5 , 1 ) = a51 this % a ( 5 , 2 ) = a52 this % a ( 5 , 3 ) = a53 this % a ( 5 , 4 ) = a54 this % a ( 6 , 1 ) = a61 this % a ( 6 , 2 ) = a62 this % a ( 6 , 3 ) = a63 this % a ( 6 , 4 ) = a64 this % a ( 6 , 5 ) = a65 this % a ( 7 , 1 ) = a71 this % a ( 7 , 2 ) = a72 this % a ( 7 , 3 ) = a73 this % a ( 7 , 4 ) = a74 this % a ( 7 , 5 ) = a75 this % a ( 7 , 6 ) = a76 ! B this % b ( 1 ) = a71 this % b ( 2 ) = a72 this % b ( 3 ) = a73 this % b ( 4 ) = a74 this % b ( 5 ) = a75 this % b ( 6 ) = a76 this % b ( 7 ) = 0.0d0 ! C this % c ( 1 ) = 0.0d0 this % c ( 2 ) = c2 this % c ( 3 ) = c3 this % c ( 4 ) = c4 this % c ( 5 ) = c5 this % c ( 6 ) = c6 this % c ( 7 ) = c7 ! E this % e ( 1 ) = e1 this % e ( 2 ) = e2 this % e ( 3 ) = e3 this % e ( 4 ) = e4 this % e ( 5 ) = e5 this % e ( 6 ) = e6 this % e ( 7 ) = e7 ! Update definition status this % m_modelDefined = . true . end subroutine ! ------------------------------------------------------------------------------ pure function dprk45_is_fsal ( this ) result ( rst ) !! Determines if the integrator is an FSAL (first same as last) !! integrator. class ( dprk45_integrator ), intent ( in ) :: this !! The dprk45_integrator object. logical :: rst !! Returns true, as this integrator is a FSAL integrator. rst = . true . end function ! ------------------------------------------------------------------------------ pure function dprk45_get_stage_count ( this ) result ( rst ) !! Gets the number of stages used by the integrator. class ( dprk45_integrator ), intent ( in ) :: this !! The dprk45_integrator object. integer ( int32 ) :: rst !! Returns the number of stages, 7 for this integrator. rst = 7 end function ! ------------------------------------------------------------------------------ pure function dprk45_get_order ( this ) result ( rst ) !! Returns the order of the integrator. class ( dprk45_integrator ), intent ( in ) :: this !! The dprk45_integrator object. integer ( int32 ) :: rst !! Returns the order of the integrator, 5 for this integrator. rst = 5 end function ! ------------------------------------------------------------------------------ subroutine dprk45_set_up_interp ( this , x , xn , y , yn , k ) use diffeq_dprk45_constants !! Sets up the interpolation polynomial. class ( dprk45_integrator ), intent ( inout ) :: this !! The dprk45_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The value of the independent variable at the next step. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution !! values. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution values at !! the next step. real ( real64 ), intent ( in ), dimension (:,:) :: k !! An N-by-M matrix containing the intermediate step function outputs !! where M is the number of stages of the integrator. ! Parameters integer ( int32 ), parameter :: n = 5 ! Local Variables integer ( int32 ) :: i , neqn real ( real64 ) :: h , ydiff , bspl ! Intialization neqn = size ( y ) h = this % get_step_size () ! Memory Allocation if ( allocated ( this % m_dprk45work )) then if ( size ( this % m_dprk45work , 1 ) /= neqn . or . & size ( this % m_dprk45work , 2 ) /= n ) & then deallocate ( this % m_dprk45work ) allocate ( this % m_dprk45work ( neqn , n )) end if else allocate ( this % m_dprk45work ( neqn , n )) end if ! Construct the coefficient arrays do i = 1 , neqn ydiff = yn ( i ) - y ( i ) bspl = h * k ( i , 1 ) - ydiff this % m_dprk45work ( i , 1 ) = y ( i ) this % m_dprk45work ( i , 2 ) = ydiff this % m_dprk45work ( i , 3 ) = bspl this % m_dprk45work ( i , 4 ) = ydiff - h * k ( i , 7 ) - bspl this % m_dprk45work ( i , 5 ) = h * ( d1 * k ( i , 1 ) + d3 * k ( i , 3 ) + & d4 * k ( i , 4 ) + d5 * k ( i , 5 ) + d6 * k ( i , 6 ) + d7 * k ( i , 7 )) end do end subroutine ! ------------------------------------------------------------------------------ subroutine dprk45_interp ( this , xprev , yprev , xnew , x , y , err ) !! Provides interpolation between integration points allowing for dense !! output. class ( dprk45_integrator ), intent ( in ) :: this !! The dprk45_integrator object. real ( real64 ), intent ( in ) :: xprev !! The previous value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yprev !! An N-element array containing the values of the dependent variables !! at xprev. real ( real64 ), intent ( in ) :: xnew !! The updated value of the independent variable. real ( real64 ), intent ( in ) :: x !! The value at which to perform the interpolation. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array containing the interpolated values for each !! equation. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. ! Local Variables integer ( int32 ) :: i , neqn real ( real64 ) :: h , s , s1 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( this % m_dprk45work , 1 ) h = xnew - xprev s = ( x - xprev ) / h s1 = 1.0d0 - s ! Input Check if ( size ( y ) /= neqn ) then call report_array_size_error ( errmgr , \"dprk45_interp\" , \"y\" , neqn , & size ( y )) return end if ! Process y = this % m_dprk45work (:, 1 ) + s * ( & this % m_dprk45work (:, 2 ) + s1 * ( & this % m_dprk45work (:, 3 ) + s * ( & this % m_dprk45work (:, 4 ) + s1 * this % m_dprk45work (:, 5 ) & ))) ! End return end subroutine ! ****************************************************************************** ! BOGACKI-SHAMPINE 3/2 INTEGRATOR ROUTINES ! ------------------------------------------------------------------------------ subroutine bsrk32_define_model ( this ) use diffeq_bsrk32_constants !! Defines (initializes) the model parameters. class ( bsrk32_integrator ), intent ( inout ) :: this !! The bsrk32_integrator object. ! Process if ( this % m_modelDefined ) return ! A this % a = 0.0d0 this % a ( 2 , 1 ) = a21 this % a ( 3 , 1 ) = a31 this % a ( 3 , 2 ) = a32 this % a ( 4 , 1 ) = a41 this % a ( 4 , 2 ) = a42 this % a ( 4 , 3 ) = a43 ! B this % b ( 1 ) = b1 this % b ( 2 ) = b2 this % b ( 3 ) = b3 this % b ( 4 ) = b4 ! C this % c ( 1 ) = c1 this % c ( 2 ) = c2 this % c ( 3 ) = c3 this % c ( 4 ) = c4 ! E this % e ( 1 ) = b1a - b1 this % e ( 2 ) = b2a - b2 this % e ( 3 ) = b3a - b3 this % e ( 4 ) = b4a - b4 end subroutine ! ------------------------------------------------------------------------------ pure function bsrk32_is_fsal ( this ) result ( rst ) !! Determines if the integrator is an FSAL (first same as last) !! integrator. class ( bsrk32_integrator ), intent ( in ) :: this !! The bsrk32_integrator object. logical :: rst !! Returns true, as this integrator is a FSAL integrator. rst = . true . end function ! ------------------------------------------------------------------------------ pure function bsrk32_get_stage_count ( this ) result ( rst ) !! Gets the number of stages used by the integrator. class ( bsrk32_integrator ), intent ( in ) :: this !! The bsrk32_integrator object. integer ( int32 ) :: rst !! Returns the number of stages, 4 for this integrator. rst = 4 end function ! ------------------------------------------------------------------------------ pure function bsrk32_get_order ( this ) result ( rst ) !! Returns the order of the integrator. class ( bsrk32_integrator ), intent ( in ) :: this !! The bsrk32_integrator object. integer ( int32 ) :: rst !! Returns the order of the integrator, 3 for this integrator. rst = 3 end function ! ------------------------------------------------------------------------------ subroutine bsrk32_set_up_interp ( this , x , xn , y , yn , k ) !! Sets up the interpolation polynomial. class ( bsrk32_integrator ), intent ( inout ) :: this !! The bsrk32_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The value of the independent variable at the next step. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution !! values. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution values at !! the next step. real ( real64 ), intent ( in ), dimension (:,:) :: k !! An N-by-M matrix containing the intermediate step function outputs !! where M is the number of stages of the integrator. ! Parameters integer ( int32 ), parameter :: n = 3 ! Local Variables integer ( int32 ) :: i , neqn real ( real64 ) :: h ! Initialization neqn = size ( y ) h = this % get_step_size () ! Memory ALlocation if ( allocated ( this % m_bsrk23work )) then if ( size ( this % m_bsrk23work , 1 ) /= neqn . or . & size ( this % m_bsrk23work , 2 ) /= n ) & then deallocate ( this % m_bsrk23work ) allocate ( this % m_bsrk23work ( neqn , n )) end if else allocate ( this % m_bsrk23work ( neqn , n )) end if ! Construct the coefficient arrays this % m_bsrk23work (:, 1 ) = - ( y - yn + k (:, 1 ) * h ) / h ** 2 this % m_bsrk23work (:, 2 ) = k (:, 1 ) - 2.0d0 * x * this % m_bsrk23work (:, 1 ) this % m_bsrk23work (:, 3 ) = y - this % m_bsrk23work (:, 1 ) * x ** 2 - & this % m_bsrk23work (:, 2 ) * x end subroutine ! ------------------------------------------------------------------------------ subroutine bsrk32_interp ( this , xprev , yprev , xnew , x , y , err ) !! Provides interpolation between integration points allowing for dense !! output. class ( bsrk32_integrator ), intent ( in ) :: this !! The bsrk32_integrator object. real ( real64 ), intent ( in ) :: xprev !! The previous value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yprev !! An N-element array containing the values of the dependent variables !! at xprev. real ( real64 ), intent ( in ) :: xnew !! The updated value of the independent variable. real ( real64 ), intent ( in ) :: x !! The value at which to perform the interpolation. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array containing the interpolated values for each !! equation. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. ! Local Variables integer ( int32 ) :: neqn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( this % m_bsrk23work , 1 ) ! Input Check if ( size ( y ) /= neqn ) then call report_array_size_error ( errmgr , \"bsrk32_interp\" , \"y\" , neqn , & size ( y )) return end if ! Process y = this % m_bsrk23work (:, 1 ) * x ** 2 + this % m_bsrk23work (:, 2 ) * x + & this % m_bsrk23work (:, 3 ) ! End return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_runge_kutta.f90.html"},{"title":"diffeq_sdirk4_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_sdirk4_constants Source Code diffeq_sdirk4_constants.f90 Source Code module diffeq_sdirk4_constants use iso_fortran_env implicit none ! Model Parameters (ESDIRK4(3)6L[2]SA, Table 16, pg 90) ! https://ntrs.nasa.gov/api/citations/20160005923/downloads/20160005923.pdf real ( real64 ), parameter :: gamma = 0.25d0 real ( real64 ), parameter :: c2 = 0.5d0 real ( real64 ), parameter :: c3 = ( 2.0d0 - sqrt ( 2.0d0 )) / 4.0d0 real ( real64 ), parameter :: c4 = 5.0d0 / 8.0d0 real ( real64 ), parameter :: c5 = 2 6.0d0 / 2 5.0d0 real ( real64 ), parameter :: c6 = 1.0d0 real ( real64 ), parameter :: a21 = gamma real ( real64 ), parameter :: a22 = gamma real ( real64 ), parameter :: a32 = ( 1.0d0 - sqrt ( 2.0d0 )) / 8.0d0 real ( real64 ), parameter :: a31 = ( c3 - a32 - gamma ) real ( real64 ), parameter :: a33 = gamma real ( real64 ), parameter :: a43 = 7.0d0 * ( 1.0d0 + sqrt ( 2.0d0 )) / 3 2.0d0 real ( real64 ), parameter :: a42 = ( 5.0d0 - 7.0d0 * sqrt ( 2.0d0 )) / 6 4.0d0 real ( real64 ), parameter :: a41 = c4 - a42 - a43 - gamma real ( real64 ), parameter :: a44 = gamma real ( real64 ), parameter :: a54 = & 16 6.0d0 * ( - 9 7.0d0 + 37 6.0d0 * sqrt ( 2.0d0 )) / 1.09375d5 real ( real64 ), parameter :: a53 = & ( 5.06605d5 + 1.32109d5 * sqrt ( 2.0d0 )) / 4.375d5 real ( real64 ), parameter :: a52 = & ( - 1.3796d4 - 5.4539d4 * sqrt ( 2.0d0 )) / 1.25d5 real ( real64 ), parameter :: a51 = c5 - a52 - a53 - a54 - gamma real ( real64 ), parameter :: a55 = gamma real ( real64 ), parameter :: b5 = & - 1 5.625d3 * ( 9 7.0d0 + 37 6.0d0 * sqrt ( 2.0d0 )) / 9.0749876d7 real ( real64 ), parameter :: b4 = & - 1 6.0d0 * ( - 2.2922d4 + 3.525d3 * sqrt ( 2.0d0 )) / 5.71953d5 real ( real64 ), parameter :: b3 = & 4 7.0d0 * ( - 26 7.0d0 + 1.783d3 * sqrt ( 2.0d0 )) / 2.73343d5 real ( real64 ), parameter :: b2 = ( 1.181d3 - 9.87d2 * sqrt ( 2.0d0 )) / 1.3782d4 real ( real64 ), parameter :: b1 = 1.0d0 - b2 - b3 - b4 - b5 - gamma real ( real64 ), parameter :: b6 = gamma real ( real64 ), parameter :: b2a = - 4.80923228411d11 / 4.982971448372d12 real ( real64 ), parameter :: b3a = 6.709447293961d12 / 1.2833189095359d13 real ( real64 ), parameter :: b4a = 3.513175791894d12 / 6.748737351361d12 real ( real64 ), parameter :: b5a = - 4.98863281070d11 / 6.042575550617d12 real ( real64 ), parameter :: b6a = 2.077005547802d12 / 8.945017530137d12 real ( real64 ), parameter :: b1a = 1.0d0 - b2a - b3a - b4a - b5a - b6a ! Dense Output Coefficients real ( real64 ), parameter :: bs11 = 1196391038466 5.0d0 / 1248334543036 3.0d0 real ( real64 ), parameter :: bs12 = 1196391038466 5.0d0 / 1248334543036 3.0d0 real ( real64 ), parameter :: bs13 = - 2860326462 4.0d0 / 197016962998 1.0d0 real ( real64 ), parameter :: bs14 = - 352442544718 3.0d0 / 268317707020 5.0d0 real ( real64 ), parameter :: bs15 = - 1717352244018 6.0d0 / 1019502431706 1.0d0 real ( real64 ), parameter :: bs16 = 2730887916970 9.0d0 / 1303050001423 3.0d0 real ( real64 ), parameter :: bs21 = - 6999676033078 8.0d0 / 1852659955145 5.0d0 real ( real64 ), parameter :: bs22 = - 6999676033078 8.0d0 / 1852659955145 5.0d0 real ( real64 ), parameter :: bs23 = 10261017190510 3.0d0 / 2626665971795 3.0d0 real ( real64 ), parameter :: bs24 = 7495762390762 0.0d0 / 1227980509731 3.0d0 real ( real64 ), parameter :: bs25 = 11385319923563 3.0d0 / 998326632029 0.0d0 real ( real64 ), parameter :: bs26 = - 8422939254395 0.0d0 / 607774059939 9.0d0 real ( real64 ), parameter :: bs31 = 3247363542941 9.0d0 / 703070151066 5.0d0 real ( real64 ), parameter :: bs32 = 3247363542941 9.0d0 / 703070151066 5.0d0 real ( real64 ), parameter :: bs33 = - 3886631725384 1.0d0 / 624983582616 5.0d0 real ( real64 ), parameter :: bs34 = - 2670571722388 6.0d0 / 426567713333 7.0d0 real ( real64 ), parameter :: bs35 = - 12110538214315 5.0d0 / 665841266752 7.0d0 real ( real64 ), parameter :: bs36 = 110202854750382 4.0d0 / 5142447687075 5.0d0 real ( real64 ), parameter :: bs41 = - 1466852863862 3.0d0 / 808346430175 5.0d0 real ( real64 ), parameter :: bs42 = - 1466852863862 3.0d0 / 808346430175 5.0d0 real ( real64 ), parameter :: bs43 = 2110345588509 1.0d0 / 777442873095 2.0d0 real ( real64 ), parameter :: bs44 = 3015559147553 3.0d0 / 1529369594006 1.0d0 real ( real64 ), parameter :: bs45 = 11985337510208 8.0d0 / 1433624007999 1.0d0 real ( real64 ), parameter :: bs46 = - 6360221397322 4.0d0 / 675388042571 7.0d0 end module","tags":"","loc":"sourcefile\\diffeq_sdirk4_constants.f90.html"},{"title":"diffeq_variable_singlestep.f90 – DIFFEQ","text":"Contents Modules diffeq_variable_singlestep Source Code diffeq_variable_singlestep.f90 Source Code module diffeq_variable_singlestep use iso_fortran_env use diffeq_variable_step use diffeq_errors use diffeq_base implicit none private public :: variable_singlestep_integrator !> @brief Defines a variable-step, single-stage integrator. type , abstract , extends ( variable_step_integrator ) :: & variable_singlestep_integrator contains procedure , public :: solve => vssi_solve !! Solves the supplied system of ODEs. procedure , private :: solve_driver => vssi_solve_driver procedure , private :: dense_solve_driver => vssi_dense_solve_driver end type contains ! ------------------------------------------------------------------------------ function vssi_solve ( this , sys , x , iv , err ) result ( rst ) !! Solves the supplied system of ODEs. class ( variable_singlestep_integrator ), intent ( inout ) :: this !! The variable_singlestep_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array, of at least 2 values, defining at a minimum !! the starting and ending values of the independent variable !! integration range.  If more than two values are specified, the !! integration results will be returned at the supplied values. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p x has less than 2 elements. !! !!  - DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size becomes !!      too small. !! !!  - DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR: Occurs if the iteration !!      count is exceeded for a single step. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE routine is defined. !! !!  - DIFFEQ_INVALID_INPUT_ERROR: Occurs if max(x) - min(x) = 0. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-N matrix where M is the number of solution points, !! and N is the number of ODEs plus 1.  The first column contains !! the values of the independent variable at which the results were !! computed.  The remaining columns contain the integration results !! for each ODE. ! Local Variables integer ( int32 ) :: nx class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nx = size ( x ) ! Input Checking if ( nx < 2 ) then call report_min_array_size_not_met ( errmgr , \"vssi_solve\" , \"x\" , 2 , nx ) return end if if ( abs ( maxval ( x ) - minval ( x )) < epsilon ( 1.0d0 )) then call errmgr % report_error ( \"vssi_solve\" , \"MAX(X) - MIN(X) is zero.\" , & DIFFEQ_INVALID_INPUT_ERROR ) return end if if (. not . sys % get_is_ode_defined ()) then call report_missing_ode ( errmgr , \"vssi_solve\" ) return end if ! Process if ( nx == 2 ) then rst = this % solve_driver ( sys , x , iv , errmgr ) else rst = this % dense_solve_driver ( sys , x , iv , errmgr ) end if if ( errmgr % has_error_occurred ()) return ! End return end function ! ------------------------------------------------------------------------------ function vssi_solve_driver ( this , sys , x , iv , err ) result ( rst ) ! Arguments class ( variable_singlestep_integrator ), intent ( inout ) :: this class ( ode_container ), intent ( inout ) :: sys real ( real64 ), intent ( in ), dimension (:) :: x , iv class ( errors ), intent ( inout ) :: err real ( real64 ), allocatable , dimension (:,:) :: rst ! Parameters real ( real64 ), parameter :: sml = 1.0d2 * epsilon ( 1.0d0 ) ! Local Variables integer ( int32 ) :: i , neqn , flag , order real ( real64 ) :: xn , xmax real ( real64 ), allocatable , dimension (:) :: yn , yn1 ! Initialization xmax = x ( 2 ) xn = x ( 1 ) neqn = size ( iv ) order = this % get_order () ! Memory Allocation allocate ( yn ( neqn ), stat = flag , source = iv ) if ( flag == 0 ) allocate ( yn1 ( neqn ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( err , \"vssi_solve_driver\" , flag ) return end if ! Store the initial conditions call this % buffer_results ( x ( 1 ), iv , err ) if ( err % has_error_occurred ()) return ! Provide an initial step size estimate call sys % ode ( xn , iv , yn1 ) call this % set_next_step_size ( & this % estimate_first_step_size ( xn , xmax , iv , yn1 ) & ) ! Cycle until complete i = 0 do ! Take the step call this % step ( sys , xn , xmax , yn , yn1 , err = err ) if ( err % has_error_occurred ()) return ! Update xn and yn xn = xn + this % get_step_size () yn = yn1 ! Store the solution call this % buffer_results ( xn , yn , err ) if ( err % has_error_occurred ()) return ! Break if |XN| > |XMAX| if ( abs ( xn ) >= abs ( xmax ) . or . abs ( this % get_step_size ()) < sml ) exit ! Iteration Counter i = i + 1 if ( i > this % get_max_integration_step_count ()) then call report_excessive_integration_steps ( err , & \"vssi_solve_driver\" , i , xn ) return end if end do ! Output the results rst = this % get_buffer_contents () ! End return end function ! ------------------------------------------------------------------------------ function vssi_dense_solve_driver ( this , sys , x , iv , err ) result ( rst ) ! Arguments class ( variable_singlestep_integrator ), intent ( inout ) :: this class ( ode_container ), intent ( inout ) :: sys real ( real64 ), intent ( in ), dimension (:) :: x , iv class ( errors ), intent ( inout ) :: err real ( real64 ), allocatable , dimension (:,:) :: rst ! Parameters real ( real64 ), parameter :: sml = 1.0d2 * epsilon ( 1.0d0 ) ! Local Variables integer ( int32 ) :: i , j , npts , neqn , flag real ( real64 ) :: xn , xmax , xn1 , xi real ( real64 ), allocatable , dimension (:) :: yn , yn1 ! Initialization neqn = size ( iv ) npts = size ( x ) xn = x ( 1 ) xmax = x ( npts ) ! Memory Allocation allocate ( rst ( npts , neqn + 1 ), stat = flag ) if ( flag == 0 ) allocate ( yn ( neqn ), stat = flag , source = iv ) if ( flag == 0 ) allocate ( yn1 ( neqn ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( err , \"vssi_solve_driver\" , flag ) return end if ! Store the initial conditions rst ( 1 , 1 ) = x ( 1 ) rst ( 1 , 2 :) = iv ! Cycle until complete i = 0 j = 1 xi = x ( 2 ) outer : do ! Take a step call this % step ( sys , xn , xmax , yn , yn1 , err = err ) if ( err % has_error_occurred ()) return xn1 = xn + this % get_step_size () ! Interpolate as needed to achieve any intermediary solution points do while ( abs ( xi ) <= abs ( xn1 )) j = j + 1 call this % interpolate ( xn , yn , xn1 , xi , rst ( j , 2 :), err ) if ( err % has_error_occurred ()) return rst ( j , 1 ) = xi if ( j >= npts ) exit outer xi = x ( j + 1 ) end do ! Update xn and yn xn = xn1 yn = yn1 ! Break if |XN| > |XMAX| if ( abs ( xn ) >= abs ( xmax ) . or . abs ( this % get_step_size ()) < sml ) exit ! Iteration Counter i = i + 1 if ( i > max ( this % get_max_integration_step_count (), npts )) then call report_excessive_integration_steps ( err , & \"vssi_solve_driver\" , i , xn ) return end if end do outer ! End return end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_variable_singlestep.f90.html"},{"title":"diffeq_variable_step.f90 – DIFFEQ","text":"Contents Modules diffeq_variable_step Source Code diffeq_variable_step.f90 Source Code module diffeq_variable_step use iso_fortran_env use diffeq_base use diffeq_errors implicit none private public :: variable_step_integrator public :: variable_step_attempt public :: variable_step_action public :: variable_step_interpolation public :: next_step_size_calculator type , abstract , extends ( ode_integrator ) :: variable_step_integrator !! Defines a variable-step integrator. real ( real64 ), private :: m_safetyfactor = 0.9d0 real ( real64 ), private :: m_maxstep = huge ( 1.0d0 ) real ( real64 ), private :: m_minstep = 1.0d2 * epsilon ( 1.0d0 ) integer ( int32 ), private :: m_maxitercount = 1000 integer ( int32 ), private :: m_maxstepcount = 1000000 real ( real64 ), private :: m_stepSize = 1.0d0 real ( real64 ), private :: m_nextStep = 1.0d0 real ( real64 ), private :: m_enormPrev = 1.0d0 logical , private :: m_respectXMax = . true . ! Solution buffer real ( real64 ), private , allocatable , dimension (:,:) :: m_buffer integer ( int32 ) :: m_bufferCount = 0 ! Workspaces real ( real64 ), private , allocatable , dimension (:) :: m_ework ! NEQN element ! Tolerances real ( real64 ), private , allocatable , dimension (:) :: m_rtol ! NEQN element real ( real64 ), private , allocatable , dimension (:) :: m_atol ! NEQN element contains procedure , private :: initialize => vsi_alloc_workspace !! Initializes the integrator. procedure ( variable_step_attempt ), deferred , public :: attempt_step !! Attempts a single integration step. procedure ( variable_step_action ), deferred , public :: on_successful_step !! Perform necessary actions on completion of a successful step. procedure , public :: get_safety_factor => vsi_get_safety_factor !! Gets a safety factor used to limit the predicted step size. procedure , public :: set_safety_factor => vsi_set_safety_factor !! Sets a safety factor used to limit the predicted step size. procedure , public :: get_max_step_size => vsi_get_max_step !! Gets the maximum allowed step size. procedure , public :: set_max_step_size => vsi_set_max_step !! Sets the maximum allowed step size. procedure , public :: get_min_step_size => vsi_get_min_step !! Gets the minimum allowed step size. procedure , public :: set_min_step_size => vsi_set_min_step !! Sets the minimum allowed step size. procedure , public :: get_max_per_step_iteration_count => & vsi_get_max_iter_count !! Gets the maximum number of iterations per step allowed. procedure , public :: set_max_per_step_iteration_count => & vsi_set_max_iter_count !! Sets the maximum number of iterations per step allowed. procedure , public :: get_max_integration_step_count => & vsi_get_max_step_count !! Gets the maximum number of integration steps allowed. procedure , public :: set_max_integration_step_count => & vsi_set_max_step_count !! Sets the maximum number of integration steps allowed. procedure ( next_step_size_calculator ), deferred , public :: & compute_next_step_size !! Computes the next step size. procedure , public :: buffer_results => vsi_append_to_buffer !! Buffers a results set. procedure , public :: get_buffer_size => vsi_get_buffer_count !! Gets the number of entries into the solution buffer. procedure , public :: clear_buffer => vsi_clear_buffer !! Clears the results buffer. procedure , public :: get_step_size => vsi_get_step_size !! Gets the current step size. procedure , public :: set_step_size => vsi_set_step_size !! Sets the current step size. procedure , public :: get_next_step_size => vsi_get_next_step_size !! Gets the next step size. procedure , public :: set_next_step_size => vsi_set_next_step_size !! Sets the next step size. procedure , public :: get_respect_x_max => vsi_get_respect_xmax !! Gets a value determining if the integrator should respect a !! hard limit in the independent variable range.  If false, the !! integrator may step pass the limit. procedure , public :: set_respect_x_max => vsi_set_respect_xmax !! Sets a value determining if the integrator should respect a !! hard limit in the independent variable range.  If false, the !! integrator may step pass the limit. procedure , public :: step => vsi_step !! Takes one integration step. procedure , public :: estimate_first_step_size => vsi_estimate_first_step !! Computes an estimate to the first step size based upon the !! initial function values. procedure ( variable_step_interpolation ), public , deferred :: interpolate !! Provides interpolation between integration points. procedure , public :: get_default_relative_tolerance => & vsi_get_default_rel_tol !! Gets the default relative error tolerance. procedure , public :: get_default_absolute_tolerance => & vsi_get_default_abs_tol !! Gets the default absolute error tolerance. procedure , public :: get_buffer_contents => vsi_get_buffer_contents !! Returns the contents of the solution buffer. procedure , public :: get_previous_error_norm => vsi_get_prev_err_norm !! Gets the norm of the previous step's error estimate. procedure , public :: set_previous_error_norm => vsi_set_prev_err_norm !! Sets the norm of the previous step's error estimate. end type interface subroutine variable_step_attempt ( this , sys , h , x , y , yn , en , xprev , & yprev , fprev , err ) !! Defines a routine meant to attempt a single integration step. use iso_fortran_env use ferror import variable_step_integrator import ode_container class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the N !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent !! variables at x + h will be written. real ( real64 ), intent ( out ), dimension (:) :: en !! An N-element array where the error estimates for each !! equation will be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. end subroutine subroutine variable_step_action ( this , x , xn , y , yn ) !! Defines a routine for performing any actions upon completion of !! a successful step. use iso_fortran_env import variable_step_integrator class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The new value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the N !! dependent variables. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the new values of the N !! dependent variables. end subroutine subroutine variable_step_interpolation ( this , xprev , yprev , xnew , x , y , & err ) !! Defines a routine for providing interpolation services between !! integration points. use iso_fortran_env use ferror import variable_step_integrator class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: xprev !! The previoius value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yprev !! An N-element array containing the previous values of the !! N dependent variables. real ( real64 ), intent ( in ) :: xnew !! The new value of the independent variable. real ( real64 ), intent ( in ) :: x !! The value at which to perform the interpolation. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where the interpolated values will be !! written. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. end subroutine function next_step_size_calculator ( this , hn , en , enm1 ) result ( rst ) !! Defines a routine for computing the next step size to attempt. use iso_fortran_env import variable_step_integrator class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: hn !! The current step size. real ( real64 ), intent ( in ) :: en !! The norm of the error for the current step. real ( real64 ), intent ( in ) :: enm1 !! The norm of the error from the previous step. real ( real64 ) :: rst !! The next step size to try. end function end interface contains ! ------------------------------------------------------------------------------ pure function vsi_get_safety_factor ( this ) result ( rst ) !! Gets a safety factor used to limit the predicted step size. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The safety factor value. rst = this % m_safetyfactor end function ! -------------------- subroutine vsi_set_safety_factor ( this , x ) !! Sets a safety factor used to limit the predicted step size. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The safety factor value. this % m_safetyfactor = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_max_step ( this ) result ( rst ) !! Gets the maximum allowed step size. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The maximum step size. rst = this % m_maxstep end function ! -------------------- subroutine vsi_set_max_step ( this , x ) !! Sets the maximum step size. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The maximum step size. this % m_maxstep = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_min_step ( this ) result ( rst ) !! Gets the minimum allowed step size. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The minimum step size. rst = this % m_minstep end function ! -------------------- subroutine vsi_set_min_step ( this , x ) !! Sets the minimum allowed step size. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The minimum step size. this % m_minstep = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_max_iter_count ( this ) result ( rst ) !! Gets the maximum number of iterations per step allowed. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. integer ( int32 ) :: rst !! The maximum iteration count. rst = this % m_maxitercount end function ! -------------------- subroutine vsi_set_max_iter_count ( this , x ) !! Sets the maximum number of iterations per step allowed. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. integer ( int32 ), intent ( in ) :: x !! The maximum iteration count. this % m_maxitercount = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_max_step_count ( this ) result ( rst ) !! Gets the maximum number of integration steps allowed. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. integer ( int32 ) :: rst !! The maximum number of integration steps. rst = this % m_maxstepcount end function ! -------------------- subroutine vsi_set_max_step_count ( this , x ) !! Sets the maximum number of integration steps allowed. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. integer ( int32 ), intent ( in ) :: x !! The maximum number of integration steps. this % m_maxstepcount = x end subroutine ! ------------------------------------------------------------------------------ subroutine vsi_append_to_buffer ( this , x , y , err ) !! Buffers a results set. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The independent variable value. real ( real64 ), intent ( in ) :: y (:) !! An N-element array containing the solution values. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling.  Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if @p y is not compatible with !!      the buffer size. ! Parameters integer ( int32 ), parameter :: buffer = 1000 ! Local Variables integer ( int32 ) :: m , n , neqn , flag real ( real64 ), allocatable , dimension (:,:) :: copy class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( y ) n = neqn + 1 ! Ensure the buffer is allocated if (. not . allocated ( this % m_buffer )) then allocate ( this % m_buffer ( buffer , n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"vsi_append_to_buffer\" , flag ) return end if this % m_bufferCount = 0 end if ! Push a value onto the end of the buffer if ( size ( this % m_buffer , 2 ) /= n ) then call report_array_size_error ( errmgr , \"vsi_append_to_buffer\" , \"buffer\" , & n , size ( this % m_buffer , 2 )) return end if this % m_bufferCount = this % m_bufferCount + 1 m = size ( this % m_buffer , 1 ) if ( this % m_bufferCount > m ) then ! Reallocate the buffer allocate ( copy ( m , n ), stat = flag , source = this % m_buffer ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"vsi_append_to_buffer\" , flag ) return end if deallocate ( this % m_buffer ) allocate ( this % m_buffer ( m + buffer , n ), stat = flag ) this % m_buffer ( 1 : m ,:) = copy end if this % m_buffer ( this % m_bufferCount , 1 ) = x this % m_buffer ( this % m_bufferCount , 2 :) = y ! End return end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_buffer_count ( this ) result ( rst ) !! Gets the number of entries into the solution buffer. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. integer ( int32 ) :: rst !! The number of buffer entries. rst = this % m_bufferCount end function ! ------------------------------------------------------------------------------ subroutine vsi_clear_buffer ( this ) !! Clears the results buffer. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. if ( allocated ( this % m_buffer )) deallocate ( this % m_buffer ) this % m_bufferCount = 0 end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_step_size ( this ) result ( rst ) !! Gets the current step size. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The step size. rst = this % m_stepSize end function ! -------------------- subroutine vsi_set_step_size ( this , x ) !! Sets the current step size. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The step size. this % m_stepSize = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_next_step_size ( this ) result ( rst ) !! Gets the next step size. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The step size. rst = this % m_nextStep end function ! -------------------- subroutine vsi_set_next_step_size ( this , x ) !! Sets the next step size. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The step size. this % m_nextStep = x end subroutine ! ------------------------------------------------------------------------------ pure function vsi_get_respect_xmax ( this ) result ( rst ) !! Gets a value determining if the integrator should respect a !! hard limit in the independent variable range.  If false, the !! integrator may step pass the limit. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. logical :: rst !! True if the integrator should respect the limiting value of !!  the independent variable; else, false. rst = this % m_respectXMax end function ! -------------------- subroutine vsi_set_respect_xmax ( this , x ) !! Sets a value determining if the integrator should respect a !! hard limit in the independent variable range.  If false, the !! integrator may step pass the limit. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. logical , intent ( in ) :: x !! True if the integrator should respect the limiting !!  value of the independent variable; else, false. this % m_respectXMax = x end subroutine ! ------------------------------------------------------------------------------ subroutine vsi_alloc_workspace ( this , neqn , err ) !! Initializes the integrator. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !!  can be used to retrieve information relating to any errors !!  encountered during execution. If not provided, a default !!  implementation of the errors class is used internally to provide !!  error handling.  Possible errors and warning messages that may be !!  encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. ! Local Variables integer ( int32 ) :: flag real ( real64 ) :: default_rtol , default_atol class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Process default_atol = this % get_default_absolute_tolerance () default_rtol = this % get_default_relative_tolerance () if ( allocated ( this % m_ework )) then if ( size ( this % m_ework ) /= neqn ) then deallocate ( this % m_ework ) allocate ( this % m_ework ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_ework ( neqn ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) go to 10 end if ! Ensure tolerance arrays are initialized appropriately as well if ( allocated ( this % m_rtol )) then if ( size ( this % m_rtol ) /= neqn ) then deallocate ( this % m_rtol ) allocate ( this % m_rtol ( neqn ), stat = flag , source = default_rtol ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_rtol ( neqn ), stat = flag , source = default_rtol ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_atol )) then if ( size ( this % m_atol ) /= neqn ) then deallocate ( this % m_atol ) allocate ( this % m_atol ( neqn ), stat = flag , source = default_atol ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_atol ( neqn ), stat = flag , source = default_atol ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"vsi_alloc_workspace\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ subroutine vsi_step ( this , sys , x , xmax , y , yn , xprev , yprev , fprev , err ) !! Takes one integration step. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ) :: xmax !! The upper integration limit. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the dependent !! variables. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where the values of the dependent variables at !! x + h will be written. real ( real64 ), intent ( in ), optional , dimension (:) :: xprev !! An optional M-element array containing the previous M values !! of the independent variable where M is the order of the !! method.  This is typically only used for multi-step methods. !! In single-step methods, this parameter is typically not !! needed. real ( real64 ), intent ( in ), optional , dimension (:,:) :: yprev !! An optional M-by-N matrix containing the previous M arrays of !! dependent variables, where M is the order of the method.  As !! with xprev, this parameter is typically used for multi-step !! methods.  In single-step methods, this parameter is typically !! not needed. real ( real64 ), intent ( inout ), optional , dimension (:,:) :: fprev !! An optional M-by-N matrix containing the previous M arrays of !! ODE (function) values.  As with xprev and yprev, M is the !! order of the method, and this parameter is typically used for !! multi-step methods.  In single-step methods, this parameter !! is typically not needed. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. ! Local Variables integer ( int32 ) :: i , neqn real ( real64 ) :: h , enorm , et class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if neqn = size ( y ) h = this % get_next_step_size () ! Input Checking if ( size ( yn ) /= neqn ) then call report_array_size_error ( errmgr , \"vsi_step\" , \"yn\" , neqn , size ( yn )) return end if ! Ensure the proper workspaces are allocated if (. not . allocated ( this % m_ework )) then call this % initialize ( neqn , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Process i = 0 do ! Attempt a step call this % attempt_step ( sys , h , x , y , yn , this % m_ework , xprev , & yprev , fprev , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the normalized error enorm = norm2 ( & this % m_ework / ( neqn * ( this % m_atol + & max ( maxval ( abs ( y )), maxval ( abs ( yn ))) * this % m_rtol )) & ) if ( enorm <= 1.0d0 ) call this % set_step_size ( h ) ! Compute a new step size h = this % compute_next_step_size ( h , enorm , this % get_previous_error_norm ()) ! Check to see if the step size is too small if ( abs ( h ) < abs ( this % get_min_step_size ())) then call report_step_size_too_small ( errmgr , \"vsi_step\" , x , h ) return end if ! Do we need to limit the step size to not overstep a limiting x value? if ( this % get_respect_x_max () . and . & abs ( x + h ) > abs ( xmax )) & then h = xmax - x end if ! Is the step successful (enorm is normalized to the error tolerances ! such that a value less or equal to 1 is successful; else, keep going) if ( enorm <= 1.0d0 ) exit ! Update the iteration counter i = i + 1 if ( i > this % get_max_per_step_iteration_count ()) then call report_excessive_iterations ( errmgr , \"vsi_step\" , i , x ) return end if end do ! Store error values from this step call this % set_previous_error_norm ( enorm ) ! Store the updated step size call this % set_next_step_size ( h ) ! Perform any actions needed on a successful step call this % on_successful_step ( x , x + this % get_step_size (), y , yn ) ! End return end subroutine ! ------------------------------------------------------------------------------ pure function vsi_estimate_first_step ( this , xo , xf , yo , fo ) & result ( rst ) !! Computes an estimate to the first step size based upon the initial !! function values. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: xo !! The initial value of the independent variable. real ( real64 ), intent ( in ) :: xf !! The final value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yo !! An N-element array containing the initial values. real ( real64 ), intent ( in ), dimension (:) :: fo !! An N-element array containing the initial function values. real ( real64 ) :: rst !! An estimate on the initial step size. ! Local Variables real ( real64 ) :: h1 , h2 ! Process h1 = 0.5d0 * ( xf - xo ) h2 = this % get_max_step_size () rst = sign ( min ( abs ( h1 ), abs ( h2 )), h1 ) end function ! ------------------------------------------------------------------------------ pure function vsi_get_default_rel_tol ( this ) result ( rst ) !! Gets the default relative error tolerance. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The tolerance value. rst = 1.0d-6 end function ! ------------------------------------------------------------------------------ pure function vsi_get_default_abs_tol ( this ) result ( rst ) !! Gets the default absolute error tolerance. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The tolerance value. rst = 1.0d-6 end function ! ------------------------------------------------------------------------------ function vsi_get_buffer_contents ( this ) result ( rst ) !! Returns the contents of the solution buffer. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The buffer contents. ! Local Variables integer ( int32 ) :: m , n ! Initialization m = this % get_buffer_size () n = size ( this % m_buffer , 2 ) ! Process if ( allocated ( this % m_buffer )) then allocate ( rst ( m , n ), source = this % m_buffer (: m ,:)) else allocate ( rst ( 0 , 0 )) end if end function ! ------------------------------------------------------------------------------ pure function vsi_get_prev_err_norm ( this ) result ( rst ) !! Gets the norm of the previous step's error estimate. class ( variable_step_integrator ), intent ( in ) :: this !! The variable_step_integrator object. real ( real64 ) :: rst !! The error norm. rst = this % m_enormPrev end function ! -------------------- subroutine vsi_set_prev_err_norm ( this , x ) !! Sets the norm of the previous step's error estimate. class ( variable_step_integrator ), intent ( inout ) :: this !! The variable_step_integrator object. real ( real64 ), intent ( in ) :: x !! The error norm. this % m_enormPrev = x end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_variable_step.f90.html"}]}