var tipuesearch = {"pages":[{"title":" DIFFEQ ","text":"DIFFEQ Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"ode_container – DIFFEQ ","text":"type, public :: ode_container A container for the routine containing the ODEs to integrate. Contents Variables fcn jacobian mass_matrix Type-Bound Procedures compute_jacobian get_finite_difference_step get_is_mass_matrix_dependent get_is_ode_defined set_finite_difference_step set_is_mass_matrix_dependent Components Type Visibility Attributes Name Initial procedure( ode ), public, pointer, nopass :: fcn => null() A pointer to the routine containing the ODEs to integrate. procedure( ode_jacobian ), public, pointer, nopass :: jacobian => null() A pointer to the routine containing the analytical Jacobian.\nIf supplied, this routine is utilized; however, if null, a finite\ndifference approximation is utilized. procedure( ode_mass_matrix ), public, pointer, nopass :: mass_matrix => null() A pointer to the routine containing the mass matrix for the\nsystem.  If set to null (the default), an identity mass matrix \nwill be assumed. Type-Bound Procedures procedure, public :: compute_jacobian => oc_jacobian private  subroutine oc_jacobian(this, x, y, jac, args, err) Computes the Jacobian matrix for the system of ODEs.  If\na routine is provided with an analytical Jacobian, the supplied\nroutine is utilized; else, the Jacobian is estimated via a forward\ndifference approximation. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. real(kind=real64), intent(in) :: x The current independent variable value. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current dependent\nvariable values. real(kind=real64), intent(out), dimension(:,:) :: jac An N-by-N matrix where the Jacobian will be written. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory \n     allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is defined,\n     and the calculation is being performed by finite differences. DIFFEQ_MATRIX_SIZE_ERROR: Occurs if jac is not N-by-N. procedure, public :: get_finite_difference_step => oc_get_fd_step private pure function oc_get_fd_step(this) result(rst) Gets the size of the step to use for the finite difference\ncalculations used to estimate the Jacobian. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value real(kind=real64) The step size. procedure, public :: get_is_mass_matrix_dependent => oc_get_is_mass_dependent private pure function oc_get_is_mass_dependent(this) result(rst) Gets a value determining if the mass matrix is state-dependent\nsuch that it requires updating at every integration step. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value logical True if the mass matrix is state-dependent such that it \nrequires updating at each integration step; else, false if the\nmass matrix is not state-dependent and can be treated as constant\nfor all integration steps. procedure, public :: get_is_ode_defined => oc_get_is_ode_defined private  function oc_get_is_ode_defined(this) result(rst) Gets a logical value determining if the ODE routine has been defined. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(in) :: this The ode_container object. Return Value logical True if the ODE routine has been defined; else, false. procedure, public :: set_finite_difference_step => oc_set_fd_step private  subroutine oc_set_fd_step(this, x) Sets the size of the step to use for the finite difference\ncalculations used to estimate the Jacobian. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. real(kind=real64), intent(in) :: x The step size. procedure, public :: set_is_mass_matrix_dependent => oc_set_is_mass_dependent private  subroutine oc_set_is_mass_dependent(this, x) Sets a value determining if the mass matrix is state-dependent\nsuch that it requires updating at every integration step. Arguments Type Intent Optional Attributes Name class( ode_container ), intent(inout) :: this The ode_container object. logical :: x True if the mass matrix is state-dependent such that it \nrequires updating at each integration step; else, false if the\nmass matrix is not state-dependent and can be treated as constant\nfor all integration steps.","tags":"","loc":"type\\ode_container.html"},{"title":"ode_integrator – DIFFEQ ","text":"type, public, abstract :: ode_integrator The most basic ODE integrator object capable of integrating\nsystems of ODE's. Contents Type-Bound Procedures append_to_buffer clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_step_limit get_step_size_control_parameter get_step_size_factor set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => oi_estimate_error Computes the norm of the scaled error estimate. private pure function oi_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => oi_next_step Estimates the next step size. private  function oi_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure( ode_solver ), public, deferred, pass :: solve Solves the supplied system of ODE's. subroutine ode_solver(this, sys, x, iv, args, err) Prototype Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\ode_integrator.html"},{"title":"single_step_integrator – DIFFEQ ","text":"type, public, abstract, extends( ode_integrator ) :: single_step_integrator The most basic, single-step integrator object capable of integrating\nsystems of ODE's. Contents Type-Bound Procedures append_to_buffer attempt_step clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_is_fsal get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_stage_count get_step_limit get_step_size_control_parameter get_step_size_factor interpolate post_step_action pre_step_action set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure( attempt_single_step ), public, deferred, pass :: attempt_step Attempts an integration step for a single-step integrator. subroutine attempt_single_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Prototype Attempts an integration step for a single-step integrator. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => oi_estimate_error Computes the norm of the scaled error estimate. private pure function oi_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => oi_next_step Estimates the next step size. private  function oi_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure( get_single_step_logical_parameter ), public, deferred, pass :: get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. pure function get_single_step_logical_parameter(this) result(rst) Prototype Returns a logical parameter from a single_step_integrator object. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value logical The parameter. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure( ode_integer_inquiry ), public, deferred, pass :: get_order Returns the order of the integrator. pure function ode_integer_inquiry(this) result(rst) Prototype Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure( single_step_integer_inquiry ), public, deferred, pass :: get_stage_count Gets the number of stages used by the integrator. pure function single_step_integer_inquiry(this) result(rst) Prototype Gets an integer from the integrator. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value integer(kind=int32) The integer value. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure( single_step_interpolate ), public, deferred, pass :: interpolate Performs an interpolation to estimate the solution at the\nrequested point. subroutine single_step_interpolate(this, x, xn, yn, fn, xn1, yn1, fn1, y) Prototype Provides a routine for interpolation. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. procedure( single_step_post_step_routine ), public, deferred, pass :: post_step_action Performs actions such as setting up interpolation after \ncompletion of a successful integration step. subroutine single_step_post_step_routine(this, sys, dense, x, xn, y, yn, f, fn, k, args) Prototype Provides a routine for performing any actions, such as setting\nup interpolation, after successful completion of a step. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure( single_step_pre_step_routine ), public, deferred, pass :: pre_step_action Provides a routine for performing any actions, such as setting\nup Jacobian calculations. subroutine single_step_pre_step_routine(this, prevs, sys, h, x, y, f, args, err) Prototype Provides a routine for performing any actions, such as setting\nup Jacobian calculations. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure, public :: solve => ssi_ode_solver Solves the supplied system of ODE's. private  subroutine ssi_ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array of independent variable values at which to return the \nthe solution to the ODE's. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\single_step_integrator.html"},{"title":"rosenbrock – DIFFEQ ","text":"type, public, extends( single_step_integrator ) :: rosenbrock Defines a 4th order Rosenbrock integrator. Remarks:\n1. This integrator is suitable for systems of stiff equations \n with modest accuracy requirements.\n2. This integrator is capable of dealing with systems that utilize a \n mass matrix. Contents Type-Bound Procedures append_to_buffer attempt_step clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_is_fsal get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_stage_count get_step_limit get_step_size_control_parameter get_step_size_factor interpolate post_step_action pre_step_action set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure, public :: attempt_step => rbrk_attempt_step Attempts an integration step for this integrator. private  subroutine rbrk_attempt_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Attempts an integration step for this integrator. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(inout) :: this The rosenbrock object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => oi_estimate_error Computes the norm of the scaled error estimate. private pure function oi_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => rbrk_next_step Estimates the next step size. private  function rbrk_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(inout) :: this The rosenbrock object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: get_is_fsal => rbrk_get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. private pure function rbrk_get_is_fsal(this) result(rst) Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(in) :: this The rosenbrock object. Return Value logical True for a FSAL integrator; else, false. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_order => rbrk_get_order Gets the order of the integrator. private pure function rbrk_get_order(this) result(rst) Gets the order of the integrator. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(in) :: this The rosenbrock object. Return Value integer(kind=int32) The order. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure, public :: get_stage_count => rbrk_get_stage_count Gets the stage count for this integrator. private pure function rbrk_get_stage_count(this) result(rst) Gets the stage count for this integrator. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(in) :: this The rosenbrock object. Return Value integer(kind=int32) The stage count. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure, public :: interpolate => rbrk_interp Performs the interpolation. private  subroutine rbrk_interp(this, x, xn, yn, fn, xn1, yn1, fn1, y) Performs the interpolation. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(in) :: this The rosenbrock object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. procedure, public :: post_step_action => rbrk_set_up_interp Sets up the interpolation process as the post-step action. private  subroutine rbrk_set_up_interp(this, sys, dense, x, xn, y, yn, f, fn, k, args) Sets up the interpolation process. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(inout) :: this The rosenbrock object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: pre_step_action => rbrk_form_matrix Constructs the system matrix. private  subroutine rbrk_form_matrix(this, prevs, sys, h, x, y, f, args, err) Constructs the system matrix of the form , and then computes it's LU \nfactorization.  The LU-factored form of A is stored internally. Arguments Type Intent Optional Attributes Name class( rosenbrock ), intent(inout) :: this The rosenbrock object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true if the\nprevious step was successful; else, false if the previous step \nfailed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives at x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure, public :: solve => ssi_ode_solver Solves the supplied system of ODE's. private  subroutine ssi_ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array of independent variable values at which to return the \nthe solution to the ODE's. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\rosenbrock.html"},{"title":"runge_kutta_23 – DIFFEQ ","text":"type, public, extends( single_step_integrator ) :: runge_kutta_23 The Bogacki-Shampine integrator (3rd order with an embedded 2nd order\nused for error estimation). Contents Type-Bound Procedures append_to_buffer attempt_step clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_is_fsal get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_stage_count get_step_limit get_step_size_control_parameter get_step_size_factor interpolate post_step_action pre_step_action set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure, public :: attempt_step => rk23_attempt_step Attempts an integration step for this integrator. private  subroutine rk23_attempt_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Attempts an integration step for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(inout) :: this The runge_kutta_23 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => oi_estimate_error Computes the norm of the scaled error estimate. private pure function oi_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => oi_next_step Estimates the next step size. private  function oi_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: get_is_fsal => rk23_get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. private pure function rk23_get_is_fsal(this) result(rst) Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(in) :: this The runge_kutta_23 object. Return Value logical True for a FSAL integrator; else, false. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_order => rk23_get_order Gets the order of the integrator. private pure function rk23_get_order(this) result(rst) Gets the order of the integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(in) :: this The runge_kutta_23 object. Return Value integer(kind=int32) The order. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure, public :: get_stage_count => rk23_get_stage_count Gets the stage count for this integrator. private pure function rk23_get_stage_count(this) result(rst) Gets the stage count for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(in) :: this The runge_kutta_23 object. Return Value integer(kind=int32) The stage count. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure, public :: interpolate => rk23_interp Performs the interpolation. private  subroutine rk23_interp(this, x, xn, yn, fn, xn1, yn1, fn1, y) Performs the interpolation. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(in) :: this The runge_kutta_23 object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. procedure, public :: post_step_action => rk23_set_up_interp Sets up the interpolation process as the post-step action. private  subroutine rk23_set_up_interp(this, sys, dense, x, xn, y, yn, f, fn, k, args) Sets up the interpolation process. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(inout) :: this The runge_kutta_23 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: pre_step_action => rk23_pre_step Performs any pre-step actions. private  subroutine rk23_pre_step(this, prevs, sys, h, x, y, f, args, err) Placeholder routine for any pre-step actions. Arguments Type Intent Optional Attributes Name class( runge_kutta_23 ), intent(inout) :: this The runge_kutta_23 object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure, public :: solve => ssi_ode_solver Solves the supplied system of ODE's. private  subroutine ssi_ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array of independent variable values at which to return the \nthe solution to the ODE's. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\runge_kutta_23.html"},{"title":"runge_kutta_45 – DIFFEQ ","text":"type, public, extends( single_step_integrator ) :: runge_kutta_45 The Dormand-Prince, Runge-Kutta integrator (5th order, with an \nembedded 4th order used for error estimation). Contents Type-Bound Procedures append_to_buffer attempt_step clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_is_fsal get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_stage_count get_step_limit get_step_size_control_parameter get_step_size_factor interpolate post_step_action pre_step_action set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure, public :: attempt_step => rk45_attempt_step Attempts an integration step for this integrator. private  subroutine rk45_attempt_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Attempts an integration step for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(inout) :: this The runge_kutta_45 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => oi_estimate_error Computes the norm of the scaled error estimate. private pure function oi_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => oi_next_step Estimates the next step size. private  function oi_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: get_is_fsal => rk45_get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. private pure function rk45_get_is_fsal(this) result(rst) Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(in) :: this The runge_kutta_45 object. Return Value logical True for a FSAL integrator; else, false. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_order => rk45_get_order Gets the order of the integrator. private pure function rk45_get_order(this) result(rst) Gets the order of the integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(in) :: this The runge_kutta_45 object. Return Value integer(kind=int32) The order. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure, public :: get_stage_count => rk45_get_stage_count Gets the stage count for this integrator. private pure function rk45_get_stage_count(this) result(rst) Gets the stage count for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(in) :: this The runge_kutta_45 object. Return Value integer(kind=int32) The stage count. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure, public :: interpolate => rk45_interp Performs the interpolation. private  subroutine rk45_interp(this, x, xn, yn, fn, xn1, yn1, fn1, y) Performs the interpolation. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(in) :: this The runge_kutta_45 object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. procedure, public :: post_step_action => rk45_set_up_interp Sets up the interpolation process as the post-step action. private  subroutine rk45_set_up_interp(this, sys, dense, x, xn, y, yn, f, fn, k, args) Sets up the interpolation process. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(inout) :: this The runge_kutta_45 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: pre_step_action => rk45_pre_step Performs any pre-step actions. private  subroutine rk45_pre_step(this, prevs, sys, h, x, y, f, args, err) Placeholder routine for any pre-step actions. Arguments Type Intent Optional Attributes Name class( runge_kutta_45 ), intent(inout) :: this The runge_kutta_45 object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure, public :: solve => ssi_ode_solver Solves the supplied system of ODE's. private  subroutine ssi_ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array of independent variable values at which to return the \nthe solution to the ODE's. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\runge_kutta_45.html"},{"title":"runge_kutta_853 – DIFFEQ ","text":"type, public, extends( single_step_integrator ) :: runge_kutta_853 An 8th order Runge-Kutta integrator with embedded 5th and 3rd order\nsolutions for error estimation. Contents Type-Bound Procedures append_to_buffer attempt_step clear_buffer compute_error_norm estimate_inital_step_size estimate_next_step_size get_absolute_tolerance get_allow_overshoot get_is_fsal get_maximum_step_size get_minimum_step_size get_order get_relative_tolerance get_solution get_stage_count get_step_limit get_step_size_control_parameter get_step_size_factor interpolate post_step_action pre_step_action set_absolute_tolerance set_allow_overshoot set_maximum_step_size set_minimum_step_size set_relative_tolerance set_step_limit set_step_size_control_parameter set_step_size_factor solve Type-Bound Procedures procedure, public :: append_to_buffer => oi_append_to_buffer Appends the supplied solution point to the internal solution \nbuffer. private  subroutine oi_append_to_buffer(this, x, y, err) Appends the supplied solution point to the internal solution buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The independent variable value. real(kind=real64), intent(in), dimension(:) :: y The values of the dependent variables corresponding to x. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. procedure, public :: attempt_step => rk853_attempt_step Attempts an integration step for this integrator. private  subroutine rk853_attempt_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Attempts an integration step for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(inout) :: this The runge_kutta_853 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: clear_buffer => oi_clear_buffer Clears the contents of the buffer. private  subroutine oi_clear_buffer(this) Clears the contents of the buffer. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. procedure, public :: compute_error_norm => rk853_estimate_error Computes the norm of the scaled error estimate. private pure function rk853_estimate_error(this, y, yest, yerr) result(rst) Computes the norm of the scaled error estimate.  A value less than one\nindicates a successful step.  A value greater than one suggests that the\nresults do not meet the requested tolerances. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(in) :: this The runge_kutta_853 object. real(kind=real64), intent(in), dimension(:) :: y The previously accepted solution array (N-element). real(kind=real64), intent(in), dimension(size(y)) :: yest An N-element array containing the next solution point estimate. real(kind=real64), intent(in), dimension(size(y)) :: yerr An N-element array containing the estimate of error for each\nequation. Return Value real(kind=real64) The norm of the scaled error. procedure, public :: estimate_inital_step_size => oi_initial_step Computes an estimate of an initial step size. private  subroutine oi_initial_step(this, sys, xo, xf, yo, fo, h, args) Computes an estimate of an initial step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. class( ode_container ), intent(in) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: xo The initial value of the independent variable. real(kind=real64), intent(in) :: xf The final value of the independent variable. real(kind=real64), intent(in), dimension(:) :: yo The initial values of the dependent variables (N-element). real(kind=real64), intent(out), dimension(size(yo)) :: fo An N-element array where the function values at xo will be written. real(kind=real64), intent(out) :: h The initial step size estimate. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: estimate_next_step_size => oi_next_step Estimates the next step size. private  function oi_next_step(this, e, eold, h, x, err) result(rst) Estimates the next step size based upon the current and previous error\nestimates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: e The norm of the current scaled error estimate. real(kind=real64), intent(inout) :: eold The norm of the previous step's scaled error estimate.  On output,\nthis variable is updated. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current independent variable value. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size\n     becomes too small in magnitude. Return Value real(kind=real64) The new step size estimate. procedure, public :: get_absolute_tolerance => oi_get_abs_tol Gets the absolute error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_allow_overshoot => oi_get_allow_overshoot Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private pure function oi_get_allow_overshoot(this) result(rst) Gets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value logical True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: get_is_fsal => rk853_get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. private pure function rk853_get_is_fsal(this) result(rst) Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(in) :: this The runge_kutta_853 object. Return Value logical True for a FSAL integrator; else, false. procedure, public :: get_maximum_step_size => oi_get_max_step Gets the magnitude of the maximum allowed step size. private pure function oi_get_max_step(this) result(rst) Gets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_minimum_step_size => oi_get_min_step Gets the magnitude of the minimum allowed step size. private pure function oi_get_min_step(this) result(rst) Gets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The step size limit. procedure, public :: get_order => rk853_get_order Gets the order of the integrator. private pure function rk853_get_order(this) result(rst) Gets the order of the integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(in) :: this The runge_kutta_853 object. Return Value integer(kind=int32) The order. procedure, public :: get_relative_tolerance => oi_get_abs_tol Gets the relative error tolerance. private pure function oi_get_abs_tol(this) result(rst) Gets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_solution => oi_get_solution Returns the solution computed by the integrator. private pure function oi_get_solution(this) result(rst) Returns the solution computed by the integrator stored as a matrix with\nthe first column containing the values of the independent variable at\nwhich the solution was computed.  The remaining columns contain the\nsolutions for each of the integrated equations in the order in which they\nappear in the source routine.  Notice, the solve routine must be called\nbefore this routine. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting solution matrix. procedure, public :: get_stage_count => rk853_get_stage_count Gets the stage count for this integrator. private pure function rk853_get_stage_count(this) result(rst) Gets the stage count for this integrator. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(in) :: this The runge_kutta_853 object. Return Value integer(kind=int32) The stage count. procedure, public :: get_step_limit => oi_get_step_limit Gets the limit on the number of integration steps. private pure function oi_get_step_limit(this) result(rst) Gets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The step limit. procedure, public :: get_step_size_control_parameter => oi_get_control_parameter Gets the step size PI control parameter. private pure function oi_get_control_parameter(this) result(rst) Gets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The control parameter. procedure, public :: get_step_size_factor => oi_get_safety_factor Gets the step size safety factor. private pure function oi_get_safety_factor(this) result(rst) Gets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value real(kind=real64) The safety factor. procedure, public :: interpolate => rk853_interp Performs the interpolation. private  subroutine rk853_interp(this, x, xn, yn, fn, xn1, yn1, fn1, y) Performs the interpolation. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(in) :: this The runge_kutta_853 object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. procedure, public :: post_step_action => rk853_set_up_interp Sets up the interpolation process as the post-step action. private  subroutine rk853_set_up_interp(this, sys, dense, x, xn, y, yn, f, fn, k, args) Sets up the interpolation process. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(inout) :: this The runge_kutta_853 object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each stage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. procedure, public :: pre_step_action => rk853_pre_step Performs any pre-step actions. Initializes private storage arrays for the integrator. private  subroutine rk853_pre_step(this, prevs, sys, h, x, y, f, args, err) Placeholder routine for any pre-step actions. Arguments Type Intent Optional Attributes Name class( runge_kutta_853 ), intent(inout) :: this The runge_kutta_853 object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. procedure, public :: set_absolute_tolerance => oi_set_abs_tol Sets the absolute error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_allow_overshoot => oi_set_allow_overshoot Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. private  subroutine oi_set_allow_overshoot(this, x) Sets a value determining if the solver is allowed to overshoot the final\nvalue in the integration range. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. logical, intent(in) :: x True if the solver can overshoot, and then interpolate to achieve the\nrequired final value; else, false thereby indicating the solver \ncannot overshoot. procedure, public :: set_maximum_step_size => oi_set_max_step Sets the magnitude of the maximum allowed step size. private  subroutine oi_set_max_step(this, x) Sets the magnitude of the maximum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_minimum_step_size => oi_set_min_step Sets the magnitude of the minimum allowed step size. private  subroutine oi_set_min_step(this, x) Sets the magnitude of the minimum allowed step size. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The step size limit. procedure, public :: set_relative_tolerance => oi_set_abs_tol Sets the relative error tolerance. private  subroutine oi_set_abs_tol(this, x) Sets the absolute error tolerance. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_step_limit => oi_set_step_limit Sets the limit on the number of integration steps. private  subroutine oi_set_step_limit(this, x) Sets the limit on the number of integration steps that may be taken \nbefore the solver terminates. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. integer(kind=int32), intent(in) :: x The step limit. procedure, public :: set_step_size_control_parameter => oi_set_control_parameter Sets the step size PI control parameter. private  subroutine oi_set_control_parameter(this, x) Sets the step size control parameter used for PI control of \nthe step size.  A value of 0 provides a default step size controller\n(non-PI); however, a nonzero value of provides PI control \nthat improves stability, but comes with a potential for efficiency loss.\nA good estimate for a starting point for this parameter is where is the order of the integrator. The PI controller for step size is defined as follows. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The control parameter procedure, public :: set_step_size_factor => oi_set_safety_factor Sets the step size safety factor. private  subroutine oi_set_safety_factor(this, x) Sets the safety factor (step size multiplier) used to provide a measure\nof control to the step size estimate such that ,\nwhere is this safety factor. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. real(kind=real64), intent(in) :: x The safety factor. procedure, public :: solve => ssi_ode_solver Solves the supplied system of ODE's. private  subroutine ssi_ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array of independent variable values at which to return the \nthe solution to the ODE's. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x.","tags":"","loc":"type\\runge_kutta_853.html"},{"title":"attempt_single_step – DIFFEQ","text":"interface public  subroutine attempt_single_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. Description Attempts an integration step for a single-step integrator.","tags":"","loc":"interface\\attempt_single_step.html"},{"title":"get_single_step_logical_parameter – DIFFEQ","text":"interface public pure function get_single_step_logical_parameter(this) result(rst) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value logical The parameter. Description Returns a logical parameter from a single_step_integrator object.","tags":"","loc":"interface\\get_single_step_logical_parameter.html"},{"title":"ode – DIFFEQ","text":"interface public  subroutine ode(x, y, dydx, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: dydx An N-element array where the derivative values will be\nwritten. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. Description An interface to a routine containing a system of first order\nODE's to integrate.","tags":"","loc":"interface\\ode.html"},{"title":"ode_integer_inquiry – DIFFEQ","text":"interface public pure function ode_integer_inquiry(this) result(rst) Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. Description Returns an integer value from the ode_integrator object.","tags":"","loc":"interface\\ode_integer_inquiry.html"},{"title":"ode_jacobian – DIFFEQ","text":"interface public  subroutine ode_jacobian(x, y, jac, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:,:) :: jac An M-by-N matrix where the Jacobian will be written. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. Description An interface to a routine capable of computing the Jacobian\nmatrix of a system of first order ODE's.","tags":"","loc":"interface\\ode_jacobian.html"},{"title":"ode_mass_matrix – DIFFEQ","text":"interface public  subroutine ode_mass_matrix(x, y, m, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:,:) :: m An N-by-N matrix where the class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. Description An interface to a routine capable of computing a mass matrix\nfor a system of differential equations.","tags":"","loc":"interface\\ode_mass_matrix.html"},{"title":"ode_solver – DIFFEQ","text":"interface public  subroutine ode_solver(this, sys, x, iv, args, err) Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. Description Solves the supplied system of ODE's.","tags":"","loc":"interface\\ode_solver.html"},{"title":"single_step_integer_inquiry – DIFFEQ","text":"interface public pure function single_step_integer_inquiry(this) result(rst) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value integer(kind=int32) The integer value. Description Gets an integer from the integrator.","tags":"","loc":"interface\\single_step_integer_inquiry.html"},{"title":"single_step_interpolate – DIFFEQ","text":"interface public  subroutine single_step_interpolate(this, x, xn, yn, fn, xn1, yn1, fn1, y) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. Description Provides a routine for interpolation.","tags":"","loc":"interface\\single_step_interpolate.html"},{"title":"single_step_post_step_routine – DIFFEQ","text":"interface public  subroutine single_step_post_step_routine(this, sys, dense, x, xn, y, yn, f, fn, k, args) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. Description Provides a routine for performing any actions, such as setting\nup interpolation, after successful completion of a step.","tags":"","loc":"interface\\single_step_post_step_routine.html"},{"title":"single_step_pre_step_routine – DIFFEQ","text":"interface public  subroutine single_step_pre_step_routine(this, prevs, sys, h, x, y, f, args, err) Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Description Provides a routine for performing any actions, such as setting\nup Jacobian calculations.","tags":"","loc":"interface\\single_step_pre_step_routine.html"},{"title":"report_array_size_error – DIFFEQ","text":"public  subroutine report_array_size_error(err, fcn, varname, expsize, actsize) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: expsize The expected size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_excessive_integration_steps – DIFFEQ","text":"public  subroutine report_excessive_integration_steps(err, fcn, n, x) Reports an error when an excessive  amount integration steps have been \ntaken. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of integration steps. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_excessive_integration_steps.html"},{"title":"report_excessive_iterations – DIFFEQ","text":"public  subroutine report_excessive_iterations(err, fcn, n, x) Reports an error when excessive iterations have been made. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of iterations. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_excessive_iterations.html"},{"title":"report_matrix_size_error – DIFFEQ","text":"public  subroutine report_matrix_size_error(err, fcn, varname, exprow, expcol, actrow, actcol) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: exprow The expected number of rows. integer(kind=int32), intent(in) :: expcol The expected number of columns. integer(kind=int32), intent(in) :: actrow The actual number of rows. integer(kind=int32), intent(in) :: actcol The actual number of columns. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – DIFFEQ","text":"public  subroutine report_memory_error(err, fcn, flag) Reports a memory error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: flag The memory status flag. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_min_array_size_not_met – DIFFEQ","text":"public  subroutine report_min_array_size_not_met(err, fcn, varname, minsize, actsize) Reports an error where the minimum array size was not met. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: minsize The minimum size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_min_array_size_not_met.html"},{"title":"report_missing_argument – DIFFEQ","text":"public  subroutine report_missing_argument(err, fcn, arg) Reports a missing argument error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: arg The name of the argument. Contents","tags":"","loc":"proc\\report_missing_argument.html"},{"title":"report_missing_ode – DIFFEQ","text":"public  subroutine report_missing_ode(err, fcn) Reports a missing ODE routine. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. Contents","tags":"","loc":"proc\\report_missing_ode.html"},{"title":"report_step_size_too_small – DIFFEQ","text":"public  subroutine report_step_size_too_small(err, fcn, x, h) Reports an error when the step size becomes too small. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. real(kind=real64), intent(in) :: x The value of the independent variable at which the step size error\noccurred. real(kind=real64), intent(in) :: h The step size value. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=256), public :: msg","tags":"","loc":"proc\\report_step_size_too_small.html"},{"title":"diffeq – DIFFEQ","text":"@brief This module contains several ODE solvers and associated types. Uses diffeq_implicit_runge_kutta diffeq_base iso_fortran_env diffeq_runge_kutta Contents None","tags":"","loc":"module\\diffeq.html"},{"title":"diffeq_base – DIFFEQ","text":"A collection of base types for the DIFFEQ library. Uses ferror diffeq_errors iso_fortran_env Contents Interfaces attempt_single_step get_single_step_logical_parameter ode ode_integer_inquiry ode_jacobian ode_mass_matrix ode_solver single_step_integer_inquiry single_step_interpolate single_step_post_step_routine single_step_pre_step_routine Derived Types ode_container ode_integrator single_step_integrator Interfaces interface public  subroutine attempt_single_step(this, sys, h, x, y, f, yn, fn, yerr, k, args) Attempts an integration step for a single-step integrator. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. real(kind=real64), intent(out), dimension(:) :: yn An N-element array where this routine will write the next\nsolution estimate at x + h. real(kind=real64), intent(out), dimension(:) :: fn An N-element array where this routine will write the next\nderivative estimate at x + h. real(kind=real64), intent(out), dimension(:) :: yerr An N-element array where this routine will write an estimate\nof the error in each equation. real(kind=real64), intent(out), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. interface public pure function get_single_step_logical_parameter(this) result(rst) Returns a logical parameter from a single_step_integrator object. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value logical The parameter. interface public  subroutine ode(x, y, dydx, args) An interface to a routine containing a system of first order\nODE's to integrate. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:) :: dydx An N-element array where the derivative values will be\nwritten. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. interface public pure function ode_integer_inquiry(this) result(rst) Returns an integer value from the ode_integrator object. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(in) :: this The ode_integrator object. Return Value integer(kind=int32) The requested value. interface public  subroutine ode_jacobian(x, y, jac, args) An interface to a routine capable of computing the Jacobian\nmatrix of a system of first order ODE's. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:,:) :: jac An M-by-N matrix where the Jacobian will be written. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. interface public  subroutine ode_mass_matrix(x, y, m, args) An interface to a routine capable of computing a mass matrix\nfor a system of differential equations. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current values of the\ndependent variables. real(kind=real64), intent(out), dimension(:,:) :: m An N-by-N matrix where the class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the routine. interface public  subroutine ode_solver(this, sys, x, iv, args, err) Solves the supplied system of ODE's. Arguments Type Intent Optional Attributes Name class( ode_integrator ), intent(inout) :: this The ode_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: x An array, of at least 2 values, defining at a minimum\nthe starting and ending values of the independent variable \nintegration range.  If more than two values are specified, \nthe integration results will be returned at the supplied \nvalues. real(kind=real64), intent(in), dimension(:) :: iv An array containing the initial values for each ODE. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling.  Possible errors and warning messages\nthat may be encountered are as follows. DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a \n     memory allocation issue. DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is \n     defined. DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than \n     2 values given in the independent variable array x. interface public pure function single_step_integer_inquiry(this) result(rst) Gets an integer from the integrator. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. Return Value integer(kind=int32) The integer value. interface public  subroutine single_step_interpolate(this, x, xn, yn, fn, xn1, yn1, fn1, y) Provides a routine for interpolation. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(in) :: this The single_step_integrator object. real(kind=real64), intent(in) :: x The value of the independent variable at which to compute\nthe interpolation. real(kind=real64), intent(in) :: xn The previous value of the independent variable at which the\nsolution is computed. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(in) :: xn1 The value of the independent variable at xn + h. real(kind=real64), intent(in), dimension(:) :: yn1 An N-element array containing the solution at xn + h. real(kind=real64), intent(in), dimension(:) :: fn1 An N-element array containing the derivatives at xn + h. real(kind=real64), intent(out), dimension(:) :: y An N-element array where this routine will write the \nsolution values interpolated at x. interface public  subroutine single_step_post_step_routine(this, sys, dense, x, xn, y, yn, f, fn, k, args) Provides a routine for performing any actions, such as setting\nup interpolation, after successful completion of a step. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. logical, intent(in) :: dense Determines if dense output is requested (true); else, false. real(kind=real64), intent(in) :: x The previous value of the independent variable. real(kind=real64), intent(in) :: xn The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the solution at x. real(kind=real64), intent(in), dimension(:) :: yn An N-element array containing the solution at xn. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the derivatives at x. real(kind=real64), intent(in), dimension(:) :: fn An N-element array containing the derivatives at xn. real(kind=real64), intent(inout), dimension(:,:) :: k An N-by-NSTAGES matrix containing the derivatives at each\nstage. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. interface public  subroutine single_step_pre_step_routine(this, prevs, sys, h, x, y, f, args, err) Provides a routine for performing any actions, such as setting\nup Jacobian calculations. Arguments Type Intent Optional Attributes Name class( single_step_integrator ), intent(inout) :: this The single_step_integrator object. logical, intent(in) :: prevs Defines the status of the previous step.  The value is true \nif the previous step was successful; else, false if the \nprevious step failed. class( ode_container ), intent(inout) :: sys The ode_container object containing the ODE's to integrate. real(kind=real64), intent(in) :: h The current step size. real(kind=real64), intent(in) :: x The current value of the independent variable. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the current solution at x. real(kind=real64), intent(in), dimension(:) :: f An N-element array containing the values of the derivatives\nat x. class(*), intent(inout), optional :: args An optional argument that can be used to pass information\nin and out of the differential equation subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to \nprovide error handling. Derived Types type, public :: ode_container A container for the routine containing the ODEs to integrate. Components Type Visibility Attributes Name Initial procedure( ode ), public, pointer, nopass :: fcn => null() A pointer to the routine containing the ODEs to integrate. procedure( ode_jacobian ), public, pointer, nopass :: jacobian => null() A pointer to the routine containing the analytical Jacobian.\nIf supplied, this routine is utilized; however, if null, a finite\ndifference approximation is utilized. procedure( ode_mass_matrix ), public, pointer, nopass :: mass_matrix => null() A pointer to the routine containing the mass matrix for the\nsystem.  If set to null (the default), an identity mass matrix \nwill be assumed. Type-Bound Procedures procedure\n                    ,                  public\n                  :: compute_jacobian =>\n                    oc_jacobian Subroutine procedure\n                    ,                  public\n                  :: get_finite_difference_step =>\n                    oc_get_fd_step Function procedure\n                    ,                  public\n                  :: get_is_mass_matrix_dependent =>\n                    oc_get_is_mass_dependent Function procedure\n                    ,                  public\n                  :: get_is_ode_defined =>\n                    oc_get_is_ode_defined Function procedure\n                    ,                  public\n                  :: set_finite_difference_step =>\n                    oc_set_fd_step Subroutine procedure\n                    ,                  public\n                  :: set_is_mass_matrix_dependent =>\n                    oc_set_is_mass_dependent Subroutine type, public :: ode_integrator The most basic ODE integrator object capable of integrating\nsystems of ODE's. Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    oi_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    oi_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n(ode_solver)                    ,                  public\n, pass                  :: solve Solves the supplied system of ODE's. type, public, extends( ode_integrator ) :: single_step_integrator The most basic, single-step integrator object capable of integrating\nsystems of ODE's. Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n(attempt_single_step)                    ,                  public\n, pass                  :: attempt_step Attempts an integration step for a single-step integrator. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    oi_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    oi_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n(get_single_step_logical_parameter)                    ,                  public\n, pass                  :: get_is_fsal Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n(ode_integer_inquiry)                    ,                  public\n, pass                  :: get_order Returns the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n(single_step_integer_inquiry)                    ,                  public\n, pass                  :: get_stage_count Gets the number of stages used by the integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n(single_step_interpolate)                    ,                  public\n, pass                  :: interpolate Performs an interpolation to estimate the solution at the\nrequested point. procedure\n(single_step_post_step_routine)                    ,                  public\n, pass                  :: post_step_action Performs actions such as setting up interpolation after \ncompletion of a successful integration step. procedure\n(single_step_pre_step_routine)                    ,                  public\n, pass                  :: pre_step_action Provides a routine for performing any actions, such as setting\nup Jacobian calculations. procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n                    ,                  public\n                  :: solve =>\n                    ssi_ode_solver Subroutine Solves the supplied system of ODE's.","tags":"","loc":"module\\diffeq_base.html"},{"title":"diffeq_bsrk32_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a31 a32 a41 a42 a43 b1 b1a b2 b2a b3 b3a b4 b4a c1 c2 c3 c4 e1 e2 e3 e4 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = 0.5d0 real(kind=real64), public, parameter :: a31 = 0.0d0 real(kind=real64), public, parameter :: a32 = 0.75d0 real(kind=real64), public, parameter :: a41 = 2.0d0/9.0d0 real(kind=real64), public, parameter :: a42 = 1.0d0/3.0d0 real(kind=real64), public, parameter :: a43 = 4.0d0/9.0d0 real(kind=real64), public, parameter :: b1 = 2.0d0/9.0d0 real(kind=real64), public, parameter :: b1a = 7.0d0/24.0d0 real(kind=real64), public, parameter :: b2 = 1.0d0/3.0d0 real(kind=real64), public, parameter :: b2a = 1.0d0/4.0d0 real(kind=real64), public, parameter :: b3 = 4.0d0/9.0d0 real(kind=real64), public, parameter :: b3a = 1.0d0/3.0d0 real(kind=real64), public, parameter :: b4 = 0.0d0 real(kind=real64), public, parameter :: b4a = 1.0d0/8.0d0 real(kind=real64), public, parameter :: c1 = 0.0d0 real(kind=real64), public, parameter :: c2 = 0.5d0 real(kind=real64), public, parameter :: c3 = 0.75d0 real(kind=real64), public, parameter :: c4 = 1.0d0 real(kind=real64), public, parameter :: e1 = b1a-b1 real(kind=real64), public, parameter :: e2 = b2a-b2 real(kind=real64), public, parameter :: e3 = b3a-b3 real(kind=real64), public, parameter :: e4 = b4a-b4","tags":"","loc":"module\\diffeq_bsrk32_constants.html"},{"title":"diffeq_dprk45_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a31 a32 a41 a42 a43 a51 a52 a53 a54 a61 a62 a63 a64 a65 a71 a72 a73 a74 a75 a76 c2 c3 c4 c5 c6 c7 d1 d3 d4 d5 d6 d7 e1 e2 e3 e4 e5 e6 e7 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = 1.0d0/5.0d0 real(kind=real64), public, parameter :: a31 = 3.0d0/40.0d0 real(kind=real64), public, parameter :: a32 = 9.0d0/40.0d0 real(kind=real64), public, parameter :: a41 = 44.0d0/45.0d0 real(kind=real64), public, parameter :: a42 = -56.0d0/15.0d0 real(kind=real64), public, parameter :: a43 = 32.0d0/9.0d0 real(kind=real64), public, parameter :: a51 = 1.9372d4/6.561d3 real(kind=real64), public, parameter :: a52 = -2.536d4/2.187d3 real(kind=real64), public, parameter :: a53 = 6.4448d4/6.561d3 real(kind=real64), public, parameter :: a54 = -2.12d2/7.29d2 real(kind=real64), public, parameter :: a61 = 9.017d3/3.168d3 real(kind=real64), public, parameter :: a62 = -3.55d2/33.0d0 real(kind=real64), public, parameter :: a63 = 4.6732d4/5.247d3 real(kind=real64), public, parameter :: a64 = 49.0d0/1.76d2 real(kind=real64), public, parameter :: a65 = -5.103d3/1.8656d4 real(kind=real64), public, parameter :: a71 = 35.0d0/3.84d2 real(kind=real64), public, parameter :: a72 = 0.0d0 real(kind=real64), public, parameter :: a73 = 5.0d2/1.113d3 real(kind=real64), public, parameter :: a74 = 1.25d2/1.92d2 real(kind=real64), public, parameter :: a75 = -2.187d3/6.784d3 real(kind=real64), public, parameter :: a76 = 11.0d0/84.0d0 real(kind=real64), public, parameter :: c2 = 1.0d0/5.0d0 real(kind=real64), public, parameter :: c3 = 3.0d0/1.0d1 real(kind=real64), public, parameter :: c4 = 4.0d0/5.0d0 real(kind=real64), public, parameter :: c5 = 8.0d0/9.0d0 real(kind=real64), public, parameter :: c6 = 1.0d0 real(kind=real64), public, parameter :: c7 = 1.0d0 real(kind=real64), public, parameter :: d1 = -1.2715105075d10/1.1282082432d10 real(kind=real64), public, parameter :: d3 = 8.74874797d10/3.2700410799d10 real(kind=real64), public, parameter :: d4 = -1.0690763975d10/1.880347072d9 real(kind=real64), public, parameter :: d5 = 7.01980252875d11/1.99316789632d11 real(kind=real64), public, parameter :: d6 = -1.453857185d9/8.22651844d8 real(kind=real64), public, parameter :: d7 = 6.9997945d7/2.9380423d7 real(kind=real64), public, parameter :: e1 = -71.0d0/5.76d4 real(kind=real64), public, parameter :: e2 = 0.0d0 real(kind=real64), public, parameter :: e3 = 71.0d0/1.6695d4 real(kind=real64), public, parameter :: e4 = -71.0d0/1.92d3 real(kind=real64), public, parameter :: e5 = 1.7253d4/3.392d5 real(kind=real64), public, parameter :: e6 = -22.0d0/5.25d2 real(kind=real64), public, parameter :: e7 = 1.0d0/4.0d1","tags":"","loc":"module\\diffeq_dprk45_constants.html"},{"title":"diffeq_errors – DIFFEQ","text":"A collection of routines for handling errors in the DIFFEQ library. Uses ferror iso_fortran_env Contents Variables DIFFEQ_ARRAY_SIZE_ERROR DIFFEQ_INVALID_INPUT_ERROR DIFFEQ_INVALID_OPERATION_ERROR DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR DIFFEQ_MATRIX_SIZE_ERROR DIFFEQ_MEMORY_ALLOCATION_ERROR DIFFEQ_MISSING_ARGUMENT_ERROR DIFFEQ_NULL_POINTER_ERROR DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR Subroutines report_array_size_error report_excessive_integration_steps report_excessive_iterations report_matrix_size_error report_memory_error report_min_array_size_not_met report_missing_argument report_missing_ode report_step_size_too_small Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DIFFEQ_ARRAY_SIZE_ERROR = 10003 integer(kind=int32), public, parameter :: DIFFEQ_INVALID_INPUT_ERROR = 10004 integer(kind=int32), public, parameter :: DIFFEQ_INVALID_OPERATION_ERROR = 10008 integer(kind=int32), public, parameter :: DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR = 10007 integer(kind=int32), public, parameter :: DIFFEQ_MATRIX_SIZE_ERROR = 10002 integer(kind=int32), public, parameter :: DIFFEQ_MEMORY_ALLOCATION_ERROR = 10000 integer(kind=int32), public, parameter :: DIFFEQ_MISSING_ARGUMENT_ERROR = 10005 integer(kind=int32), public, parameter :: DIFFEQ_NULL_POINTER_ERROR = 10001 integer(kind=int32), public, parameter :: DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR = 10006 Subroutines public  subroutine report_array_size_error (err, fcn, varname, expsize, actsize) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: expsize The expected size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. public  subroutine report_excessive_integration_steps (err, fcn, n, x) Reports an error when an excessive  amount integration steps have been \ntaken. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of integration steps. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. public  subroutine report_excessive_iterations (err, fcn, n, x) Reports an error when excessive iterations have been made. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: n The number of iterations. real(kind=real64), intent(in) :: x The value of the independent variable at which the error occurred. public  subroutine report_matrix_size_error (err, fcn, varname, exprow, expcol, actrow, actcol) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: exprow The expected number of rows. integer(kind=int32), intent(in) :: expcol The expected number of columns. integer(kind=int32), intent(in) :: actrow The actual number of rows. integer(kind=int32), intent(in) :: actcol The actual number of columns. public  subroutine report_memory_error (err, fcn, flag) Reports a memory error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. integer(kind=int32), intent(in) :: flag The memory status flag. public  subroutine report_min_array_size_not_met (err, fcn, varname, minsize, actsize) Reports an error where the minimum array size was not met. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: varname The offending variable name. integer(kind=int32), intent(in) :: minsize The minimum size of the array. integer(kind=int32), intent(in) :: actsize The actual size of the array. public  subroutine report_missing_argument (err, fcn, arg) Reports a missing argument error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. character(len=*), intent(in) :: arg The name of the argument. public  subroutine report_missing_ode (err, fcn) Reports a missing ODE routine. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. public  subroutine report_step_size_too_small (err, fcn, x, h) Reports an error when the step size becomes too small. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fcn The name of the function or subroutine in which the error occurred. real(kind=real64), intent(in) :: x The value of the independent variable at which the step size error\noccurred. real(kind=real64), intent(in) :: h The step size value.","tags":"","loc":"module\\diffeq_errors.html"},{"title":"diffeq_implicit_runge_kutta – DIFFEQ","text":"Uses diffeq_errors diffeq_base iso_fortran_env linalg Contents Derived Types rosenbrock Derived Types type, public, extends( single_step_integrator ) :: rosenbrock Defines a 4th order Rosenbrock integrator. Read more… Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rbrk_attempt_step Subroutine Attempts an integration step for this integrator. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    oi_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    rbrk_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: get_is_fsal =>\n                    rbrk_get_is_fsal Function Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    rbrk_get_order Function Gets the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    rbrk_get_stage_count Function Gets the stage count for this integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n                    ,                  public\n                  :: interpolate =>\n                    rbrk_interp Subroutine Performs the interpolation. procedure\n                    ,                  public\n                  :: post_step_action =>\n                    rbrk_set_up_interp Subroutine Sets up the interpolation process as the post-step action. procedure\n                    ,                  public\n                  :: pre_step_action =>\n                    rbrk_form_matrix Subroutine Constructs the system matrix. procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n                    ,                  public\n                  :: solve =>\n                    ssi_ode_solver Subroutine Solves the supplied system of ODE's.","tags":"","loc":"module\\diffeq_implicit_runge_kutta.html"},{"title":"diffeq_rk853_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a101 a104 a105 a106 a107 a108 a109 a111 a1110 a114 a115 a116 a117 a118 a119 a121 a1210 a1211 a124 a125 a126 a127 a128 a129 a141 a1410 a1411 a1412 a1413 a147 a148 a149 a151 a1511 a1512 a1513 a1514 a156 a157 a158 a161 a1613 a1614 a1615 a166 a167 a168 a169 a21 a31 a32 a41 a43 a51 a53 a54 a61 a64 a65 a71 a74 a75 a76 a81 a84 a85 a86 a87 a91 a94 a95 a96 a97 a98 b1 b10 b11 b12 b6 b7 b8 b9 bhh1 bhh2 bhh3 c10 c11 c14 c15 c16 c2 c3 c4 c5 c6 c7 c8 c9 d41 d410 d411 d412 d413 d414 d415 d416 d46 d47 d48 d49 d51 d510 d511 d512 d513 d514 d515 d516 d56 d57 d58 d59 d61 d610 d611 d612 d613 d614 d615 d616 d66 d67 d68 d69 d71 d710 d711 d712 d713 d714 d715 d716 d76 d77 d78 d79 er1 er10 er11 er12 er6 er7 er8 er9 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a101 = 4.77662536438264365890433908527d-1 real(kind=real64), public, parameter :: a104 = -2.48811461997166764192642586468d0 real(kind=real64), public, parameter :: a105 = -5.90290826836842996371446475743d-1 real(kind=real64), public, parameter :: a106 = 2.12300514481811942347288949897d1 real(kind=real64), public, parameter :: a107 = 1.52792336328824235832596922938d1 real(kind=real64), public, parameter :: a108 = -3.32882109689848629194453265587d1 real(kind=real64), public, parameter :: a109 = -2.03312017085086261358222928593d-2 real(kind=real64), public, parameter :: a111 = -9.3714243008598732571704021658d-1 real(kind=real64), public, parameter :: a1110 = -3.0467644718982195003823669022d0 real(kind=real64), public, parameter :: a114 = 5.18637242884406370830023853209d0 real(kind=real64), public, parameter :: a115 = 1.09143734899672957818500254654d0 real(kind=real64), public, parameter :: a116 = -8.14978701074692612513997267357d0 real(kind=real64), public, parameter :: a117 = -1.85200656599969598641566180701d1 real(kind=real64), public, parameter :: a118 = 2.27394870993505042818970056734d1 real(kind=real64), public, parameter :: a119 = 2.49360555267965238987089396762d0 real(kind=real64), public, parameter :: a121 = 2.27331014751653820792359768449d0 real(kind=real64), public, parameter :: a1210 = 1.23605671757943030647266201528d1 real(kind=real64), public, parameter :: a1211 = 6.43392746015763530355970484046d-1 real(kind=real64), public, parameter :: a124 = -1.05344954667372501984066689879d1 real(kind=real64), public, parameter :: a125 = -2.00087205822486249909675718444d0 real(kind=real64), public, parameter :: a126 = -1.79589318631187989172765950534d1 real(kind=real64), public, parameter :: a127 = 2.79488845294199600508499808837d1 real(kind=real64), public, parameter :: a128 = -2.85899827713502369474065508674d0 real(kind=real64), public, parameter :: a129 = -8.87285693353062954433549289258d0 real(kind=real64), public, parameter :: a141 = 5.61675022830479523392909219681d-2 real(kind=real64), public, parameter :: a1410 = 1.5329179827876569731206322685d-1 real(kind=real64), public, parameter :: a1411 = 8.20105229563468988491666602057d-3 real(kind=real64), public, parameter :: a1412 = 7.56789766054569976138603589584d-3 real(kind=real64), public, parameter :: a1413 = -8.298d-3 real(kind=real64), public, parameter :: a147 = 2.53500210216624811088794765333d-1 real(kind=real64), public, parameter :: a148 = -2.46239037470802489917441475441d-1 real(kind=real64), public, parameter :: a149 = -1.24191423263816360469010140626d-1 real(kind=real64), public, parameter :: a151 = 3.18346481635021405060768473261d-2 real(kind=real64), public, parameter :: a1511 = -1.08347328697249322858509316994d-4 real(kind=real64), public, parameter :: a1512 = 3.82571090835658412954920192323d-4 real(kind=real64), public, parameter :: a1513 = -3.40465008687404560802977114492d-4 real(kind=real64), public, parameter :: a1514 = 1.41312443674632500278074618366d-1 real(kind=real64), public, parameter :: a156 = 2.83009096723667755288322961402d-2 real(kind=real64), public, parameter :: a157 = 5.35419883074385676223797384372d-2 real(kind=real64), public, parameter :: a158 = -5.49237485713909884646569340306d-2 real(kind=real64), public, parameter :: a161 = -4.28896301583791923408573538692d-1 real(kind=real64), public, parameter :: a1613 = -1.39902416515901462129418009734d-3 real(kind=real64), public, parameter :: a1614 = 2.9475147891527723389556272149d0 real(kind=real64), public, parameter :: a1615 = -9.15095847217987001081870187138d0 real(kind=real64), public, parameter :: a166 = -4.69762141536116384314449447206d0 real(kind=real64), public, parameter :: a167 = 7.68342119606259904184240953878d0 real(kind=real64), public, parameter :: a168 = 4.06898981839711007970213554331d0 real(kind=real64), public, parameter :: a169 = 3.56727187455281109270669543021d-1 real(kind=real64), public, parameter :: a21 = 5.26001519587677318785587544488d-2 real(kind=real64), public, parameter :: a31 = 1.97250569845378994544595329183d-2 real(kind=real64), public, parameter :: a32 = 5.91751709536136983633785987549d-2 real(kind=real64), public, parameter :: a41 = 2.95875854768068491816892993775d-2 real(kind=real64), public, parameter :: a43 = 8.87627564304205475450678981324d-2 real(kind=real64), public, parameter :: a51 = 2.41365134159266685502369798665d-1 real(kind=real64), public, parameter :: a53 = -8.84549479328286085344864962717d-1 real(kind=real64), public, parameter :: a54 = 9.24834003261792003115737966543d-1 real(kind=real64), public, parameter :: a61 = 3.7037037037037037037037037037d-2 real(kind=real64), public, parameter :: a64 = 1.70828608729473871279604482173d-1 real(kind=real64), public, parameter :: a65 = 1.25467687566822425016691814123d-1 real(kind=real64), public, parameter :: a71 = 3.7109375d-2 real(kind=real64), public, parameter :: a74 = 1.70252211019544039314978060272d-1 real(kind=real64), public, parameter :: a75 = 6.02165389804559606850219397283d-2 real(kind=real64), public, parameter :: a76 = -1.7578125d-2 real(kind=real64), public, parameter :: a81 = 3.70920001185047927108779319836d-2 real(kind=real64), public, parameter :: a84 = 1.70383925712239993810214054705d-1 real(kind=real64), public, parameter :: a85 = 1.07262030446373284651809199168d-1 real(kind=real64), public, parameter :: a86 = -1.53194377486244017527936158236d-2 real(kind=real64), public, parameter :: a87 = 8.27378916381402288758473766002d-3 real(kind=real64), public, parameter :: a91 = 6.24110958716075717114429577812d-1 real(kind=real64), public, parameter :: a94 = -3.36089262944694129406857109825d0 real(kind=real64), public, parameter :: a95 = -8.68219346841726006818189891453d-1 real(kind=real64), public, parameter :: a96 = 2.75920996994467083049415600797d1 real(kind=real64), public, parameter :: a97 = 2.01540675504778934086186788979d1 real(kind=real64), public, parameter :: a98 = -4.34898841810699588477366255144d1 real(kind=real64), public, parameter :: b1 = 5.42937341165687622380535766363d-2 real(kind=real64), public, parameter :: b10 = -1.52160949662516078556178806805d-1 real(kind=real64), public, parameter :: b11 = 2.01365400804030348374776537501d-1 real(kind=real64), public, parameter :: b12 = 4.47106157277725905176885569043d-2 real(kind=real64), public, parameter :: b6 = 4.45031289275240888144113950566d0 real(kind=real64), public, parameter :: b7 = 1.89151789931450038304281599044d0 real(kind=real64), public, parameter :: b8 = -5.8012039600105847814672114227d0 real(kind=real64), public, parameter :: b9 = 3.1116436695781989440891606237d-1 real(kind=real64), public, parameter :: bhh1 = 0.244094488188976377952755905512d0 real(kind=real64), public, parameter :: bhh2 = 0.733846688281611857341361741547d0 real(kind=real64), public, parameter :: bhh3 = 0.220588235294117647058823529412d-1 real(kind=real64), public, parameter :: c10 = 0.6d0 real(kind=real64), public, parameter :: c11 = 0.857142857142857142857142857142d0 real(kind=real64), public, parameter :: c14 = 0.1d0 real(kind=real64), public, parameter :: c15 = 0.2d0 real(kind=real64), public, parameter :: c16 = 0.777777777777777777777777777778d0 real(kind=real64), public, parameter :: c2 = 0.526001519587677318785587544488d-1 real(kind=real64), public, parameter :: c3 = 0.789002279381515978178381316732d-1 real(kind=real64), public, parameter :: c4 = 0.118350341907227396726757197510d0 real(kind=real64), public, parameter :: c5 = 0.281649658092772603273242802490d0 real(kind=real64), public, parameter :: c6 = 0.333333333333333333333333333333d0 real(kind=real64), public, parameter :: c7 = 0.25d0 real(kind=real64), public, parameter :: c8 = 0.307692307692307692307692307692d0 real(kind=real64), public, parameter :: c9 = 0.651282051282051282051282051282d0 real(kind=real64), public, parameter :: d41 = -0.84289382761090128651353491142d1 real(kind=real64), public, parameter :: d410 = -0.87139158377797299206789907490d0 real(kind=real64), public, parameter :: d411 = 0.22404374302607882758541771650d1 real(kind=real64), public, parameter :: d412 = 0.63157877876946881815570249290d0 real(kind=real64), public, parameter :: d413 = -0.88990336451333310820698117400d-1 real(kind=real64), public, parameter :: d414 = 0.18148505520854727256656404962d2 real(kind=real64), public, parameter :: d415 = -0.91946323924783554000451984436d1 real(kind=real64), public, parameter :: d416 = -0.44360363875948939664310572000d1 real(kind=real64), public, parameter :: d46 = 0.56671495351937776962531783590d0 real(kind=real64), public, parameter :: d47 = -0.30689499459498916912797304727d1 real(kind=real64), public, parameter :: d48 = 0.23846676565120698287728149680d1 real(kind=real64), public, parameter :: d49 = 0.21170345824450282767155149946d1 real(kind=real64), public, parameter :: d51 = 0.10427508642579134603413151009d2 real(kind=real64), public, parameter :: d510 = 0.77334326684722638389603898808d1 real(kind=real64), public, parameter :: d511 = -0.30674084731089398182061213626d2 real(kind=real64), public, parameter :: d512 = -0.93321305264302278729567221706d1 real(kind=real64), public, parameter :: d513 = 0.15697238121770843886131091075d2 real(kind=real64), public, parameter :: d514 = -0.31139403219565177677282850411d2 real(kind=real64), public, parameter :: d515 = -0.93529243588444783865713862664d1 real(kind=real64), public, parameter :: d516 = 0.35816841486394083752465898540d2 real(kind=real64), public, parameter :: d56 = 0.24228349177525818288430175319d3 real(kind=real64), public, parameter :: d57 = 0.16520045171727028198505394887d3 real(kind=real64), public, parameter :: d58 = -0.37454675472269020279518312152d3 real(kind=real64), public, parameter :: d59 = -0.22113666853125306036270938578d2 real(kind=real64), public, parameter :: d61 = 0.19985053242002433820987653617d2 real(kind=real64), public, parameter :: d610 = 0.68812326946963000169666922661d1 real(kind=real64), public, parameter :: d611 = -0.10006050966910838403183860980d1 real(kind=real64), public, parameter :: d612 = 0.77771377980534432092869265740d0 real(kind=real64), public, parameter :: d613 = -0.27782057523535084065932004339d1 real(kind=real64), public, parameter :: d614 = -0.60196695231264120758267380846d2 real(kind=real64), public, parameter :: d615 = 0.84320405506677161018159903784d2 real(kind=real64), public, parameter :: d616 = 0.11992291136182789328035130030d2 real(kind=real64), public, parameter :: d66 = -0.38703730874935176555105901742d3 real(kind=real64), public, parameter :: d67 = -0.18917813819516756882830838328d3 real(kind=real64), public, parameter :: d68 = 0.52780815920542364900561016686d3 real(kind=real64), public, parameter :: d69 = -0.11573902539959630126141871134d2 real(kind=real64), public, parameter :: d71 = -0.25693933462703749003312586129d2 real(kind=real64), public, parameter :: d710 = -0.37458323136451633156875139351d2 real(kind=real64), public, parameter :: d711 = 0.10409964950896230045147246184d3 real(kind=real64), public, parameter :: d712 = 0.29840293426660503123344363579d2 real(kind=real64), public, parameter :: d713 = -0.43533456590011143754432175058d2 real(kind=real64), public, parameter :: d714 = 0.96324553959188282948394950600d2 real(kind=real64), public, parameter :: d715 = -0.39177261675615439165231486172d2 real(kind=real64), public, parameter :: d716 = -0.14972683625798562581422125276d3 real(kind=real64), public, parameter :: d76 = -0.15418974869023643374053993627d3 real(kind=real64), public, parameter :: d77 = -0.23152937917604549567536039109d3 real(kind=real64), public, parameter :: d78 = 0.35763911791061412378285349910d3 real(kind=real64), public, parameter :: d79 = 0.93405324183624310003907691704d2 real(kind=real64), public, parameter :: er1 = 0.1312004499419488073250102996d-1 real(kind=real64), public, parameter :: er10 = 0.3341791187130174790297318841d0 real(kind=real64), public, parameter :: er11 = 0.8192320648511571246570742613d-1 real(kind=real64), public, parameter :: er12 = -0.2235530786388629525884427845d-1 real(kind=real64), public, parameter :: er6 = -0.1225156446376204440720569753d1 real(kind=real64), public, parameter :: er7 = -0.4957589496572501915214079952d0 real(kind=real64), public, parameter :: er8 = 0.1664377182454986536961530415d1 real(kind=real64), public, parameter :: er9 = -0.3503288487499736816886487290d0","tags":"","loc":"module\\diffeq_rk853_constants.html"},{"title":"diffeq_rosenbrock_constants – DIFFEQ","text":"Uses iso_fortran_env Contents Variables a21 a31 a32 a41 a42 a43 a51 a52 a53 a54 bet2p bet3p bet4p c2 c21 c3 c31 c32 c4 c41 c42 c43 c51 c52 c53 c54 c61 c62 c63 c64 c65 d1 d2 d21 d22 d23 d24 d25 d3 d31 d32 d33 d34 d35 d4 gam Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: a21 = 0.1544d1 real(kind=real64), public, parameter :: a31 = 0.9466785280815826d0 real(kind=real64), public, parameter :: a32 = 0.2557011698983284d0 real(kind=real64), public, parameter :: a41 = 0.3314825187068521d1 real(kind=real64), public, parameter :: a42 = 0.2896124015972201d1 real(kind=real64), public, parameter :: a43 = 0.9986419139977817d0 real(kind=real64), public, parameter :: a51 = 0.1221224509226641d1 real(kind=real64), public, parameter :: a52 = 0.6019134481288629d1 real(kind=real64), public, parameter :: a53 = 0.1253708332932087d2 real(kind=real64), public, parameter :: a54 = -0.6878860361058950d0 real(kind=real64), public, parameter :: bet2p = 0.0317d0 real(kind=real64), public, parameter :: bet3p = 0.0635d0 real(kind=real64), public, parameter :: bet4p = 0.3438d0 real(kind=real64), public, parameter :: c2 = 0.386d0 real(kind=real64), public, parameter :: c21 = -0.5668800000000000d1 real(kind=real64), public, parameter :: c3 = 0.21d0 real(kind=real64), public, parameter :: c31 = -0.2430093356833875d1 real(kind=real64), public, parameter :: c32 = -0.2063599157091915d0 real(kind=real64), public, parameter :: c4 = 0.63d0 real(kind=real64), public, parameter :: c41 = -0.1073529058151375d0 real(kind=real64), public, parameter :: c42 = -0.9594562251023355d1 real(kind=real64), public, parameter :: c43 = -0.2047028614809616d2 real(kind=real64), public, parameter :: c51 = 0.7496443313967647d1 real(kind=real64), public, parameter :: c52 = -0.1024680431464352d2 real(kind=real64), public, parameter :: c53 = -0.3399990352819905d2 real(kind=real64), public, parameter :: c54 = 0.1170890893206160d2 real(kind=real64), public, parameter :: c61 = 0.8083246795921522d1 real(kind=real64), public, parameter :: c62 = -0.7981132988064893d1 real(kind=real64), public, parameter :: c63 = -0.3152159432874371d2 real(kind=real64), public, parameter :: c64 = 0.1631930543123136d2 real(kind=real64), public, parameter :: c65 = -0.6058818238834054d1 real(kind=real64), public, parameter :: d1 = 0.25d0 real(kind=real64), public, parameter :: d2 = -0.1043d0 real(kind=real64), public, parameter :: d21 = 0.1012623508344586d2 real(kind=real64), public, parameter :: d22 = -0.7487995877610167d1 real(kind=real64), public, parameter :: d23 = -0.3480091861555747d2 real(kind=real64), public, parameter :: d24 = -0.7992771707568823d1 real(kind=real64), public, parameter :: d25 = 0.1025137723295662d1 real(kind=real64), public, parameter :: d3 = 0.1035d0 real(kind=real64), public, parameter :: d31 = -0.6762803392801253d0 real(kind=real64), public, parameter :: d32 = 0.6087714651680015d1 real(kind=real64), public, parameter :: d33 = 0.1643084320892478d2 real(kind=real64), public, parameter :: d34 = 0.2476722511418386d2 real(kind=real64), public, parameter :: d35 = -0.6594389125716872d1 real(kind=real64), public, parameter :: d4 = -0.3620000000000023d1 real(kind=real64), public, parameter :: gam = 0.25d0","tags":"","loc":"module\\diffeq_rosenbrock_constants.html"},{"title":"diffeq_runge_kutta – DIFFEQ","text":"Uses ferror diffeq_errors diffeq_base iso_fortran_env Contents Derived Types runge_kutta_23 runge_kutta_45 runge_kutta_853 Derived Types type, public, extends( single_step_integrator ) :: runge_kutta_23 The Bogacki-Shampine integrator (3rd order with an embedded 2nd order\nused for error estimation). Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rk23_attempt_step Subroutine Attempts an integration step for this integrator. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    oi_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    oi_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: get_is_fsal =>\n                    rk23_get_is_fsal Function Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    rk23_get_order Function Gets the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    rk23_get_stage_count Function Gets the stage count for this integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n                    ,                  public\n                  :: interpolate =>\n                    rk23_interp Subroutine Performs the interpolation. procedure\n                    ,                  public\n                  :: post_step_action =>\n                    rk23_set_up_interp Subroutine Sets up the interpolation process as the post-step action. procedure\n                    ,                  public\n                  :: pre_step_action =>\n                    rk23_pre_step Subroutine Performs any pre-step actions. procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n                    ,                  public\n                  :: solve =>\n                    ssi_ode_solver Subroutine Solves the supplied system of ODE's. type, public, extends( single_step_integrator ) :: runge_kutta_45 The Dormand-Prince, Runge-Kutta integrator (5th order, with an \nembedded 4th order used for error estimation). Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rk45_attempt_step Subroutine Attempts an integration step for this integrator. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    oi_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    oi_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: get_is_fsal =>\n                    rk45_get_is_fsal Function Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    rk45_get_order Function Gets the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    rk45_get_stage_count Function Gets the stage count for this integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n                    ,                  public\n                  :: interpolate =>\n                    rk45_interp Subroutine Performs the interpolation. procedure\n                    ,                  public\n                  :: post_step_action =>\n                    rk45_set_up_interp Subroutine Sets up the interpolation process as the post-step action. procedure\n                    ,                  public\n                  :: pre_step_action =>\n                    rk45_pre_step Subroutine Performs any pre-step actions. procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n                    ,                  public\n                  :: solve =>\n                    ssi_ode_solver Subroutine Solves the supplied system of ODE's. type, public, extends( single_step_integrator ) :: runge_kutta_853 An 8th order Runge-Kutta integrator with embedded 5th and 3rd order\nsolutions for error estimation. Type-Bound Procedures procedure\n                    ,                  public\n                  :: append_to_buffer =>\n                    oi_append_to_buffer Subroutine Appends the supplied solution point to the internal solution \nbuffer. procedure\n                    ,                  public\n                  :: attempt_step =>\n                    rk853_attempt_step Subroutine Attempts an integration step for this integrator. procedure\n                    ,                  public\n                  :: clear_buffer =>\n                    oi_clear_buffer Subroutine Clears the contents of the buffer. procedure\n                    ,                  public\n                  :: compute_error_norm =>\n                    rk853_estimate_error Function Computes the norm of the scaled error estimate. procedure\n                    ,                  public\n                  :: estimate_inital_step_size =>\n                    oi_initial_step Subroutine Computes an estimate of an initial step size. procedure\n                    ,                  public\n                  :: estimate_next_step_size =>\n                    oi_next_step Function Estimates the next step size. procedure\n                    ,                  public\n                  :: get_absolute_tolerance =>\n                    oi_get_abs_tol Function Gets the absolute error tolerance. procedure\n                    ,                  public\n                  :: get_allow_overshoot =>\n                    oi_get_allow_overshoot Function Gets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: get_is_fsal =>\n                    rk853_get_is_fsal Function Gets a logical parameter stating if this is a first-same-as-last\n(FSAL) integrator. procedure\n                    ,                  public\n                  :: get_maximum_step_size =>\n                    oi_get_max_step Function Gets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: get_minimum_step_size =>\n                    oi_get_min_step Function Gets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: get_order =>\n                    rk853_get_order Function Gets the order of the integrator. procedure\n                    ,                  public\n                  :: get_relative_tolerance =>\n                    oi_get_abs_tol Function Gets the relative error tolerance. procedure\n                    ,                  public\n                  :: get_solution =>\n                    oi_get_solution Function Returns the solution computed by the integrator. procedure\n                    ,                  public\n                  :: get_stage_count =>\n                    rk853_get_stage_count Function Gets the stage count for this integrator. procedure\n                    ,                  public\n                  :: get_step_limit =>\n                    oi_get_step_limit Function Gets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: get_step_size_control_parameter =>\n                    oi_get_control_parameter Function Gets the step size PI control parameter. procedure\n                    ,                  public\n                  :: get_step_size_factor =>\n                    oi_get_safety_factor Function Gets the step size safety factor. procedure\n                    ,                  public\n                  :: interpolate =>\n                    rk853_interp Subroutine Performs the interpolation. procedure\n                    ,                  public\n                  :: post_step_action =>\n                    rk853_set_up_interp Subroutine Sets up the interpolation process as the post-step action. procedure\n                    ,                  public\n                  :: pre_step_action =>\n                    rk853_pre_step Subroutine Performs any pre-step actions. Read more… procedure\n                    ,                  public\n                  :: set_absolute_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the absolute error tolerance. procedure\n                    ,                  public\n                  :: set_allow_overshoot =>\n                    oi_set_allow_overshoot Subroutine Sets a value determining if the solver is allowed to overshoot \nthe final value in the integration range. procedure\n                    ,                  public\n                  :: set_maximum_step_size =>\n                    oi_set_max_step Subroutine Sets the magnitude of the maximum allowed step size. procedure\n                    ,                  public\n                  :: set_minimum_step_size =>\n                    oi_set_min_step Subroutine Sets the magnitude of the minimum allowed step size. procedure\n                    ,                  public\n                  :: set_relative_tolerance =>\n                    oi_set_abs_tol Subroutine Sets the relative error tolerance. procedure\n                    ,                  public\n                  :: set_step_limit =>\n                    oi_set_step_limit Subroutine Sets the limit on the number of integration steps. procedure\n                    ,                  public\n                  :: set_step_size_control_parameter =>\n                    oi_set_control_parameter Subroutine Sets the step size PI control parameter. procedure\n                    ,                  public\n                  :: set_step_size_factor =>\n                    oi_set_safety_factor Subroutine Sets the step size safety factor. procedure\n                    ,                  public\n                  :: solve =>\n                    ssi_ode_solver Subroutine Solves the supplied system of ODE's.","tags":"","loc":"module\\diffeq_runge_kutta.html"},{"title":"diffeq.f90 – DIFFEQ","text":"Contents Modules diffeq Source Code diffeq.f90 Source Code !> @brief This module contains several ODE solvers and associated types. module diffeq use iso_fortran_env use diffeq_base use diffeq_runge_kutta use diffeq_implicit_runge_kutta implicit none private public :: ode public :: ode_jacobian public :: ode_mass_matrix public :: ode_container public :: ode_integrator public :: ode_solver public :: ode_integer_inquiry public :: attempt_single_step public :: get_single_step_logical_parameter public :: single_step_post_step_routine public :: single_step_pre_step_routine public :: single_step_interpolate public :: single_step_integrator public :: runge_kutta_45 public :: runge_kutta_23 public :: runge_kutta_853 public :: rosenbrock end module","tags":"","loc":"sourcefile\\diffeq.f90.html"},{"title":"diffeq_base.f90 – DIFFEQ","text":"Contents Modules diffeq_base Source Code diffeq_base.f90 Source Code module diffeq_base !! A collection of base types for the DIFFEQ library. use iso_fortran_env use diffeq_errors use ferror implicit none private public :: ode public :: ode_jacobian public :: ode_mass_matrix public :: ode_container public :: ode_integrator public :: ode_solver public :: ode_integer_inquiry public :: attempt_single_step public :: get_single_step_logical_parameter public :: single_step_post_step_routine public :: single_step_pre_step_routine public :: single_step_interpolate public :: single_step_integer_inquiry public :: single_step_integrator ! ------------------------------------------------------------------------------ interface subroutine ode ( x , y , dydx , args ) !! An interface to a routine containing a system of first order !! ODE's to integrate. use iso_fortran_env real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:) :: dydx !! An N-element array where the derivative values will be !! written. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the routine. end subroutine subroutine ode_jacobian ( x , y , jac , args ) !! An interface to a routine capable of computing the Jacobian !! matrix of a system of first order ODE's. use iso_fortran_env real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:,:) :: jac !! An M-by-N matrix where the Jacobian will be written. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the routine. end subroutine subroutine ode_mass_matrix ( x , y , m , args ) !! An interface to a routine capable of computing a mass matrix !! for a system of differential equations. use iso_fortran_env real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current values of the !! dependent variables. real ( real64 ), intent ( out ), dimension (:,:) :: m !! An N-by-N matrix where the class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the routine. end subroutine end interface ! ------------------------------------------------------------------------------ type ode_container !! A container for the routine containing the ODEs to integrate. logical , private :: m_massDependent = . true . ! A value determining if the mass matrix is state dependent such ! that it must be recomputed at each step. real ( real64 ), private , allocatable , dimension (:) :: m_jwork ! Jacobian calculation workspace array. real ( real64 ), private :: m_fdStep = sqrt ( epsilon ( 1.0d0 )) ! Finite difference step size. procedure ( ode ), pointer , public , nopass :: fcn => null () !! A pointer to the routine containing the ODEs to integrate. procedure ( ode_jacobian ), pointer , public , nopass :: & jacobian => null () !! A pointer to the routine containing the analytical Jacobian. !! If supplied, this routine is utilized; however, if null, a finite !! difference approximation is utilized. procedure ( ode_mass_matrix ), pointer , public , nopass :: & mass_matrix => null () !! A pointer to the routine containing the mass matrix for the !! system.  If set to null (the default), an identity mass matrix !! will be assumed. contains procedure , private :: allocate_workspace => oc_alloc_workspace procedure , public :: get_finite_difference_step => oc_get_fd_step procedure , public :: set_finite_difference_step => oc_set_fd_step procedure , public :: get_is_mass_matrix_dependent => & oc_get_is_mass_dependent procedure , public :: set_is_mass_matrix_dependent => & oc_set_is_mass_dependent procedure , public :: compute_jacobian => oc_jacobian procedure , public :: get_is_ode_defined => oc_get_is_ode_defined end type ! ------------------------------------------------------------------------------ type , abstract :: ode_integrator !! The most basic ODE integrator object capable of integrating !! systems of ODE's. real ( real64 ), private , allocatable , dimension (:,:) :: m_buffer ! The internal solution buffer. integer ( int32 ), private :: m_bufferCount = 0 ! The number of solution points stored in the buffer. real ( real64 ), private :: m_abstol = 1.0d-6 ! The absolute tolerance value applied to each equation. real ( real64 ), private :: m_reltol = 1.0d-6 ! The relative tolerance value applied to each equation. real ( real64 ), private :: m_minStep = 1.0d1 * epsilon ( 1.0d0 ) ! The minimum allowable step size. real ( real64 ), private :: m_maxStep = huge ( 1.0d0 ) ! The maximum allowable step size. real ( real64 ), private :: m_safetyFactor = 0.9d0 ! The step size safety factor. real ( real64 ), private :: m_beta = 0.0d0 ! PI step size controller exponent. logical , private :: m_reject = . false . ! Internal variable tracking step size acceptance. integer ( int32 ), private :: m_stepLimit = 1000000 ! A limit on the total number of integration steps.  Exceeding this ! value may indicate that a different integrator should be ! considered.  Either that, or this is a really large-sized ! problem that is being solved. logical , private :: m_allowOvershoot = . true . ! True if the solver is allowed to overshoot the final value and ! interpolate back.  False, if the solver must terminate on the ! final value. contains procedure ( ode_solver ), public , pass , deferred :: solve !! Solves the supplied system of ODE's. procedure ( ode_integer_inquiry ), public , pass , deferred :: get_order !! Returns the order of the integrator. procedure , public :: append_to_buffer => oi_append_to_buffer !! Appends the supplied solution point to the internal solution !! buffer. procedure , public :: get_solution => oi_get_solution !! Returns the solution computed by the integrator. procedure , public :: clear_buffer => oi_clear_buffer !! Clears the contents of the buffer. procedure , public :: get_absolute_tolerance => oi_get_abs_tol !! Gets the absolute error tolerance. procedure , public :: set_absolute_tolerance => oi_set_abs_tol !! Sets the absolute error tolerance. procedure , public :: get_relative_tolerance => oi_get_abs_tol !! Gets the relative error tolerance. procedure , public :: set_relative_tolerance => oi_set_abs_tol !! Sets the relative error tolerance. procedure , public :: compute_error_norm => oi_estimate_error !! Computes the norm of the scaled error estimate. procedure , public :: get_minimum_step_size => oi_get_min_step !! Gets the magnitude of the minimum allowed step size. procedure , public :: set_minimum_step_size => oi_set_min_step !! Sets the magnitude of the minimum allowed step size. procedure , public :: get_maximum_step_size => oi_get_max_step !! Gets the magnitude of the maximum allowed step size. procedure , public :: set_maximum_step_size => oi_set_max_step !! Sets the magnitude of the maximum allowed step size. procedure , public :: get_step_size_factor => oi_get_safety_factor !! Gets the step size safety factor. procedure , public :: set_step_size_factor => oi_set_safety_factor !! Sets the step size safety factor. procedure , public :: get_step_size_control_parameter => & oi_get_control_parameter !! Gets the step size PI control parameter. procedure , public :: set_step_size_control_parameter => & oi_set_control_parameter !! Sets the step size PI control parameter. procedure , public :: estimate_next_step_size => oi_next_step !! Estimates the next step size. procedure , public :: estimate_inital_step_size => oi_initial_step !! Computes an estimate of an initial step size. procedure , public :: get_step_limit => oi_get_step_limit !! Gets the limit on the number of integration steps. procedure , public :: set_step_limit => oi_set_step_limit !! Sets the limit on the number of integration steps. procedure , public :: get_allow_overshoot => oi_get_allow_overshoot !! Gets a value determining if the solver is allowed to overshoot !! the final value in the integration range. procedure , public :: set_allow_overshoot => oi_set_allow_overshoot !! Sets a value determining if the solver is allowed to overshoot !! the final value in the integration range. end type interface subroutine ode_solver ( this , sys , x , iv , args , err ) !! Solves the supplied system of ODE's. use iso_fortran_env use ferror import ode_integrator import ode_container class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array, of at least 2 values, defining at a minimum !! the starting and ending values of the independent variable !! integration range.  If more than two values are specified, !! the integration results will be returned at the supplied !! values. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is !!      defined. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than !!      2 values given in the independent variable array x. end subroutine pure function ode_integer_inquiry ( this ) result ( rst ) !! Returns an integer value from the ode_integrator object. use iso_fortran_env import ode_integrator class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. integer ( int32 ) :: rst !! The requested value. end function end interface ! ------------------------------------------------------------------------------ type , abstract , extends ( ode_integrator ) :: single_step_integrator !! The most basic, single-step integrator object capable of integrating !! systems of ODE's. contains procedure ( attempt_single_step ), public , pass , deferred :: attempt_step !! Attempts an integration step for a single-step integrator. procedure ( get_single_step_logical_parameter ), public , pass , & deferred :: get_is_fsal !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. procedure ( single_step_post_step_routine ), public , pass , deferred :: & post_step_action !! Performs actions such as setting up interpolation after !! completion of a successful integration step. procedure ( single_step_interpolate ), public , pass , deferred :: & interpolate !! Performs an interpolation to estimate the solution at the !! requested point. procedure ( single_step_pre_step_routine ), public , pass , deferred :: & pre_step_action !! Provides a routine for performing any actions, such as setting !! up Jacobian calculations. procedure ( single_step_integer_inquiry ), public , pass , deferred :: & get_stage_count !! Gets the number of stages used by the integrator. procedure , public :: solve => ssi_ode_solver !! Solves the supplied system of ODE's. end type interface subroutine attempt_single_step ( this , sys , h , x , y , f , yn , fn , yerr , k , args ) use iso_fortran_env import single_step_integrator import ode_container !! Attempts an integration step for a single-step integrator. class ( single_step_integrator ), intent ( inout ) :: this !! The single_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where this routine will write the next !! solution estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: fn !! An N-element array where this routine will write the next !! derivative estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: yerr !! An N-element array where this routine will write an estimate !! of the error in each equation. real ( real64 ), intent ( out ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each !! stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. end subroutine pure function get_single_step_logical_parameter ( this ) result ( rst ) !! Returns a logical parameter from a single_step_integrator object. import single_step_integrator class ( single_step_integrator ), intent ( in ) :: this !! The single_step_integrator object. logical :: rst !! The parameter. end function subroutine single_step_post_step_routine ( this , sys , dense , x , xn , y , & yn , f , fn , k , args ) !! Provides a routine for performing any actions, such as setting !! up interpolation, after successful completion of a step. use iso_fortran_env import single_step_integrator import ode_container class ( single_step_integrator ), intent ( inout ) :: this !! The single_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. logical , intent ( in ) :: dense !! Determines if dense output is requested (true); else, false. real ( real64 ), intent ( in ) :: x !! The previous value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the solution at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the derivatives at x. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each !! stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. end subroutine subroutine single_step_interpolate ( this , x , xn , yn , fn , xn1 , yn1 , & fn1 , y ) !! Provides a routine for interpolation. use iso_fortran_env import single_step_integrator class ( single_step_integrator ), intent ( in ) :: this !! The single_step_integrator object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which to compute !! the interpolation. real ( real64 ), intent ( in ) :: xn !! The previous value of the independent variable at which the !! solution is computed. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( in ) :: xn1 !! The value of the independent variable at xn + h. real ( real64 ), intent ( in ), dimension (:) :: yn1 !! An N-element array containing the solution at xn + h. real ( real64 ), intent ( in ), dimension (:) :: fn1 !! An N-element array containing the derivatives at xn + h. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where this routine will write the !! solution values interpolated at x. end subroutine subroutine single_step_pre_step_routine ( this , prevs , sys , h , x , y , f , & args , err ) !! Provides a routine for performing any actions, such as setting !! up Jacobian calculations. use iso_fortran_env use ferror import single_step_integrator import ode_container class ( single_step_integrator ), intent ( inout ) :: this !! The single_step_integrator object. logical , intent ( in ) :: prevs !! Defines the status of the previous step.  The value is true !! if the previous step was successful; else, false if the !! previous step failed. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. end subroutine pure function single_step_integer_inquiry ( this ) result ( rst ) !! Gets an integer from the integrator. use iso_fortran_env import single_step_integrator class ( single_step_integrator ), intent ( in ) :: this !! The single_step_integrator object. integer ( int32 ) :: rst !! The integer value. end function end interface ! ------------------------------------------------------------------------------    ! TO DO: multi-step integrator contains ! ****************************************************************************** ! ODE_CONTAINER ROUTINES ! ------------------------------------------------------------------------------ pure function oc_get_fd_step ( this ) result ( rst ) !! Gets the size of the step to use for the finite difference !! calculations used to estimate the Jacobian. class ( ode_container ), intent ( in ) :: this !! The ode_container object. real ( real64 ) :: rst !! The step size. rst = this % m_fdStep end function ! -------------------- subroutine oc_set_fd_step ( this , x ) !! Sets the size of the step to use for the finite difference !! calculations used to estimate the Jacobian. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. real ( real64 ), intent ( in ) :: x !! The step size. this % m_fdStep = x end subroutine ! ------------------------------------------------------------------------------ pure function oc_get_is_mass_dependent ( this ) result ( rst ) !! Gets a value determining if the mass matrix is state-dependent !! such that it requires updating at every integration step. class ( ode_container ), intent ( in ) :: this !! The ode_container object. logical :: rst !! True if the mass matrix is state-dependent such that it !! requires updating at each integration step; else, false if the !! mass matrix is not state-dependent and can be treated as constant !! for all integration steps. rst = this % m_massDependent end function ! -------------------- subroutine oc_set_is_mass_dependent ( this , x ) !! Sets a value determining if the mass matrix is state-dependent !! such that it requires updating at every integration step. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. logical :: x !! True if the mass matrix is state-dependent such that it !! requires updating at each integration step; else, false if the !! mass matrix is not state-dependent and can be treated as constant !! for all integration steps. this % m_massDependent = x end subroutine ! ------------------------------------------------------------------------------ subroutine oc_jacobian ( this , x , y , jac , args , err ) !! Computes the Jacobian matrix for the system of ODEs.  If !! a routine is provided with an analytical Jacobian, the supplied !! routine is utilized; else, the Jacobian is estimated via a forward !! difference approximation. class ( ode_container ), intent ( inout ) :: this !! The ode_container object. real ( real64 ), intent ( in ) :: x !! The current independent variable value. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current dependent !! variable values. real ( real64 ), intent ( out ), dimension (:,:) :: jac !! An N-by-N matrix where the Jacobian will be written. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a memory !!      allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is defined, !!      and the calculation is being performed by finite differences. !! !!  - DIFFEQ_MATRIX_SIZE_ERROR: Occurs if jac is not N-by-N. ! Local Variables integer ( int32 ) :: i , ndof real ( real64 ) :: h class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ndof = size ( y ) h = this % get_finite_difference_step () ! Input Checking if ( size ( jac , 1 ) /= ndof . or . size ( jac , 2 ) /= ndof ) then call report_matrix_size_error ( errmgr , \"oc_jacobian\" , \"jac\" , & ndof , ndof , size ( jac , 1 ), size ( jac , 2 )) return end if ! Use a user-defined routine, and then be done if ( associated ( this % jacobian )) then call this % jacobian ( x , y , jac , args ) return end if ! Allocate workspace.  No action is taken if the proper workspace is ! already allocated. call this % allocate_workspace ( ndof , errmgr ) if ( errmgr % has_error_occurred ()) return ! Finite Difference Approximation ! J(i,j) = df(i) / dy(j) this % m_jwork ( 1 : ndof ) = y call this % fcn ( x , y , this % m_jwork ( ndof + 1 :), args ) do i = 1 , ndof this % m_jwork ( i ) = this % m_jwork ( i ) + h call this % fcn ( x , this % m_jwork ( 1 : ndof ), jac (:, i ), args ) jac (:, i ) = ( jac (:, i ) - this % m_jwork ( ndof + 1 :)) / h this % m_jwork ( i ) = y ( i ) end do ! End return end subroutine ! ------------------------------------------------------------------------------ subroutine oc_alloc_workspace ( this , ndof , err ) ! Use to allocate internal workspaces.  This routine only takes action ! if the workspace array(s) are not sized properly for the application. class ( ode_container ), intent ( inout ) :: this ! The ode_container object. integer ( int32 ), intent ( in ) :: ndof ! The number of degrees of freedom. class ( errors ), intent ( inout ) :: err ! The error handling object. ! Local Variables integer ( int32 ) :: flag ! Jacobian Workspace Allocation if ( allocated ( this % m_jwork )) then if ( size ( this % m_jwork ) /= 2 * ndof ) then deallocate ( this % m_jwork ) allocate ( this % m_jwork ( 2 * ndof ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) then call report_memory_error ( err , \"oc_alloc_workspace\" , flag ) return end if end if else allocate ( this % m_jwork ( 2 * ndof ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) then call report_memory_error ( err , \"oc_alloc_workspace\" , flag ) return end if end if ! End return end subroutine ! ------------------------------------------------------------------------------ function oc_get_is_ode_defined ( this ) result ( rst ) !! Gets a logical value determining if the ODE routine has been defined. class ( ode_container ), intent ( in ) :: this !! The ode_container object. logical :: rst !! True if the ODE routine has been defined; else, false. rst = associated ( this % fcn ) end function ! ****************************************************************************** ! ODE_INTEGRATOR ROUTINES ! ------------------------------------------------------------------------------ subroutine oi_append_to_buffer ( this , x , y , err ) !! Appends the supplied solution point to the internal solution buffer. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The independent variable value. real ( real64 ), intent ( in ), dimension (:) :: y !! The values of the dependent variables corresponding to x. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. ! Parameters integer ( int32 ), parameter :: buffer_size = 1000 ! Local Variables integer ( int32 ) :: i , start , m , n , neqn , flag real ( real64 ), allocatable , dimension (:,:) :: copy class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( allocated ( this % m_buffer )) then neqn = size ( this % m_buffer , 2 ) - 1 else neqn = size ( y ) end if n = neqn + 1 start = this % m_bufferCount + 1 ! Input Checking if ( size ( y ) /= neqn ) then call report_array_size_error ( errmgr , \"oi_append_to_buffer\" , \"y\" , neqn , & size ( y )) return end if ! Allocate memory if necessary if (. not . allocated ( this % m_buffer )) then allocate ( this % m_buffer ( buffer_size , n ), stat = flag ) if ( flag /= 0 ) go to 10 else m = size ( this % m_buffer , 1 ) if ( start == m + 1 ) then allocate ( copy ( m , n ), source = this % m_buffer , stat = flag ) if ( flag /= 0 ) go to 10 m = m + buffer_size deallocate ( this % m_buffer ) allocate ( this % m_buffer ( m , n ), stat = flag ) if ( flag /= 0 ) go to 10 this % m_buffer (: this % m_bufferCount ,:) = copy end if end if ! Store the result this % m_buffer ( start , 1 ) = x this % m_buffer ( start , 2 :) = y this % m_bufferCount = this % m_bufferCount + 1 ! End return ! Memory Error Handler 10 continue call report_memory_error ( errmgr , \"oi_append_to_buffer\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_solution ( this ) result ( rst ) !! Returns the solution computed by the integrator stored as a matrix with !! the first column containing the values of the independent variable at !! which the solution was computed.  The remaining columns contain the !! solutions for each of the integrated equations in the order in which they !! appear in the source routine.  Notice, the solve routine must be called !! before this routine. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting solution matrix. if ( allocated ( this % m_buffer )) then rst = this % m_buffer (: this % m_bufferCount ,:) else allocate ( rst ( 0 , 0 )) end if end function ! ------------------------------------------------------------------------------ subroutine oi_clear_buffer ( this ) !! Clears the contents of the buffer. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. ! Clear the buffer if ( allocated ( this % m_buffer )) deallocate ( this % m_buffer ) this % m_bufferCount = 0 end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_abs_tol ( this ) result ( rst ) !! Gets the absolute error tolerance. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The tolerance value. rst = this % m_abstol end function ! -------------------- subroutine oi_set_abs_tol ( this , x ) !! Sets the absolute error tolerance. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_abstol = x end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_rel_tol ( this ) result ( rst ) !! Gets the relative error tolerance. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The tolerance value. rst = this % m_reltol end function ! -------------------- subroutine oi_set_rel_tol ( this , x ) !! Sets the relative error tolerance. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_reltol = x end subroutine ! ------------------------------------------------------------------------------ pure function oi_estimate_error ( this , y , yest , yerr ) result ( rst ) !! Computes the norm of the scaled error estimate.  A value less than one !! indicates a successful step.  A value greater than one suggests that the !! results do not meet the requested tolerances. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ), dimension (:) :: y !! The previously accepted solution array (N-element). real ( real64 ), intent ( in ), dimension ( size ( y )) :: yest !! An N-element array containing the next solution point estimate. real ( real64 ), intent ( in ), dimension ( size ( y )) :: yerr !! An N-element array containing the estimate of error for each !! equation. real ( real64 ) :: rst !! The norm of the scaled error. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: sf , atol , rtol ! Initialization n = size ( y ) atol = this % get_absolute_tolerance () rtol = this % get_relative_tolerance () ! Process rst = 0.0d0 do i = 1 , n sf = atol + rtol * max ( abs ( y ( i )), abs ( yest ( i ))) rst = rst + ( yerr ( i ) / sf ) ** 2 end do rst = sqrt ( rst / n ) end function ! ------------------------------------------------------------------------------ pure function oi_get_min_step ( this ) result ( rst ) !! Gets the magnitude of the minimum allowed step size. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The step size limit. rst = this % m_minStep end function ! -------------------- subroutine oi_set_min_step ( this , x ) !! Sets the magnitude of the minimum allowed step size. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The step size limit. this % m_minStep = abs ( x ) end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_max_step ( this ) result ( rst ) !! Gets the magnitude of the maximum allowed step size. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The step size limit. rst = this % m_maxStep end function ! -------------------- subroutine oi_set_max_step ( this , x ) !! Sets the magnitude of the maximum allowed step size. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The step size limit. this % m_maxStep = abs ( x ) end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_safety_factor ( this ) result ( rst ) !! Gets the safety factor (step size multiplier) used to provide a measure !! of control to the step size estimate such that  h_{new} = f_{s} h , !! where  f_{s}  is this safety factor. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The safety factor. rst = this % m_safetyFactor end function ! -------------------- subroutine oi_set_safety_factor ( this , x ) !! Sets the safety factor (step size multiplier) used to provide a measure !! of control to the step size estimate such that  h_{new} = f_{s} h , !! where  f_{s}  is this safety factor. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The safety factor. this % m_safetyFactor = x end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_control_parameter ( this ) result ( rst ) !! Gets the step size control parameter  \\beta  used for PI control of !! the step size.  A value of 0 provides a default step size controller !! (non-PI); however, a nonzero value of  \\beta  provides PI control !! that improves stability, but comes with a potential for efficiency loss. !! A good estimate for a starting point for this parameter is  \\beta = !! \\frac{0.4}{k}  where  k  is the order of the integrator. !! !! The PI controller for step size is defined as follows. !!  h_{n+1} = f_{s} h_{n} e_{n}&#94;{-\\alpha} e_{n-1}&#94;{\\beta}  class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. real ( real64 ) :: rst !! The control parameter. rst = this % m_beta end function ! -------------------- subroutine oi_set_control_parameter ( this , x ) !! Sets the step size control parameter  \\beta  used for PI control of !! the step size.  A value of 0 provides a default step size controller !! (non-PI); however, a nonzero value of  \\beta  provides PI control !! that improves stability, but comes with a potential for efficiency loss. !! A good estimate for a starting point for this parameter is  \\beta = !! \\frac{0.4}{k}  where  k  is the order of the integrator. !! !! The PI controller for step size is defined as follows. !!  h_{n+1} = f_{s} h_{n} e_{n}&#94;{-\\alpha} e_{n-1}&#94;{\\beta}  class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: x !! The control parameter this % m_beta = x end subroutine ! ------------------------------------------------------------------------------ function oi_next_step ( this , e , eold , h , x , err ) result ( rst ) !! Estimates the next step size based upon the current and previous error !! estimates. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. real ( real64 ), intent ( in ) :: e !! The norm of the current scaled error estimate. real ( real64 ), intent ( inout ) :: eold !! The norm of the previous step's scaled error estimate.  On output, !! this variable is updated. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current independent variable value. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size !!      becomes too small in magnitude. real ( real64 ) :: rst !! The new step size estimate. ! Parameters real ( real64 ), parameter :: minscale = 2.0d-1 real ( real64 ), parameter :: maxscale = 1.0d1 ! Local Variables integer ( int32 ) :: k real ( real64 ) :: alpha , beta , fs , maxstep , minstep , scale class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if k = this % get_order () beta = this % get_step_size_control_parameter () alpha = 1.0d0 / k - 0.75d0 * beta maxstep = this % get_maximum_step_size () minstep = this % get_minimum_step_size () fs = this % get_step_size_factor () ! Process if ( e <= 1.0d0 ) then ! The step met error tolerances and is acceptable if ( e == 0.0d0 ) then scale = maxscale else scale = fs * e ** ( - alpha ) * eold ** beta if ( scale < minscale ) scale = minscale if ( scale > maxscale ) scale = maxscale end if if ( this % m_reject ) then ! Don't let the step size increase if the last step was rejected rst = h * min ( scale , 1.0d0 ) else rst = h * scale end if eold = max ( e , 1.0d-4 ) this % m_reject = . false . else ! The step is rejected, reduce the step size scale = fs * e ** ( - alpha ) scale = max ( scale , minscale ) this % m_reject = . true . rst = h * scale end if ! Check the step size against limits if ( abs ( rst ) > maxstep ) then rst = sign ( maxstep , h ) end if if ( abs ( rst ) < minstep ) then call report_step_size_too_small ( errmgr , \"oi_next_step\" , x , rst ) return end if end function ! ------------------------------------------------------------------------------ subroutine oi_initial_step ( this , sys , xo , xf , yo , fo , h , args ) !! Computes an estimate of an initial step size. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. class ( ode_container ), intent ( in ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: xo !! The initial value of the independent variable. real ( real64 ), intent ( in ) :: xf !! The final value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: yo !! The initial values of the dependent variables (N-element). real ( real64 ), intent ( out ), dimension ( size ( yo )) :: fo !! An N-element array where the function values at xo will be written. real ( real64 ), intent ( out ) :: h !! The initial step size estimate. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables real ( real64 ) :: e , dx ! Use a very basic estimate of an initial step size.  The catch is that a ! single function evaluation must be made; however, this is likely needed ! in the first place, so no real extra work is necessary. dx = 0.1d0 * ( xf - xo ) e = max ( this % get_absolute_tolerance (), this % get_relative_tolerance ()) call sys % fcn ( xo , yo , fo , args ) h = 2.0d0 * e / norm2 ( fo ) h = min ( abs ( dx ), h ) h = sign ( h , dx ) end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_step_limit ( this ) result ( rst ) !! Gets the limit on the number of integration steps that may be taken !! before the solver terminates. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. integer ( int32 ) :: rst !! The step limit. rst = this % m_stepLimit end function ! -------------------- subroutine oi_set_step_limit ( this , x ) !! Sets the limit on the number of integration steps that may be taken !! before the solver terminates. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. integer ( int32 ), intent ( in ) :: x !! The step limit. this % m_stepLimit = x end subroutine ! ------------------------------------------------------------------------------ pure function oi_get_allow_overshoot ( this ) result ( rst ) !! Gets a value determining if the solver is allowed to overshoot the final !! value in the integration range. class ( ode_integrator ), intent ( in ) :: this !! The ode_integrator object. logical :: rst !! True if the solver can overshoot, and then interpolate to achieve the !! required final value; else, false thereby indicating the solver !! cannot overshoot. rst = this % m_allowOvershoot end function ! -------------------- subroutine oi_set_allow_overshoot ( this , x ) !! Sets a value determining if the solver is allowed to overshoot the final !! value in the integration range. class ( ode_integrator ), intent ( inout ) :: this !! The ode_integrator object. logical , intent ( in ) :: x !! True if the solver can overshoot, and then interpolate to achieve the !! required final value; else, false thereby indicating the solver !! cannot overshoot. this % m_allowOvershoot = x end subroutine ! ****************************************************************************** ! SINGLE-STEP INTEGRATOR ! ------------------------------------------------------------------------------ subroutine ssi_ode_solver ( this , sys , x , iv , args , err ) !! Solves the supplied system of ODE's. class ( single_step_integrator ), intent ( inout ) :: this !! The single_step_integrator object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: x !! An array of independent variable values at which to return the !! the solution to the ODE's. real ( real64 ), intent ( in ), dimension (:) :: iv !! An array containing the initial values for each ODE. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_MEMORY_ALLOCATION_ERROR: Occurs if there is a !!      memory allocation issue. !! !!  - DIFFEQ_NULL_POINTER_ERROR: Occurs if no ODE function is !!      defined. !! !!  - DIFFEQ_ARRAY_SIZE_ERROR: Occurs if there are less than !!      2 values given in the independent variable array x. ! Local Variables logical :: dense , success integer ( int32 ) :: i , j , n , neqn , flag , nsteps , nstages real ( real64 ) :: h , xo , xn , xmax , ei , eold real ( real64 ), allocatable , dimension (:) :: f , y , yn , fn , yerr , yi real ( real64 ), allocatable , dimension (:,:) :: k class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) success = . true . ! Input Checking if ( n < 2 ) then call report_array_size_error ( errmgr , \"ssi_ode_solver\" , \"x\" , 2 , n ) return end if if (. not . sys % get_is_ode_defined ()) then call report_missing_ode ( errmgr , \"ssi_ode_solver\" ) return end if ! Additional Initialization neqn = size ( iv ) xo = x ( 1 ) xmax = x ( n ) j = 2 eold = 1.0d-4 dense = ( n > 2 ) nsteps = this % get_step_limit () nstages = this % get_stage_count () ! Memory Allocations allocate ( & f ( neqn ), & y ( neqn ), & yn ( neqn ), & fn ( neqn ), & yerr ( neqn ), & k ( neqn , nstages ), & stat = flag & ) if ( flag == 0 . and . dense ) allocate ( yi ( neqn ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"ssi_ode_solver\" , flag ) return end if ! Estimate an initial step size ! ! Outputs: ! - f: Value of the derivatives at xo ! - h: Initial step size estimate call this % estimate_inital_step_size ( sys , xo , xmax , iv , f , h , args ) ! Store the initial conditions call this % append_to_buffer ( x ( 1 ), iv , errmgr ) if ( errmgr % has_error_occurred ()) return y = iv ! Cycle until integration is complete do i = 1 , nsteps ! Perform any pre-step actions call this % pre_step_action ( success , sys , h , xo , y , f , args = args , & err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Attempt a step call this % attempt_step ( sys , h , xo , y , f , yn , fn , yerr , k , args ) xn = xo + h ! Compute a normalized error value.  A value < 1 indicates success ei = this % compute_error_norm ( y , yn , yerr ) ! Determine the next step size h = this % estimate_next_step_size ( ei , eold , h , xo , errmgr ) if ( errmgr % has_error_occurred ()) return ! Reject the step? success = ei <= 1.0d0 if (. not . success ) cycle ! We failed.  Try again with a new step size ! If we're here, the step has been successful.  Take any post-step ! action such as setting up interpolation routines, etc. call this % post_step_action ( sys , dense , xo , xn , y , yn , f , fn , k , args ) ! Do we need to interpolate for dense output, or can we just store ! values and move on if ( dense ) then ! Perform the interpolation as needed until a new step is required interp : do while ( abs ( x ( j )) <= abs ( xn )) call this % interpolate ( x ( j ), xo , y , f , xn , yn , fn , yi ) call this % append_to_buffer ( x ( j ), yi , errmgr ) if ( errmgr % has_error_occurred ()) return j = j + 1 if ( j > n ) exit interp end do interp else ! Store the values and move on call this % append_to_buffer ( xn , yn , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Are we done? if ( abs ( xn ) >= abs ( xmax )) then ! Deal with the case where output is only returned at the ! integration points and the solver oversteps the endpoint. if ( abs ( xn ) > abs ( xmax )) then ! Interpolate to get the solution at xmax call this % post_step_action ( sys , . true ., xo , xn , y , yn , f , fn , k ) call this % interpolate ( xmax , xo , y , f , xn , yn , fn , yi ) call this % append_to_buffer ( xmax , yi , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! We're done go to 100 end if ! Do we need to limit the step size to not overshoot the terminal value? if ( this % get_allow_overshoot () . and . abs ( xn + h ) > abs ( xmax )) then ! Limit the step size h = xmax - xn end if ! Update parameters xo = xn y = yn ! Is this an FSAL integrator?  If so, we already have the derivative ! values.  If not, we need to recompute the derivative values for the ! next iteration if ( this % get_is_fsal ()) then ! We have the derivative estimate already f = fn else ! Update the derivative estimates call sys % fcn ( xn , yn , f , args ) ! write to f, not fn end if end do ! If we're here, the solver has run out of allowable steps call report_excessive_integration_steps ( errmgr , \"ssi_ode_solver\" , nsteps , & xn ) return ! End 100 continue return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_base.f90.html"},{"title":"diffeq_bsrk32_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_bsrk32_constants Source Code diffeq_bsrk32_constants.f90 Source Code module diffeq_bsrk32_constants use iso_fortran_env implicit none real ( real64 ), parameter :: a21 = 0.5d0 real ( real64 ), parameter :: a31 = 0.0d0 real ( real64 ), parameter :: a32 = 0.75d0 real ( real64 ), parameter :: a41 = 2.0d0 / 9.0d0 real ( real64 ), parameter :: a42 = 1.0d0 / 3.0d0 real ( real64 ), parameter :: a43 = 4.0d0 / 9.0d0 real ( real64 ), parameter :: b1 = 2.0d0 / 9.0d0 real ( real64 ), parameter :: b2 = 1.0d0 / 3.0d0 real ( real64 ), parameter :: b3 = 4.0d0 / 9.0d0 real ( real64 ), parameter :: b4 = 0.0d0 real ( real64 ), parameter :: b1a = 7.0d0 / 2 4.0d0 real ( real64 ), parameter :: b2a = 1.0d0 / 4.0d0 real ( real64 ), parameter :: b3a = 1.0d0 / 3.0d0 real ( real64 ), parameter :: b4a = 1.0d0 / 8.0d0 real ( real64 ), parameter :: c1 = 0.0d0 real ( real64 ), parameter :: c2 = 0.5d0 real ( real64 ), parameter :: c3 = 0.75d0 real ( real64 ), parameter :: c4 = 1.0d0 real ( real64 ), parameter :: e1 = b1a - b1 real ( real64 ), parameter :: e2 = b2a - b2 real ( real64 ), parameter :: e3 = b3a - b3 real ( real64 ), parameter :: e4 = b4a - b4 end module","tags":"","loc":"sourcefile\\diffeq_bsrk32_constants.f90.html"},{"title":"diffeq_dprk45_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_dprk45_constants Source Code diffeq_dprk45_constants.f90 Source Code module diffeq_dprk45_constants use iso_fortran_env implicit none ! Dormand-Prince 4th/5th Order Model Coefficients real ( real64 ), parameter :: a21 = 1.0d0 / 5.0d0 real ( real64 ), parameter :: a31 = 3.0d0 / 4 0.0d0 real ( real64 ), parameter :: a32 = 9.0d0 / 4 0.0d0 real ( real64 ), parameter :: a41 = 4 4.0d0 / 4 5.0d0 real ( real64 ), parameter :: a42 = - 5 6.0d0 / 1 5.0d0 real ( real64 ), parameter :: a43 = 3 2.0d0 / 9.0d0 real ( real64 ), parameter :: a51 = 1.9372d4 / 6.561d3 real ( real64 ), parameter :: a52 = - 2.536d4 / 2.187d3 real ( real64 ), parameter :: a53 = 6.4448d4 / 6.561d3 real ( real64 ), parameter :: a54 = - 2.12d2 / 7.29d2 real ( real64 ), parameter :: a61 = 9.017d3 / 3.168d3 real ( real64 ), parameter :: a62 = - 3.55d2 / 3 3.0d0 real ( real64 ), parameter :: a63 = 4.6732d4 / 5.247d3 real ( real64 ), parameter :: a64 = 4 9.0d0 / 1.76d2 real ( real64 ), parameter :: a65 = - 5.103d3 / 1.8656d4 real ( real64 ), parameter :: a71 = 3 5.0d0 / 3.84d2 real ( real64 ), parameter :: a72 = 0.0d0 real ( real64 ), parameter :: a73 = 5.0d2 / 1.113d3 real ( real64 ), parameter :: a74 = 1.25d2 / 1.92d2 real ( real64 ), parameter :: a75 = - 2.187d3 / 6.784d3 real ( real64 ), parameter :: a76 = 1 1.0d0 / 8 4.0d0 real ( real64 ), parameter :: e1 = - 7 1.0d0 / 5.76d4 real ( real64 ), parameter :: e2 = 0.0d0 real ( real64 ), parameter :: e3 = 7 1.0d0 / 1.6695d4 real ( real64 ), parameter :: e4 = - 7 1.0d0 / 1.92d3 real ( real64 ), parameter :: e5 = 1.7253d4 / 3.392d5 real ( real64 ), parameter :: e6 = - 2 2.0d0 / 5.25d2 real ( real64 ), parameter :: e7 = 1.0d0 / 4.0d1 real ( real64 ), parameter :: c2 = 1.0d0 / 5.0d0 real ( real64 ), parameter :: c3 = 3.0d0 / 1.0d1 real ( real64 ), parameter :: c4 = 4.0d0 / 5.0d0 real ( real64 ), parameter :: c5 = 8.0d0 / 9.0d0 real ( real64 ), parameter :: c6 = 1.0d0 real ( real64 ), parameter :: c7 = 1.0d0 ! Interpolation Parameters real ( real64 ), parameter :: d1 = - 1.2715105075d10 / 1.1282082432d10 real ( real64 ), parameter :: d3 = 8.74874797d10 / 3.2700410799d10 real ( real64 ), parameter :: d4 = - 1.0690763975d10 / 1.880347072d9 real ( real64 ), parameter :: d5 = 7.01980252875d11 / 1.99316789632d11 real ( real64 ), parameter :: d6 = - 1.453857185d9 / 8.22651844d8 real ( real64 ), parameter :: d7 = 6.9997945d7 / 2.9380423d7 end module","tags":"","loc":"sourcefile\\diffeq_dprk45_constants.f90.html"},{"title":"diffeq_errors.f90 – DIFFEQ","text":"Contents Modules diffeq_errors Source Code diffeq_errors.f90 Source Code module diffeq_errors !! A collection of routines for handling errors in the DIFFEQ library. use iso_fortran_env use ferror implicit none ! ------------------------------------------------------------------------------ ! Error Flags integer ( int32 ), parameter :: DIFFEQ_MEMORY_ALLOCATION_ERROR = 10000 integer ( int32 ), parameter :: DIFFEQ_NULL_POINTER_ERROR = 10001 integer ( int32 ), parameter :: DIFFEQ_MATRIX_SIZE_ERROR = 10002 integer ( int32 ), parameter :: DIFFEQ_ARRAY_SIZE_ERROR = 10003 integer ( int32 ), parameter :: DIFFEQ_INVALID_INPUT_ERROR = 10004 integer ( int32 ), parameter :: DIFFEQ_MISSING_ARGUMENT_ERROR = 10005 integer ( int32 ), parameter :: DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR = 10006 integer ( int32 ), parameter :: DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR = 10007 integer ( int32 ), parameter :: DIFFEQ_INVALID_OPERATION_ERROR = 10008 ! ------------------------------------------------------------------------------ contains ! ------------------------------------------------------------------------------ subroutine report_memory_error ( err , fcn , flag ) !! Reports a memory error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: flag !! The memory status flag. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_MEMORY_ALLOCATION_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_error ( err , fcn , varname , exprow , expcol , & actrow , actcol ) !! Reports a matrix size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: exprow !! The expected number of rows. integer ( int32 ), intent ( in ) :: expcol !! The expected number of columns. integer ( int32 ), intent ( in ) :: actrow !! The actual number of rows. integer ( int32 ), intent ( in ) :: actcol !! The actual number of columns. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"The matrix \" // varname // \" was expected to be (\" , & exprow , \"-by-\" , expcol , \"), but was found to be (\" , actrow , \"-by-\" , & actcol , \").\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_min_array_size_not_met ( err , fcn , varname , minsize , actsize ) !! Reports an error where the minimum array size was not met. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: minsize !! The minimum size of the array. integer ( int32 ), intent ( in ) :: actsize !! The actual size of the array. ! Local Variables character ( len = 256 ) :: errmsg ! Process write ( errmsg , 100 ) \"Array \" // varname // \" must be at least of size \" , & minsize , \", but was found to be of size \" , actsize , \".\" call err % report_error ( fcn , trim ( errmsg ), DIFFEQ_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_missing_ode ( err , fcn ) !! Reports a missing ODE routine. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. ! Process call err % report_error ( fcn , \"No ODE routine has been supplied.\" , & DIFFEQ_NULL_POINTER_ERROR ) return end subroutine ! ------------------------------------------------------------------------------ subroutine report_array_size_error ( err , fcn , varname , expsize , actsize ) !! Reports an array size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: varname !! The offending variable name. integer ( int32 ), intent ( in ) :: expsize !! The expected size of the array. integer ( int32 ), intent ( in ) :: actsize !! The actual size of the array. ! Local Variables character ( len = 256 ) :: msg ! Process write ( msg , 100 ) \"Array \" // varname // \" was expected to be of size \" , & expsize , \", but was found to be of size \" , actsize , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_missing_argument ( err , fcn , arg ) !! Reports a missing argument error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. character ( len = * ), intent ( in ) :: arg !! The name of the argument. ! Process call err % report_error ( fcn , \"Argument \" // arg // \" was missing.\" , & DIFFEQ_MISSING_ARGUMENT_ERROR ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_step_size_too_small ( err , fcn , x , h ) !! Reports an error when the step size becomes too small. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the step size error !! occurred. real ( real64 ), intent ( in ) :: h !! The step size value. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) \"A step size of \" , h , \" was encountered at x = \" , x , & \", and is too small to continue integration.\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR ) ! Formatting 100 format ( A , EN0 . 3 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_excessive_iterations ( err , fcn , n , x ) !! Reports an error when excessive iterations have been made. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: n !! The number of iterations. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the error occurred. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) \"The allowable iteration count was exceeded (iteration \" , & n , \") at x = \" , x , \".\" call err % report_error ( fcn , trim ( msg ), DIFFEQ_ITERATION_COUNT_EXCEEDED_ERROR ) ! Formatting 100 format ( A , I0 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_excessive_integration_steps ( err , fcn , n , x ) !! Reports an error when an excessive  amount integration steps have been !! taken. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fcn !! The name of the function or subroutine in which the error occurred. integer ( int32 ), intent ( in ) :: n !! The number of integration steps. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the error occurred. ! Process character ( len = 256 ) :: msg write ( msg , 100 ) & \"The allowable number of integration steps was exceeded (step \" , & n , \" at x = \" , x , \".\" ! Formatting 100 format ( A , I0 , A , EN0 . 3 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_errors.f90.html"},{"title":"diffeq_implicit_runge_kutta.f90 – DIFFEQ","text":"Contents Modules diffeq_implicit_runge_kutta Source Code diffeq_implicit_runge_kutta.f90 Source Code module diffeq_implicit_runge_kutta use iso_fortran_env use diffeq_base use diffeq_errors use linalg , only : lu_factor , solve_lu implicit none private public :: rosenbrock type , extends ( single_step_integrator ) :: rosenbrock !! Defines a 4th order Rosenbrock integrator. !! !! Remarks: !! 1. This integrator is suitable for systems of stiff equations !!  with modest accuracy requirements. !! 2. This integrator is capable of dealing with systems that utilize a !!  mass matrix. real ( real64 ), private , allocatable , dimension (:,:) :: jac ! The Jacobian matrix. real ( real64 ), private , allocatable , dimension (:,:) :: mass ! The mass matrix. integer ( int32 ), private , allocatable , dimension (:) :: pivot ! LU factorization pivot tracking array logical , private :: m_massComputed = . false . ! True if the mass matrix has been computed; else, false. real ( real64 ), private , allocatable , dimension (:) :: dfdx ! N-element array of df/dx real ( real64 ), private , allocatable , dimension (:,:) :: a ! System matrix. real ( real64 ), private , allocatable , dimension (:) :: rc1 real ( real64 ), private , allocatable , dimension (:) :: rc2 real ( real64 ), private , allocatable , dimension (:) :: rc3 real ( real64 ), private , allocatable , dimension (:) :: rc4 logical , private :: m_firstStep = . true . logical , private :: m_rejectStep = . false . real ( real64 ), private :: m_hOld = 0.0d0 contains procedure , private :: initialize_matrices => rbrk_init_matrices !! Allocates internal storage for the system matrices. procedure , private :: initialize_interp => rbrk_init_interp !! Initializes private storage for the interpolation process. procedure , public :: pre_step_action => rbrk_form_matrix !! Constructs the system matrix. procedure , public :: attempt_step => rbrk_attempt_step !! Attempts an integration step for this integrator. procedure , public :: post_step_action => rbrk_set_up_interp !! Sets up the interpolation process as the post-step action. procedure , public :: interpolate => rbrk_interp !! Performs the interpolation. procedure , public :: get_order => rbrk_get_order !! Gets the order of the integrator. procedure , public :: get_is_fsal => rbrk_get_is_fsal !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. procedure , public :: get_stage_count => rbrk_get_stage_count !! Gets the stage count for this integrator. procedure , public :: estimate_next_step_size => rbrk_next_step !! Estimates the next step size. end type contains ! ****************************************************************************** ! ROSENBROCK ! ------------------------------------------------------------------------------ subroutine rbrk_form_matrix ( this , prevs , sys , h , x , y , f , args , err ) use diffeq_rosenbrock_constants !! Constructs the system matrix of the form !!  A = \\frac{1}{\\gamma h} M - J , and then computes it's LU !! factorization.  The LU-factored form of A is stored internally. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. logical , intent ( in ) :: prevs !! Defines the status of the previous step.  The value is true if the !! previous step was successful; else, false if the previous step !! failed. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives at x. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. ! Local Variables integer ( int32 ) :: i , n logical :: useMass real ( real64 ) :: fac class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( y ) useMass = associated ( sys % mass_matrix ) call this % initialize_matrices ( n , useMass ) ! Compute the Jacobian matrix - only need to update if the previous step ! was successful if ( prevs ) then call sys % compute_jacobian ( x , y , this % jac , args = args , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the mass matrix if ( useMass ) then if (. not . this % m_massComputed . or . & sys % get_is_mass_matrix_dependent ()) & then ! We need to compute the mass matrix call sys % mass_matrix ( x , y , this % mass , args ) this % m_massComputed = . true . end if end if end if ! Form the system matrix, and then factor it accordingly fac = 1.0d0 / ( gam * h ) if ( useMass ) then this % a = fac * this % mass - this % jac else this % a = - this % jac do i = 1 , n this % a ( i , i ) = this % a ( i , i ) + fac end do end if ! Factor the equations call lu_factor ( this % a , this % pivot , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute df/dx fac = sys % get_finite_difference_step () call sys % fcn ( x + fac , y , this % dfdx , args ) this % dfdx = ( this % dfdx - f ) / h ! forward differencing end subroutine ! ------------------------------------------------------------------------------ subroutine rbrk_init_matrices ( this , n , usemass ) !! Allocates internal storage for the system matrices. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. integer ( int32 ), intent ( in ) :: n !! The number of equations being integrated. logical , intent ( in ) :: usemass !! True if a mass matrix is used; else, false. ! Process if ( allocated ( this % jac )) then if ( size ( this % jac , 1 ) == n . and . size ( this % jac , 2 ) == n ) then ! All is good return else deallocate ( this % jac ) if ( allocated ( this % mass )) deallocate ( this % mass ) deallocate ( this % pivot ) deallocate ( this % dfdx ) deallocate ( this % a ) end if end if if ( usemass ) then allocate ( & this % jac ( n , n ), & this % mass ( n , n ), & this % pivot ( n ), & this % dfdx ( n ), & this % a ( n , n ) & ) else allocate ( & this % jac ( n , n ), & this % pivot ( n ), & this % dfdx ( n ), & this % a ( n , n ) & ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine rbrk_attempt_step ( this , sys , h , x , y , f , yn , fn , yerr , k , args ) use diffeq_rosenbrock_constants !! Attempts an integration step for this integrator. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where this routine will write the next !! solution estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: fn !! An N-element array where this routine will write the next !! derivative estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: yerr !! An N-element array where this routine will write an estimate !! of the error in each equation. real ( real64 ), intent ( out ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: n ! Initialization n = size ( y ) ! Process k (:, 1 ) = f + h * d1 * this % dfdx call solve_lu ( this % a , this % pivot , k (:, 1 )) yn = y + a21 * k (:, 1 ) call sys % fcn ( x + c2 * h , yn , fn , args ) k (:, 2 ) = fn + h * d2 * this % dfdx + c21 * k (:, 1 ) / h call solve_lu ( this % a , this % pivot , k (:, 2 )) yn = y + a31 * k (:, 1 ) + a32 * k (:, 2 ) call sys % fcn ( x + c3 * h , yn , fn , args ) k (:, 3 ) = fn + h * d3 * this % dfdx + ( c31 * k (:, 1 ) + c32 * k (:, 2 )) / h call solve_lu ( this % a , this % pivot , k (:, 3 )) yn = y + a41 * k (:, 1 ) + a42 * k (:, 2 ) + a43 * k (:, 3 ) call sys % fcn ( x + c4 * h , yn , fn , args ) k (:, 4 ) = fn + h * d4 * this % dfdx + ( c41 * k (:, 1 ) + c42 * k (:, 2 ) + & c43 * k (:, 3 )) / h call solve_lu ( this % a , this % pivot , k (:, 4 )) yn = y + a51 * k (:, 1 ) + a52 * k (:, 2 ) + a53 * k (:, 3 ) + a54 * k (:, 4 ) call sys % fcn ( x + h , yn , fn , args ) k (:, 5 ) = fn + ( c51 * k (:, 1 ) + c52 * k (:, 2 ) + c53 * k (:, 3 ) + & c54 * k (:, 4 )) / h call solve_lu ( this % a , this % pivot , k (:, 5 )) yn = yn + k (:, 5 ) call sys % fcn ( x + h , yn , fn , args ) ! updated derivative yerr = fn + ( c61 * k (:, 1 ) + c62 * k (:, 2 ) + c63 * k (:, 3 ) + & c64 * k (:, 4 ) + c65 * k (:, 5 )) / h call solve_lu ( this % a , this % pivot , yerr ) yn = yn + yerr end subroutine ! ------------------------------------------------------------------------------ subroutine rbrk_init_interp ( this , neqn ) !! Allocates storage for the interpolation process. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. ! Process if ( allocated ( this % rc1 )) then if ( size ( this % rc1 ) == neqn ) then ! All is good return else deallocate ( this % rc1 ) deallocate ( this % rc2 ) deallocate ( this % rc3 ) deallocate ( this % rc4 ) end if end if allocate ( & this % rc1 ( neqn ), & this % rc2 ( neqn ), & this % rc3 ( neqn ), & this % rc4 ( neqn ) & ) end subroutine ! ------------------------------------------------------------------------------ subroutine rbrk_set_up_interp ( this , sys , dense , x , xn , y , yn , f , fn , k , args ) use diffeq_rosenbrock_constants !! Sets up the interpolation process. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. logical , intent ( in ) :: dense !! Determines if dense output is requested (true); else, false. real ( real64 ), intent ( in ) :: x !! The previous value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the solution at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the derivatives at x. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: i , n ! Quick Return if (. not . dense ) return ! Initialization n = size ( y ) call this % initialize_interp ( n ) ! Process do i = 1 , n this % rc1 ( i ) = y ( i ) this % rc2 ( i ) = yn ( i ) this % rc3 ( i ) = d21 * k ( i , 1 ) + d22 * k ( i , 2 ) + d23 * k ( i , 3 ) + & d24 * k ( i , 4 ) + d25 * k ( i , 5 ) this % rc4 ( i ) = d31 * k ( i , 1 ) + d32 * k ( i , 2 ) + d33 * k ( i , 3 ) + & d34 * k ( i , 4 ) + d35 * k ( i , 5 ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine rbrk_interp ( this , x , xn , yn , fn , xn1 , yn1 , fn1 , y ) !! Performs the interpolation. class ( rosenbrock ), intent ( in ) :: this !! The rosenbrock object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which to compute !! the interpolation. real ( real64 ), intent ( in ) :: xn !! The previous value of the independent variable at which the !! solution is computed. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( in ) :: xn1 !! The value of the independent variable at xn + h. real ( real64 ), intent ( in ), dimension (:) :: yn1 !! An N-element array containing the solution at xn + h. real ( real64 ), intent ( in ), dimension (:) :: fn1 !! An N-element array containing the derivatives at xn + h. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where this routine will write the !! solution values interpolated at x. ! Local Variables real ( real64 ) :: h , s , s1 ! Process h = xn1 - xn s = ( x - xn ) / h s1 = 1.0d0 - s y = this % rc1 * s1 + s * ( this % rc2 + s1 * ( this % rc3 + s * this % rc4 )) end subroutine ! ------------------------------------------------------------------------------ pure function rbrk_get_order ( this ) result ( rst ) !! Gets the order of the integrator. class ( rosenbrock ), intent ( in ) :: this !! The rosenbrock object. integer ( int32 ) :: rst !! The order. rst = 4 end function ! ------------------------------------------------------------------------------ pure function rbrk_get_is_fsal ( this ) result ( rst ) !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. class ( rosenbrock ), intent ( in ) :: this !! The rosenbrock object. logical :: rst !! True for a FSAL integrator; else, false. rst = . true . end function ! ------------------------------------------------------------------------------ pure function rbrk_get_stage_count ( this ) result ( rst ) !! Gets the stage count for this integrator. class ( rosenbrock ), intent ( in ) :: this !! The rosenbrock object. integer ( int32 ) :: rst !! The stage count. rst = 6 end function ! ------------------------------------------------------------------------------ function rbrk_next_step ( this , e , eold , h , x , err ) result ( rst ) !! Estimates the next step size based upon the current and previous error !! estimates. class ( rosenbrock ), intent ( inout ) :: this !! The rosenbrock object. real ( real64 ), intent ( in ) :: e !! The norm of the current scaled error estimate. real ( real64 ), intent ( inout ) :: eold !! The norm of the previous step's scaled error estimate.  On output, !! this variable is updated. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current independent variable value. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling.  Possible errors and warning messages !! that may be encountered are as follows. !! !!  - DIFFEQ_STEP_SIZE_TOO_SMALL_ERROR: Occurs if the step size !!      becomes too small in magnitude. real ( real64 ) :: rst !! The new step size estimate. ! Parameters real ( real64 ), parameter :: fac1 = 5.0d0 real ( real64 ), parameter :: fac2 = 1.0d0 / 6.0d0 ! Local Variables real ( real64 ) :: safe , fac , facpred ! Initialization safe = this % get_step_size_factor () fac = max ( fac2 , min ( fac1 , e ** ( 0.25d0 ) / safe )) rst = h / fac ! Process if ( e <= 1.0d0 ) then ! The step met error tolerances and is acceptable if (. not . this % m_firstStep ) then facpred = ( this % m_hOld / h ) * ( e * e / eold ) ** ( 0.25d00 ) / safe facpred = max ( fac2 , min ( fac1 , facpred )) fac = max ( fac , facpred ) rst = h / fac end if this % m_firstStep = . false . this % m_hOld = h eold = max ( 1.0d-2 , e ) if ( this % m_rejectStep ) then ! Don't let the step size increase if the last step was rejected if ( abs ( h ) >= 0.0d0 ) then rst = min ( abs ( rst ), abs ( h )) else rst = max ( abs ( rst ), abs ( h )) end if rst = sign ( rst , h ) end if this % m_rejectStep = . false . else ! The step is rejected, reduce the step size - already computed this % m_rejectStep = . true . end if end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_implicit_runge_kutta.f90.html"},{"title":"diffeq_rk853_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_rk853_constants Source Code diffeq_rk853_constants.f90 Source Code module diffeq_rk853_constants use iso_fortran_env implicit none real ( real64 ), parameter :: a21 = 5.26001519587677318785587544488d-2 real ( real64 ), parameter :: a31 = 1.97250569845378994544595329183d-2 real ( real64 ), parameter :: a32 = 5.91751709536136983633785987549d-2 real ( real64 ), parameter :: a41 = 2.95875854768068491816892993775d-2 real ( real64 ), parameter :: a43 = 8.87627564304205475450678981324d-2 real ( real64 ), parameter :: a51 = 2.41365134159266685502369798665d-1 real ( real64 ), parameter :: a53 = - 8.84549479328286085344864962717d-1 real ( real64 ), parameter :: a54 = 9.24834003261792003115737966543d-1 real ( real64 ), parameter :: a61 = 3.7037037037037037037037037037d-2 real ( real64 ), parameter :: a64 = 1.70828608729473871279604482173d-1 real ( real64 ), parameter :: a65 = 1.25467687566822425016691814123d-1 real ( real64 ), parameter :: a71 = 3.7109375d-2 real ( real64 ), parameter :: a74 = 1.70252211019544039314978060272d-1 real ( real64 ), parameter :: a75 = 6.02165389804559606850219397283d-2 real ( real64 ), parameter :: a76 = - 1.7578125d-2 real ( real64 ), parameter :: a81 = 3.70920001185047927108779319836d-2 real ( real64 ), parameter :: a84 = 1.70383925712239993810214054705d-1 real ( real64 ), parameter :: a85 = 1.07262030446373284651809199168d-1 real ( real64 ), parameter :: a86 = - 1.53194377486244017527936158236d-2 real ( real64 ), parameter :: a87 = 8.27378916381402288758473766002d-3 real ( real64 ), parameter :: a91 = 6.24110958716075717114429577812d-1 real ( real64 ), parameter :: a94 = - 3.36089262944694129406857109825d0 real ( real64 ), parameter :: a95 = - 8.68219346841726006818189891453d-1 real ( real64 ), parameter :: a96 = 2.75920996994467083049415600797d1 real ( real64 ), parameter :: a97 = 2.01540675504778934086186788979d1 real ( real64 ), parameter :: a98 = - 4.34898841810699588477366255144d1 real ( real64 ), parameter :: a101 = 4.77662536438264365890433908527d-1 real ( real64 ), parameter :: a104 = - 2.48811461997166764192642586468d0 real ( real64 ), parameter :: a105 = - 5.90290826836842996371446475743d-1 real ( real64 ), parameter :: a106 = 2.12300514481811942347288949897d1 real ( real64 ), parameter :: a107 = 1.52792336328824235832596922938d1 real ( real64 ), parameter :: a108 = - 3.32882109689848629194453265587d1 real ( real64 ), parameter :: a109 = - 2.03312017085086261358222928593d-2 real ( real64 ), parameter :: a111 = - 9.3714243008598732571704021658d-1 real ( real64 ), parameter :: a114 = 5.18637242884406370830023853209d0 real ( real64 ), parameter :: a115 = 1.09143734899672957818500254654d0 real ( real64 ), parameter :: a116 = - 8.14978701074692612513997267357d0 real ( real64 ), parameter :: a117 = - 1.85200656599969598641566180701d1 real ( real64 ), parameter :: a118 = 2.27394870993505042818970056734d1 real ( real64 ), parameter :: a119 = 2.49360555267965238987089396762d0 real ( real64 ), parameter :: a1110 = - 3.0467644718982195003823669022d0 real ( real64 ), parameter :: a121 = 2.27331014751653820792359768449d0 real ( real64 ), parameter :: a124 = - 1.05344954667372501984066689879d1 real ( real64 ), parameter :: a125 = - 2.00087205822486249909675718444d0 real ( real64 ), parameter :: a126 = - 1.79589318631187989172765950534d1 real ( real64 ), parameter :: a127 = 2.79488845294199600508499808837d1 real ( real64 ), parameter :: a128 = - 2.85899827713502369474065508674d0 real ( real64 ), parameter :: a129 = - 8.87285693353062954433549289258d0 real ( real64 ), parameter :: a1210 = 1.23605671757943030647266201528d1 real ( real64 ), parameter :: a1211 = 6.43392746015763530355970484046d-1 real ( real64 ), parameter :: a141 = 5.61675022830479523392909219681d-2 real ( real64 ), parameter :: a147 = 2.53500210216624811088794765333d-1 real ( real64 ), parameter :: a148 = - 2.46239037470802489917441475441d-1 real ( real64 ), parameter :: a149 = - 1.24191423263816360469010140626d-1 real ( real64 ), parameter :: a1410 = 1.5329179827876569731206322685d-1 real ( real64 ), parameter :: a1411 = 8.20105229563468988491666602057d-3 real ( real64 ), parameter :: a1412 = 7.56789766054569976138603589584d-3 real ( real64 ), parameter :: a1413 = - 8.298d-3 real ( real64 ), parameter :: a151 = 3.18346481635021405060768473261d-2 real ( real64 ), parameter :: a156 = 2.83009096723667755288322961402d-2 real ( real64 ), parameter :: a157 = 5.35419883074385676223797384372d-2 real ( real64 ), parameter :: a158 = - 5.49237485713909884646569340306d-2 real ( real64 ), parameter :: a1511 = - 1.08347328697249322858509316994d-4 real ( real64 ), parameter :: a1512 = 3.82571090835658412954920192323d-4 real ( real64 ), parameter :: a1513 = - 3.40465008687404560802977114492d-4 real ( real64 ), parameter :: a1514 = 1.41312443674632500278074618366d-1 real ( real64 ), parameter :: a161 = - 4.28896301583791923408573538692d-1 real ( real64 ), parameter :: a166 = - 4.69762141536116384314449447206d0 real ( real64 ), parameter :: a167 = 7.68342119606259904184240953878d0 real ( real64 ), parameter :: a168 = 4.06898981839711007970213554331d0 real ( real64 ), parameter :: a169 = 3.56727187455281109270669543021d-1 real ( real64 ), parameter :: a1613 = - 1.39902416515901462129418009734d-3 real ( real64 ), parameter :: a1614 = 2.9475147891527723389556272149d0 real ( real64 ), parameter :: a1615 = - 9.15095847217987001081870187138d0 real ( real64 ), parameter :: b1 = 5.42937341165687622380535766363d-2 real ( real64 ), parameter :: b6 = 4.45031289275240888144113950566d0 real ( real64 ), parameter :: b7 = 1.89151789931450038304281599044d0 real ( real64 ), parameter :: b8 = - 5.8012039600105847814672114227d0 real ( real64 ), parameter :: b9 = 3.1116436695781989440891606237d-1 real ( real64 ), parameter :: b10 = - 1.52160949662516078556178806805d-1 real ( real64 ), parameter :: b11 = 2.01365400804030348374776537501d-1 real ( real64 ), parameter :: b12 = 4.47106157277725905176885569043d-2 real ( real64 ), parameter :: c2 = 0.526001519587677318785587544488d-1 real ( real64 ), parameter :: c3 = 0.789002279381515978178381316732d-1 real ( real64 ), parameter :: c4 = 0.118350341907227396726757197510d0 real ( real64 ), parameter :: c5 = 0.281649658092772603273242802490d0 real ( real64 ), parameter :: c6 = 0.333333333333333333333333333333d0 real ( real64 ), parameter :: c7 = 0.25d0 real ( real64 ), parameter :: c8 = 0.307692307692307692307692307692d0 real ( real64 ), parameter :: c9 = 0.651282051282051282051282051282d0 real ( real64 ), parameter :: c10 = 0.6d0 real ( real64 ), parameter :: c11 = 0.857142857142857142857142857142d0 real ( real64 ), parameter :: c14 = 0.1d0 real ( real64 ), parameter :: c15 = 0.2d0 real ( real64 ), parameter :: c16 = 0.777777777777777777777777777778d0 real ( real64 ), parameter :: bhh1 = 0.244094488188976377952755905512d0 real ( real64 ), parameter :: bhh2 = 0.733846688281611857341361741547d0 real ( real64 ), parameter :: bhh3 = 0.220588235294117647058823529412d-1 real ( real64 ), parameter :: er1 = 0.1312004499419488073250102996d-1 real ( real64 ), parameter :: er6 = - 0.1225156446376204440720569753d1 real ( real64 ), parameter :: er7 = - 0.4957589496572501915214079952d0 real ( real64 ), parameter :: er8 = 0.1664377182454986536961530415d1 real ( real64 ), parameter :: er9 = - 0.3503288487499736816886487290d0 real ( real64 ), parameter :: er10 = 0.3341791187130174790297318841d0 real ( real64 ), parameter :: er11 = 0.8192320648511571246570742613d-1 real ( real64 ), parameter :: er12 = - 0.2235530786388629525884427845d-1 real ( real64 ), parameter :: d41 = - 0.84289382761090128651353491142d1 real ( real64 ), parameter :: d46 = 0.56671495351937776962531783590d0 real ( real64 ), parameter :: d47 = - 0.30689499459498916912797304727d1 real ( real64 ), parameter :: d48 = 0.23846676565120698287728149680d1 real ( real64 ), parameter :: d49 = 0.21170345824450282767155149946d1 real ( real64 ), parameter :: d410 = - 0.87139158377797299206789907490d0 real ( real64 ), parameter :: d411 = 0.22404374302607882758541771650d1 real ( real64 ), parameter :: d412 = 0.63157877876946881815570249290d0 real ( real64 ), parameter :: d413 = - 0.88990336451333310820698117400d-1 real ( real64 ), parameter :: d414 = 0.18148505520854727256656404962d2 real ( real64 ), parameter :: d415 = - 0.91946323924783554000451984436d1 real ( real64 ), parameter :: d416 = - 0.44360363875948939664310572000d1 real ( real64 ), parameter :: d51 = 0.10427508642579134603413151009d2 real ( real64 ), parameter :: d56 = 0.24228349177525818288430175319d3 real ( real64 ), parameter :: d57 = 0.16520045171727028198505394887d3 real ( real64 ), parameter :: d58 = - 0.37454675472269020279518312152d3 real ( real64 ), parameter :: d59 = - 0.22113666853125306036270938578d2 real ( real64 ), parameter :: d510 = 0.77334326684722638389603898808d1 real ( real64 ), parameter :: d511 = - 0.30674084731089398182061213626d2 real ( real64 ), parameter :: d512 = - 0.93321305264302278729567221706d1 real ( real64 ), parameter :: d513 = 0.15697238121770843886131091075d2 real ( real64 ), parameter :: d514 = - 0.31139403219565177677282850411d2 real ( real64 ), parameter :: d515 = - 0.93529243588444783865713862664d1 real ( real64 ), parameter :: d516 = 0.35816841486394083752465898540d2 real ( real64 ), parameter :: d61 = 0.19985053242002433820987653617d2 real ( real64 ), parameter :: d66 = - 0.38703730874935176555105901742d3 real ( real64 ), parameter :: d67 = - 0.18917813819516756882830838328d3 real ( real64 ), parameter :: d68 = 0.52780815920542364900561016686d3 real ( real64 ), parameter :: d69 = - 0.11573902539959630126141871134d2 real ( real64 ), parameter :: d610 = 0.68812326946963000169666922661d1 real ( real64 ), parameter :: d611 = - 0.10006050966910838403183860980d1 real ( real64 ), parameter :: d612 = 0.77771377980534432092869265740d0 real ( real64 ), parameter :: d613 = - 0.27782057523535084065932004339d1 real ( real64 ), parameter :: d614 = - 0.60196695231264120758267380846d2 real ( real64 ), parameter :: d615 = 0.84320405506677161018159903784d2 real ( real64 ), parameter :: d616 = 0.11992291136182789328035130030d2 real ( real64 ), parameter :: d71 = - 0.25693933462703749003312586129d2 real ( real64 ), parameter :: d76 = - 0.15418974869023643374053993627d3 real ( real64 ), parameter :: d77 = - 0.23152937917604549567536039109d3 real ( real64 ), parameter :: d78 = 0.35763911791061412378285349910d3 real ( real64 ), parameter :: d79 = 0.93405324183624310003907691704d2 real ( real64 ), parameter :: d710 = - 0.37458323136451633156875139351d2 real ( real64 ), parameter :: d711 = 0.10409964950896230045147246184d3 real ( real64 ), parameter :: d712 = 0.29840293426660503123344363579d2 real ( real64 ), parameter :: d713 = - 0.43533456590011143754432175058d2 real ( real64 ), parameter :: d714 = 0.96324553959188282948394950600d2 real ( real64 ), parameter :: d715 = - 0.39177261675615439165231486172d2 real ( real64 ), parameter :: d716 = - 0.14972683625798562581422125276d3 end module","tags":"","loc":"sourcefile\\diffeq_rk853_constants.f90.html"},{"title":"diffeq_rosenbrock_constants.f90 – DIFFEQ","text":"Contents Modules diffeq_rosenbrock_constants Source Code diffeq_rosenbrock_constants.f90 Source Code module diffeq_rosenbrock_constants use iso_fortran_env implicit none real ( real64 ), parameter :: c2 = 0.386d0 ; real ( real64 ), parameter :: c3 = 0.21d0 ; real ( real64 ), parameter :: c4 = 0.63d0 ; real ( real64 ), parameter :: bet2p = 0.0317d0 ; real ( real64 ), parameter :: bet3p = 0.0635d0 ; real ( real64 ), parameter :: bet4p = 0.3438d0 ; real ( real64 ), parameter :: d1 = 0.25d0 ; real ( real64 ), parameter :: d2 = - 0.1043d0 ; real ( real64 ), parameter :: d3 = 0.1035d0 ; real ( real64 ), parameter :: d4 = - 0.3620000000000023d1 ; real ( real64 ), parameter :: a21 = 0.1544d1 ; real ( real64 ), parameter :: a31 = 0.9466785280815826d0 ; real ( real64 ), parameter :: a32 = 0.2557011698983284d0 ; real ( real64 ), parameter :: a41 = 0.3314825187068521d1 ; real ( real64 ), parameter :: a42 = 0.2896124015972201d1 ; real ( real64 ), parameter :: a43 = 0.9986419139977817d0 ; real ( real64 ), parameter :: a51 = 0.1221224509226641d1 ; real ( real64 ), parameter :: a52 = 0.6019134481288629d1 ; real ( real64 ), parameter :: a53 = 0.1253708332932087d2 ; real ( real64 ), parameter :: a54 = - 0.6878860361058950d0 ; real ( real64 ), parameter :: c21 = - 0.5668800000000000d1 ; real ( real64 ), parameter :: c31 = - 0.2430093356833875d1 ; real ( real64 ), parameter :: c32 = - 0.2063599157091915d0 ; real ( real64 ), parameter :: c41 = - 0.1073529058151375d0 ; real ( real64 ), parameter :: c42 = - 0.9594562251023355d1 ; real ( real64 ), parameter :: c43 = - 0.2047028614809616d2 ; real ( real64 ), parameter :: c51 = 0.7496443313967647d1 ; real ( real64 ), parameter :: c52 = - 0.1024680431464352d2 ; real ( real64 ), parameter :: c53 = - 0.3399990352819905d2 ; real ( real64 ), parameter :: c54 = 0.1170890893206160d2 ; real ( real64 ), parameter :: c61 = 0.8083246795921522d1 ; real ( real64 ), parameter :: c62 = - 0.7981132988064893d1 ; real ( real64 ), parameter :: c63 = - 0.3152159432874371d2 ; real ( real64 ), parameter :: c64 = 0.1631930543123136d2 ; real ( real64 ), parameter :: c65 = - 0.6058818238834054d1 ; real ( real64 ), parameter :: gam = 0.25d0 ; real ( real64 ), parameter :: d21 = 0.1012623508344586d2 ; real ( real64 ), parameter :: d22 = - 0.7487995877610167d1 ; real ( real64 ), parameter :: d23 = - 0.3480091861555747d2 ; real ( real64 ), parameter :: d24 = - 0.7992771707568823d1 ; real ( real64 ), parameter :: d25 = 0.1025137723295662d1 ; real ( real64 ), parameter :: d31 = - 0.6762803392801253d0 ; real ( real64 ), parameter :: d32 = 0.6087714651680015d1 ; real ( real64 ), parameter :: d33 = 0.1643084320892478d2 ; real ( real64 ), parameter :: d34 = 0.2476722511418386d2 ; real ( real64 ), parameter :: d35 = - 0.6594389125716872d1 ; end module","tags":"","loc":"sourcefile\\diffeq_rosenbrock_constants.f90.html"},{"title":"diffeq_runge_kutta.f90 – DIFFEQ","text":"Contents Modules diffeq_runge_kutta Source Code diffeq_runge_kutta.f90 Source Code module diffeq_runge_kutta use iso_fortran_env use diffeq_errors use diffeq_base use ferror implicit none private public :: runge_kutta_45 public :: runge_kutta_23 public :: runge_kutta_853 type , extends ( single_step_integrator ) :: runge_kutta_45 !! The Dormand-Prince, Runge-Kutta integrator (5th order, with an !! embedded 4th order used for error estimation). real ( real64 ), private , allocatable , dimension (:) :: rc1 real ( real64 ), private , allocatable , dimension (:) :: rc2 real ( real64 ), private , allocatable , dimension (:) :: rc3 real ( real64 ), private , allocatable , dimension (:) :: rc4 real ( real64 ), private , allocatable , dimension (:) :: rc5 contains procedure , public :: pre_step_action => rk45_pre_step !! Performs any pre-step actions. procedure , public :: get_order => rk45_get_order !! Gets the order of the integrator. procedure , public :: get_is_fsal => rk45_get_is_fsal !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. procedure , public :: get_stage_count => rk45_get_stage_count !! Gets the stage count for this integrator. procedure , private :: initialize_interp => rk45_init_interp !! Allocates storage for the interpolation process. procedure , public :: attempt_step => rk45_attempt_step !! Attempts an integration step for this integrator. procedure , public :: post_step_action => rk45_set_up_interp !! Sets up the interpolation process as the post-step action. procedure , public :: interpolate => rk45_interp !! Performs the interpolation. end type type , extends ( single_step_integrator ) :: runge_kutta_23 !! The Bogacki-Shampine integrator (3rd order with an embedded 2nd order !! used for error estimation). real ( real64 ), private , allocatable , dimension (:) :: rc1 real ( real64 ), private , allocatable , dimension (:) :: rc2 real ( real64 ), private , allocatable , dimension (:) :: rc3 contains procedure , public :: pre_step_action => rk23_pre_step !! Performs any pre-step actions. procedure , private :: initialize_interp => rk23_init_interp !! Allocates storage for the interpolation process. procedure , public :: get_order => rk23_get_order !! Gets the order of the integrator. procedure , public :: get_is_fsal => rk23_get_is_fsal !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. procedure , public :: get_stage_count => rk23_get_stage_count !! Gets the stage count for this integrator. procedure , public :: attempt_step => rk23_attempt_step !! Attempts an integration step for this integrator. procedure , public :: post_step_action => rk23_set_up_interp !! Sets up the interpolation process as the post-step action. procedure , public :: interpolate => rk23_interp !! Performs the interpolation. end type type , extends ( single_step_integrator ) :: runge_kutta_853 !! An 8th order Runge-Kutta integrator with embedded 5th and 3rd order !! solutions for error estimation. real ( real64 ), private , allocatable , dimension (:) :: yerr2 real ( real64 ), private , allocatable , dimension (:) :: rc1 real ( real64 ), private , allocatable , dimension (:) :: rc2 real ( real64 ), private , allocatable , dimension (:) :: rc3 real ( real64 ), private , allocatable , dimension (:) :: rc4 real ( real64 ), private , allocatable , dimension (:) :: rc5 real ( real64 ), private , allocatable , dimension (:) :: rc6 real ( real64 ), private , allocatable , dimension (:) :: rc7 real ( real64 ), private , allocatable , dimension (:) :: rc8 real ( real64 ), private , allocatable , dimension (:) :: work real ( real64 ), private :: m_stepSize contains procedure , public :: pre_step_action => rk853_pre_step !! Performs any pre-step actions. ! procedure, private :: initialize => rk853_init !! Initializes private storage arrays for the integrator. procedure , private :: initialize_interp => rk853_init_interp !! Allocates storage for the interpolation process. procedure , public :: get_order => rk853_get_order !! Gets the order of the integrator. procedure , public :: get_is_fsal => rk853_get_is_fsal !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. procedure , public :: get_stage_count => rk853_get_stage_count !! Gets the stage count for this integrator. procedure , public :: attempt_step => rk853_attempt_step !! Attempts an integration step for this integrator. procedure , public :: post_step_action => rk853_set_up_interp !! Sets up the interpolation process as the post-step action. procedure , public :: interpolate => rk853_interp !! Performs the interpolation. procedure , public :: compute_error_norm => rk853_estimate_error !! Computes the norm of the scaled error estimate. end type contains ! ****************************************************************************** ! RUNGE_KUTTA_45 ! ------------------------------------------------------------------------------ subroutine rk45_pre_step ( this , prevs , sys , h , x , y , f , args , err ) !! Placeholder routine for any pre-step actions. class ( runge_kutta_45 ), intent ( inout ) :: this !! The runge_kutta_45 object. logical , intent ( in ) :: prevs !! Defines the status of the previous step.  The value is true !! if the previous step was successful; else, false if the !! previous step failed. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. ! Process return end subroutine ! ------------------------------------------------------------------------------ pure function rk45_get_order ( this ) result ( rst ) !! Gets the order of the integrator. class ( runge_kutta_45 ), intent ( in ) :: this !! The runge_kutta_45 object. integer ( int32 ) :: rst !! The order. rst = 5 end function ! ------------------------------------------------------------------------------ pure function rk45_get_is_fsal ( this ) result ( rst ) !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. class ( runge_kutta_45 ), intent ( in ) :: this !! The runge_kutta_45 object. logical :: rst !! True for a FSAL integrator; else, false. rst = . true . end function ! ------------------------------------------------------------------------------ pure function rk45_get_stage_count ( this ) result ( rst ) !! Gets the stage count for this integrator. class ( runge_kutta_45 ), intent ( in ) :: this !! The runge_kutta_45 object. integer ( int32 ) :: rst !! The stage count. rst = 7 end function ! ------------------------------------------------------------------------------ subroutine rk45_init_interp ( this , neqn ) !! Allocates storage for the interpolation process. class ( runge_kutta_45 ), intent ( inout ) :: this !! The runge_kutta_45 object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. ! Process if ( allocated ( this % rc1 )) then if ( size ( this % rc1 ) == neqn ) then ! All is good return else deallocate ( this % rc1 ) deallocate ( this % rc2 ) deallocate ( this % rc3 ) deallocate ( this % rc4 ) deallocate ( this % rc5 ) end if end if allocate ( & this % rc1 ( neqn ), & this % rc2 ( neqn ), & this % rc3 ( neqn ), & this % rc4 ( neqn ), & this % rc5 ( neqn ) & ) end subroutine ! ------------------------------------------------------------------------------ subroutine rk45_attempt_step ( this , sys , h , x , y , f , yn , fn , yerr , k , args ) use diffeq_dprk45_constants !! Attempts an integration step for this integrator. class ( runge_kutta_45 ), intent ( inout ) :: this !! The runge_kutta_45 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where this routine will write the next !! solution estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: fn !! An N-element array where this routine will write the next !! derivative estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: yerr !! An N-element array where this routine will write an estimate !! of the error in each equation. real ( real64 ), intent ( out ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: n ! Initialization n = size ( y ) ! Process ! k1 = f as the derivatives were computed from the previous step k (:, 1 ) = f yn = y + h * a21 * f call sys % fcn ( x + h * c2 , yn , k (:, 2 ), args ) yn = y + h * ( a31 * f + a32 * k (:, 2 )) call sys % fcn ( x + h * c3 , yn , k (:, 3 ), args ) yn = y + h * ( a41 * f + a42 * k (:, 2 ) + a43 * k (:, 3 )) call sys % fcn ( x + h * c4 , yn , k (:, 4 ), args ) yn = y + h * ( a51 * f + a52 * k (:, 2 ) + a53 * k (:, 3 ) + a54 * k (:, 4 )) call sys % fcn ( x + h * c5 , yn , k (:, 5 ), args ) yn = y + h * ( a61 * f + a62 * k (:, 2 ) + a63 * k (:, 3 ) + a64 * k (:, 4 ) + & a65 * k (:, 5 )) call sys % fcn ( x + h * c6 , yn , k (:, 6 ), args ) yn = y + h * ( a71 * f + a73 * k (:, 3 ) + a74 * k (:, 4 ) + a75 * k (:, 5 ) + a76 * k (:, 6 )) call sys % fcn ( x + h * c7 , yn , fn , args ) ! Compute the error estimate yerr = h * ( e1 * f + e2 * k (:, 2 ) + e3 * k (:, 3 ) + e4 * k (:, 4 ) + & e5 * k (:, 5 ) + e6 * k (:, 6 ) + e7 * fn ) end subroutine ! ------------------------------------------------------------------------------ subroutine rk45_set_up_interp ( this , sys , dense , x , xn , y , yn , f , fn , k , args ) use diffeq_dprk45_constants !! Sets up the interpolation process. class ( runge_kutta_45 ), intent ( inout ) :: this !! The runge_kutta_45 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. logical , intent ( in ) :: dense !! Determines if dense output is requested (true); else, false. real ( real64 ), intent ( in ) :: x !! The previous value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the solution at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the derivatives at x. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: h , ydiff , bspl ! Quick Return if (. not . dense ) return ! Initialization n = size ( y ) call this % initialize_interp ( n ) h = xn - x ! Process do i = 1 , n this % rc1 ( i ) = y ( i ) ydiff = yn ( i ) - y ( i ) this % rc2 ( i ) = ydiff bspl = h * f ( i ) - ydiff this % rc3 ( i ) = bspl this % rc4 ( i ) = ydiff - h * fn ( i ) - bspl this % rc5 = h * ( d1 * f ( i ) + d3 * k ( i , 3 ) + d4 * k ( i , 4 ) + & d5 * k ( i , 5 ) + d6 * k ( i , 6 ) + d7 * fn ( i )) end do end subroutine ! ------------------------------------------------------------------------------ subroutine rk45_interp ( this , x , xn , yn , fn , xn1 , yn1 , fn1 , y ) !! Performs the interpolation. class ( runge_kutta_45 ), intent ( in ) :: this !! The runge_kutta_45 object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which to compute !! the interpolation. real ( real64 ), intent ( in ) :: xn !! The previous value of the independent variable at which the !! solution is computed. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( in ) :: xn1 !! The value of the independent variable at xn + h. real ( real64 ), intent ( in ), dimension (:) :: yn1 !! An N-element array containing the solution at xn + h. real ( real64 ), intent ( in ), dimension (:) :: fn1 !! An N-element array containing the derivatives at xn + h. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where this routine will write the !! solution values interpolated at x. ! Local Variables real ( real64 ) :: h , s , s1 ! Process h = xn1 - xn s = ( x - xn ) / h s1 = 1.0d0 - s y = this % rc1 + s * ( this % rc2 + s1 * ( this % rc3 + & s * ( this % rc4 + s1 * this % rc5 ))) end subroutine ! ****************************************************************************** ! RUNGE_KUTTA_23 ! ------------------------------------------------------------------------------ subroutine rk23_pre_step ( this , prevs , sys , h , x , y , f , args , err ) !! Placeholder routine for any pre-step actions. class ( runge_kutta_23 ), intent ( inout ) :: this !! The runge_kutta_23 object. logical , intent ( in ) :: prevs !! Defines the status of the previous step.  The value is true !! if the previous step was successful; else, false if the !! previous step failed. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. ! Process return end subroutine ! ------------------------------------------------------------------------------ pure function rk23_get_order ( this ) result ( rst ) !! Gets the order of the integrator. class ( runge_kutta_23 ), intent ( in ) :: this !! The runge_kutta_23 object. integer ( int32 ) :: rst !! The order. rst = 3 end function ! ------------------------------------------------------------------------------ pure function rk23_get_is_fsal ( this ) result ( rst ) !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. class ( runge_kutta_23 ), intent ( in ) :: this !! The runge_kutta_23 object. logical :: rst !! True for a FSAL integrator; else, false. rst = . true . end function ! ------------------------------------------------------------------------------ pure function rk23_get_stage_count ( this ) result ( rst ) !! Gets the stage count for this integrator. class ( runge_kutta_23 ), intent ( in ) :: this !! The runge_kutta_23 object. integer ( int32 ) :: rst !! The stage count. rst = 4 end function ! ------------------------------------------------------------------------------ subroutine rk23_init_interp ( this , neqn ) !! Allocates storage for the interpolation process. class ( runge_kutta_23 ), intent ( inout ) :: this !! The runge_kutta_23 object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. ! Process if ( allocated ( this % rc1 )) then if ( size ( this % rc1 ) == neqn ) then ! All is good return else deallocate ( this % rc1 ) deallocate ( this % rc2 ) deallocate ( this % rc3 ) end if end if allocate ( & this % rc1 ( neqn ), & this % rc2 ( neqn ), & this % rc3 ( neqn ) & ) end subroutine ! ------------------------------------------------------------------------------ subroutine rk23_attempt_step ( this , sys , h , x , y , f , yn , fn , yerr , k , args ) use diffeq_bsrk32_constants !! Attempts an integration step for this integrator. class ( runge_kutta_23 ), intent ( inout ) :: this !! The runge_kutta_23 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where this routine will write the next !! solution estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: fn !! An N-element array where this routine will write the next !! derivative estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: yerr !! An N-element array where this routine will write an estimate !! of the error in each equation. real ( real64 ), intent ( out ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: n ! Initialization n = size ( y ) ! Process ! k1 = f as the derivatives were computed from the previous step k (:, 1 ) = f yn = y + h * a21 * f call sys % fcn ( x + h * c2 , yn , k (:, 2 ), args ) yn = y + h * ( a31 * f + a32 * k (:, 2 )) call sys % fcn ( x + h * c3 , yn , k (:, 3 ), args ) yn = y + h * ( a41 * f + a42 * k (:, 2 ) + a43 * k (:, 3 )) call sys % fcn ( x + h * c4 , yn , fn , args ) ! Compute the error estimate yerr = h * ( e1 * f + e2 * k (:, 2 ) + e3 * k (:, 3 ) + e4 * fn ) end subroutine ! ------------------------------------------------------------------------------ subroutine rk23_set_up_interp ( this , sys , dense , x , xn , y , yn , f , fn , k , args ) use diffeq_bsrk32_constants !! Sets up the interpolation process. class ( runge_kutta_23 ), intent ( inout ) :: this !! The runge_kutta_23 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. logical , intent ( in ) :: dense !! Determines if dense output is requested (true); else, false. real ( real64 ), intent ( in ) :: x !! The previous value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the solution at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the derivatives at x. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: n real ( real64 ) :: h ! Quick Return if (. not . dense ) return ! Initialization h = xn - x n = size ( y ) call this % initialize_interp ( n ) ! Process this % rc1 = - ( y - yn + f * h ) / h ** 2 this % rc2 = f - 2.0d0 * x * this % rc1 this % rc3 = y - this % rc1 * x ** 2 - this % rc2 * x end subroutine ! ------------------------------------------------------------------------------ subroutine rk23_interp ( this , x , xn , yn , fn , xn1 , yn1 , fn1 , y ) !! Performs the interpolation. class ( runge_kutta_23 ), intent ( in ) :: this !! The runge_kutta_23 object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which to compute !! the interpolation. real ( real64 ), intent ( in ) :: xn !! The previous value of the independent variable at which the !! solution is computed. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( in ) :: xn1 !! The value of the independent variable at xn + h. real ( real64 ), intent ( in ), dimension (:) :: yn1 !! An N-element array containing the solution at xn + h. real ( real64 ), intent ( in ), dimension (:) :: fn1 !! An N-element array containing the derivatives at xn + h. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where this routine will write the !! solution values interpolated at x. ! Process y = this % rc1 * x ** 2 + this % rc2 * x + this % rc3 end subroutine ! ****************************************************************************** ! RUNGE_KUTTA_853 ! ------------------------------------------------------------------------------ subroutine rk853_pre_step ( this , prevs , sys , h , x , y , f , args , err ) !! Placeholder routine for any pre-step actions. class ( runge_kutta_853 ), intent ( inout ) :: this !! The runge_kutta_853 object. logical , intent ( in ) :: prevs !! Defines the status of the previous step.  The value is true !! if the previous step was successful; else, false if the !! previous step failed. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to !! provide error handling. ! Process return end subroutine ! ------------------------------------------------------------------------------ subroutine rk853_init_interp ( this , neqn ) !! Allocates storage for the interpolation process. class ( runge_kutta_853 ), intent ( inout ) :: this !! The runge_kutta_853 object. integer ( int32 ), intent ( in ) :: neqn !! The number of equations being integrated. ! Process if ( allocated ( this % rc1 )) then if ( size ( this % rc1 ) == neqn ) then ! All is good return else deallocate ( this % rc1 ) deallocate ( this % rc2 ) deallocate ( this % rc3 ) deallocate ( this % rc4 ) deallocate ( this % rc5 ) deallocate ( this % rc6 ) deallocate ( this % rc7 ) deallocate ( this % rc8 ) deallocate ( this % work ) end if end if allocate ( & this % rc1 ( neqn ), & this % rc2 ( neqn ), & this % rc3 ( neqn ), & this % rc4 ( neqn ), & this % rc5 ( neqn ), & this % rc6 ( neqn ), & this % rc7 ( neqn ), & this % rc8 ( neqn ), & this % work ( neqn ) & ) end subroutine ! ------------------------------------------------------------------------------ pure function rk853_get_order ( this ) result ( rst ) !! Gets the order of the integrator. class ( runge_kutta_853 ), intent ( in ) :: this !! The runge_kutta_853 object. integer ( int32 ) :: rst !! The order. rst = 8 end function ! ------------------------------------------------------------------------------ pure function rk853_get_is_fsal ( this ) result ( rst ) !! Gets a logical parameter stating if this is a first-same-as-last !! (FSAL) integrator. class ( runge_kutta_853 ), intent ( in ) :: this !! The runge_kutta_853 object. logical :: rst !! True for a FSAL integrator; else, false. rst = . true . end function ! ------------------------------------------------------------------------------ pure function rk853_get_stage_count ( this ) result ( rst ) !! Gets the stage count for this integrator. class ( runge_kutta_853 ), intent ( in ) :: this !! The runge_kutta_853 object. integer ( int32 ) :: rst !! The stage count. rst = 12 end function ! ------------------------------------------------------------------------------ subroutine rk853_attempt_step ( this , sys , h , x , y , f , yn , fn , yerr , k , args ) use diffeq_rk853_constants !! Attempts an integration step for this integrator. class ( runge_kutta_853 ), intent ( inout ) :: this !! The runge_kutta_853 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. real ( real64 ), intent ( in ) :: h !! The current step size. real ( real64 ), intent ( in ) :: x !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the current solution at x. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the values of the derivatives !! at x. real ( real64 ), intent ( out ), dimension (:) :: yn !! An N-element array where this routine will write the next !! solution estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: fn !! An N-element array where this routine will write the next !! derivative estimate at x + h. real ( real64 ), intent ( out ), dimension (:) :: yerr !! An N-element array where this routine will write an estimate !! of the error in each equation. real ( real64 ), intent ( out ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: n ! Initialization n = size ( y ) if (. not . allocated ( this % yerr2 )) allocate ( this % yerr2 ( n )) ! Process ! k1 = f as the derivatives were computed outside of this routine k (:, 1 ) = f yn = y + h * a21 call sys % fcn ( x + c2 * h , yn , k (:, 2 ), args ) yn = y + h * ( a31 * f + a32 * k (:, 2 )) call sys % fcn ( x + c3 * h , yn , k (:, 3 ), args ) yn = y + h * ( a41 * f + a43 * k (:, 3 )) call sys % fcn ( x + c4 * h , yn , k (:, 4 ), args ) yn = y + h * ( a51 * f + a53 * k (:, 3 ) + a54 * k (:, 4 )) call sys % fcn ( x + c5 * h , yn , k (:, 5 ), args ) yn = y + h * ( a61 * f + a64 * k (:, 4 ) + a65 * k (:, 5 )) call sys % fcn ( x + c6 * h , yn , k (:, 6 ), args ) yn = y + h * ( a71 * f + a74 * k (:, 4 ) + a75 * k (:, 5 ) + a76 * k (:, 6 )) call sys % fcn ( x + c7 * h , yn , k (:, 7 ), args ) yn = y + h * ( a81 * f + a84 * k (:, 4 ) + a85 * k (:, 5 ) + a86 * k (:, 6 ) + & a87 * k (:, 7 )) call sys % fcn ( x + c8 * h , yn , k (:, 8 ), args ) yn = y + h * ( a91 * f + a94 * k (:, 4 ) + a95 * k (:, 5 ) + a96 * k (:, 6 ) + & a97 * k (:, 7 ) + a98 * k (:, 8 )) call sys % fcn ( x + c9 * h , yn , k (:, 9 ), args ) yn = y + h * ( a101 * f + a104 * k (:, 4 ) + a105 * k (:, 5 ) + & a106 * k (:, 6 ) + a107 * k (:, 7 ) + a108 * k (:, 8 ) + a109 * k (:, 9 )) call sys % fcn ( x + c10 * h , yn , k (:, 10 ), args ) yn = y + h * ( a111 * f + a114 * k (:, 4 ) + a115 * k (:, 5 ) + & a116 * k (:, 6 ) + a117 * k (:, 7 ) + a118 * k (:, 8 ) + a119 * k (:, 9 ) + & a1110 * k (:, 10 )) call sys % fcn ( x + c11 * h , yn , k (:, 2 ), args ) yn = y + h * ( a121 * f + a124 * k (:, 4 ) + a125 * k (:, 5 ) + & a126 * k (:, 6 ) + a127 * k (:, 7 ) + a128 * k (:, 8 ) + a129 * k (:, 9 ) + & a1210 * k (:, 10 ) + a1211 * k (:, 2 )) call sys % fcn ( x + h , yn , k (:, 3 ), args ) k (:, 4 ) = b1 * f + b6 * k (:, 6 ) + b7 * k (:, 7 ) + b8 * k (:, 8 ) + & b9 * k (:, 9 ) + b10 * k (:, 10 ) + b11 * k (:, 2 ) + b12 * k (:, 3 ) yn = y + h * k (:, 4 ) call sys % fcn ( x + h , yn , fn , args ) yerr = k (:, 4 ) - bhh1 * f - bhh2 * k (:, 9 ) - bhh3 * k (:, 3 ) this % yerr2 = er1 * f + er6 * k (:, 6 ) + er7 * k (:, 7 ) + er8 * k (:, 8 ) + & er9 * k (:, 9 ) + er10 * k (:, 10 ) + er11 * k (:, 2 ) + er12 * k (:, 3 ) this % m_stepSize = h end subroutine ! ------------------------------------------------------------------------------ subroutine rk853_set_up_interp ( this , sys , dense , x , xn , y , yn , f , fn , k , args ) use diffeq_rk853_constants !! Sets up the interpolation process. class ( runge_kutta_853 ), intent ( inout ) :: this !! The runge_kutta_853 object. class ( ode_container ), intent ( inout ) :: sys !! The ode_container object containing the ODE's to integrate. logical , intent ( in ) :: dense !! Determines if dense output is requested (true); else, false. real ( real64 ), intent ( in ) :: x !! The previous value of the independent variable. real ( real64 ), intent ( in ) :: xn !! The current value of the independent variable. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the solution at x. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: f !! An N-element array containing the derivatives at x. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! An N-by-NSTAGES matrix containing the derivatives at each stage. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass information !! in and out of the differential equation subroutine. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: ydiff , bspl , h ! Quick Return if (. not . dense ) return ! Initialization n = size ( y ) h = xn - x call this % initialize_interp ( n ) ! Process do i = 1 , n this % rc1 ( i ) = y ( i ) ydiff = yn ( i ) - y ( i ) this % rc2 ( i ) = ydiff bspl = h * f ( i ) - ydiff this % rc3 ( i ) = bspl this % rc4 ( i ) = ydiff - h * fn ( i ) - bspl this % rc5 ( i ) = d41 * f ( i ) + d46 * k ( i , 6 ) + d47 * k ( i , 7 ) + & d48 * k ( i , 8 ) + d49 * k ( i , 9 ) + d410 * k ( i , 10 ) + & d411 * k ( i , 2 ) + d412 * k ( i , 3 ) this % rc6 ( i ) = d51 * f ( i ) + d56 * k ( i , 6 ) + d57 * k ( i , 7 ) + & d58 * k ( i , 8 ) + d59 * k ( i , 9 ) + d510 * k ( i , 10 ) + & d511 * k ( i , 2 ) + d512 * k ( i , 3 ) this % rc7 ( i ) = d61 * f ( i ) + d66 * k ( i , 6 ) + d67 * k ( i , 7 ) + & d68 * k ( i , 8 ) + d69 * k ( i , 9 ) + d610 * k ( i , 10 ) + & d611 * k ( i , 2 ) + d612 * k ( i , 3 ) this % rc8 ( i ) = d71 * f ( i ) + d76 * k ( i , 6 ) + d77 * k ( i , 7 ) + & d78 * k ( i , 8 ) + d79 * k ( i , 9 ) + d710 * k ( i , 10 ) + & d711 * k ( i , 2 ) + d712 * k ( i , 3 ) end do this % work = y + h * ( a141 * f + a147 * k (:, 7 ) + a148 * k (:, 8 ) + & a149 * k (:, 9 ) + a1410 * k (:, 10 ) + a1411 * k (:, 2 ) + & a1412 * k (:, 3 ) + a1413 * fn ) call sys % fcn ( x + c14 * h , this % work , k (:, 10 )) this % work = y + h * ( a151 * f + a156 * k (:, 6 ) + a157 * k (:, 7 ) + & a158 * k (:, 8 ) + a1511 * k (:, 2 ) + a1512 * k (:, 3 ) + a1513 * fn + & a1514 * k (:, 10 )) call sys % fcn ( x + c15 * h , this % work , k (:, 2 )) this % work = y + h * ( a161 * f + a166 * k (:, 6 ) + a167 * k (:, 7 ) + & a168 * k (:, 8 ) + a169 * k (:, 9 ) + a1613 * fn + a1614 * k (:, 10 ) + & a1615 * k (:, 2 )) call sys % fcn ( x + c16 * h , this % work , k (:, 3 )) do i = 1 , n this % rc5 ( i ) = h * ( this % rc5 ( i ) + d413 * fn ( i ) + d414 * k ( i , 10 ) + & d415 * k ( i , 2 ) + d416 * k ( i , 3 )) this % rc6 ( i ) = h * ( this % rc6 ( i ) + d513 * fn ( i ) + d514 * k ( i , 10 ) + & d515 * k ( i , 2 ) + d516 * k ( i , 3 )) this % rc7 ( i ) = h * ( this % rc7 ( i ) + d613 * fn ( i ) + d614 * k ( i , 10 ) + & d615 * k ( i , 2 ) + d616 * k ( i , 3 )) this % rc8 ( i ) = h * ( this % rc8 ( i ) + d713 * fn ( i ) + d714 * k ( i , 10 ) + & d715 * k ( i , 2 ) + d716 * k ( i , 3 )) end do end subroutine ! ------------------------------------------------------------------------------ subroutine rk853_interp ( this , x , xn , yn , fn , xn1 , yn1 , fn1 , y ) !! Performs the interpolation. class ( runge_kutta_853 ), intent ( in ) :: this !! The runge_kutta_853 object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which to compute !! the interpolation. real ( real64 ), intent ( in ) :: xn !! The previous value of the independent variable at which the !! solution is computed. real ( real64 ), intent ( in ), dimension (:) :: yn !! An N-element array containing the solution at xn. real ( real64 ), intent ( in ), dimension (:) :: fn !! An N-element array containing the derivatives at xn. real ( real64 ), intent ( in ) :: xn1 !! The value of the independent variable at xn + h. real ( real64 ), intent ( in ), dimension (:) :: yn1 !! An N-element array containing the solution at xn + h. real ( real64 ), intent ( in ), dimension (:) :: fn1 !! An N-element array containing the derivatives at xn + h. real ( real64 ), intent ( out ), dimension (:) :: y !! An N-element array where this routine will write the !! solution values interpolated at x. ! Local Variables real ( real64 ) :: h , s , s1 ! Process h = xn1 - xn s = ( x - xn ) / h s1 = 1.0d0 - s y = this % rc1 + s * ( this % rc2 + s1 * ( this % rc3 + s * ( this % rc4 + s1 * & ( this % rc5 + s * ( this % rc6 + s1 * ( this % rc7 + s * this % rc8 )))))) end subroutine ! ------------------------------------------------------------------------------ pure function rk853_estimate_error ( this , y , yest , yerr ) result ( rst ) !! Computes the norm of the scaled error estimate.  A value less than one !! indicates a successful step.  A value greater than one suggests that the !! results do not meet the requested tolerances. class ( runge_kutta_853 ), intent ( in ) :: this !! The runge_kutta_853 object. real ( real64 ), intent ( in ), dimension (:) :: y !! The previously accepted solution array (N-element). real ( real64 ), intent ( in ), dimension ( size ( y )) :: yest !! An N-element array containing the next solution point estimate. real ( real64 ), intent ( in ), dimension ( size ( y )) :: yerr !! An N-element array containing the estimate of error for each !! equation. real ( real64 ) :: rst !! The norm of the scaled error. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: err , err2 , sf , denom , atol , rtol ! Initialization n = size ( y ) atol = this % get_absolute_tolerance () rtol = this % get_relative_tolerance () err = 0.0d0 err2 = 0.0d0 ! Process do i = 1 , n sf = atol + rtol * max ( abs ( y ( i )), abs ( yest ( i ))) err2 = err2 + ( yerr ( i ) / sf ) ** 2 err = err + ( this % yerr2 ( i ) / sf ) ** 2 end do denom = err + 1.0d-2 * err2 if ( denom <= 0.0d0 ) denom = 1.0d0 rst = err * sqrt ( 1.0d0 / ( n * denom )) * abs ( this % m_stepSize ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\diffeq_runge_kutta.f90.html"}]}